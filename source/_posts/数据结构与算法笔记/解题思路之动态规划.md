---
title: 解题思路之动态规划
toc: true
categories:
- 练习笔记
abbrlink: d6cdfd6a
date: 2023-02-16 17:11:19
tags:
- LeetCode

---
# 什么是动态规划 
动态规划，英文：Dynamic Programming，简称DP。
简单理解，动态规划的每一个状态都能由上一个状态推导而来

# 解题步骤
以斐波那契数列为例，动态规划问题可以拆解为五步曲：

1、确定dp数组和下标含义：第n个斐波那契数是`dp[n]`

2、确定递推公式（也可叫状态转移方程）：`dp[n] = dp[n-1] + dp[n-2]`

3、dp数组初始化：`dp[0] = 0; dp[1] = 1`

4、确定遍历顺序：从前到后遍历，`dp[n]`依赖`dp[n-1]`和`dp[n-2]`

5、举例推导dp数组：当`n=10`时，dp数组应该为：`0 1 1 2 3 5 8 13 21 34 55`

# 背包问题

![VN3QSV.png](https://i.imgloc.com/2023/06/26/VN3QSV.png)

## 01背包解法

[详细讲解](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#%E4%BA%8C%E7%BB%B4dp%E6%95%B0%E7%BB%8401%E8%83%8C%E5%8C%85)

> 有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。  
> 举例：n=3, w=4, weight=[1,3,4], value=[15,20,30]

**暴力解法：** 利用回溯算法枚举所有组合，每个物品有取和不取两个状态，时间复杂度是O(2^n)。  

### 解法一：二维dp数组

解题五步曲：  

1、`dp[i][j]` 表示从下标为`[0-i]`的物品里任意取，放进容量为`j`的背包，价值总和最大是多少  

2、不放物品`i`时，`dp[i][j]` = `dp[i-1][j]`；  
  放物品`i`时，`dp[i][j]` = dp[i - 1][j - weight[i]] + value[i]，`dp[i - 1][j - weight[i]]`为背包容量为`j - weight[i]`的时候不放物品i的最大价值

3、初始化背包容量`j=0`时，最大价值一定为0，`dp[i][0]=0`  
初始化`i=0`时各容量下背包能装入的最大价值，当`j<weight[0]`时，dp[0][j]=0；当`j>=weight[0]`时，dp[0][j]=value[0]`

4、双层遍历背包和物品，顺序没有关系，先遍历物品易理解

5、举例推导：`n=3, w=4, weight=[1,3,4], value=[15,20,30]`

![VNp06d.png](https://i.imgloc.com/2023/06/26/VNp06d.png)

**java代码实现:**
```java
public class BagProblem {
	public static void main(String[] args) {
		int[] weight = {1,3,4};
		int[] value = {15,20,30};
		int bagSize = 4;
		testWeightBagProblem(weight,value,bagSize);
	}

	/**
	 * 动态规划获得结果
	 * @param weight  物品的重量
	 * @param value   物品的价值
	 * @param bagSize 背包的容量
	 */
	public static void testWeightBagProblem(int[] weight, int[] value, int bagSize){

		// 创建dp数组
		int goods = weight.length;  // 获取物品的数量
		int[][] dp = new int[goods][bagSize + 1];

		// 初始化dp数组
		// 创建数组后，其中默认的值就是0
		for (int j = weight[0]; j <= bagSize; j++) {
			dp[0][j] = value[0];
		}

		// 填充dp数组
		for (int i = 1; i < weight.length; i++) {
			for (int j = 1; j <= bagSize; j++) {
				if (j < weight[i]) {
					/**
					 * 当前背包的容量都没有当前物品i大的时候，是不放物品i的
					 * 那么前i-1个物品能放下的最大价值就是当前情况的最大价值
					 */
					dp[i][j] = dp[i-1][j];
				} else {
					/**
					 * 当前背包的容量可以放下物品i
					 * 那么此时分两种情况：
					 *    1、不放物品i
					 *    2、放物品i
					 * 比较这两种情况下，哪种背包中物品的最大价值最大
					 */
					dp[i][j] = Math.max(dp[i-1][j] , dp[i-1][j-weight[i]] + value[i]);
				}
			}
		}

		// 打印dp数组
		for (int i = 0; i < goods; i++) {
			for (int j = 0; j <= bagSize; j++) {
				System.out.print(dp[i][j] + "\t");
			}
			System.out.println("\n");
		}
	}
}
```

###解法二：一维dp数组

在使用二维数组的时候，递推公式：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`

可以发现如果把`dp[i - 1]`那一层拷贝到`dp[i]`上，表达式完全可以是：`dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])`

与其把`dp[i - 1]`这一层拷贝到`dp[i]`上，不如只用一个一维数组了，只用`dp[j]`（一维数组，也可以理解是一个滚动数组）。

解题五步曲：

1、`dp[j]`表示容量为`j`的背包能装下的最大价值

2、不放物品`i`时，`dp[j] = dp[j]`；  
放物品i时，`dp[j] = dp[j - weight[i]] + value[i]`为背包容量为`j - weight[i]`的时候不放物品i的最大价值  
所以`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`

3、初始化背包容量`j=0`时，`dp[j]=0` 

4、双层遍历物品和背包，背包倒序遍历，因为当前`dp[j]`来自上一层左侧的值，如果正序遍历，左侧的值都被当前层覆盖了

5、举例推导：`n=3, w=4, weight=[1,3,4], value=[15,20,30]`  

![VN6Nfz.png](https://i.imgloc.com/2023/06/27/VN6Nfz.png)

**java代码实现：**
```java
public static void main(String[] args) {
    int[] weight = {1, 3, 4};
    int[] value = {15, 20, 30};
    int bagWight = 4;
    testWeightBagProblem(weight, value, bagWight);
}

public static void testWeightBagProblem(int[] weight, int[] value, int bagWeight){
    int wLen = weight.length;
    //定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值
    int[] dp = new int[bagWeight + 1];
    //遍历顺序：先遍历物品，再遍历背包容量
    for (int i = 0; i < wLen; i++){
        for (int j = bagWeight; j >= weight[i]; j--){
            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    //打印dp数组
    for (int j = 0; j <= bagWeight; j++){
        System.out.print(dp[j] + " ");
    }
}
```

## 完全背包解法

[详细讲解](https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85)

> 有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个**（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。  
> 举例：n=3, w=4, weight=[1,3,4], value=[15,20,30]

**01背包和完全背包唯一不同就是体现在遍历顺序上** 。01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。而完全背包的物品是可以添加多次的，所以要从小到大去遍历。可以借由二维dp数组解法理解，在01背包中当前状态继承自上层左侧，在完全背包中当前状态继承自本层左侧，所以压缩成一维数组解法，01背包内嵌的循环倒序遍历，完全背包内嵌的循环是正序遍历。

01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！

二维dp数组解题五步曲：

1、`dp[i][j]` 表示从下标为`[0-i]`的物品里可重复任意取，放进容量为`j`的背包，价值总和最大是多少

2、不放物品`i`时，`dp[i][j]` = `dp[i-1][j]`；  
放物品`i`时，`dp[i][j]` = dp[i][j - weight[i]] + value[i]，`dp[i][j - weight[i]]`为背包容量为`j - weight[i]`的时候，在`[0-i]`的物品里可重复任意取的最大价值

3、初始化背包容量`j=0`时，最大价值一定为0，`dp[i][0]=0`  
初始化`i=0`时各容量下背包能装入的最大价值，当`j<weight[0]`时，dp[0][j]=0；当`j>=weight[0]`时，dp[0][j]=dp[0][j-weight[0]]+value[0]`

4、双层遍历背包和物品，顺序没有关系，先遍历物品易理解

5、举例推导：`n=3, w=4, weight=[1,3,4], value=[15,20,30]`。（示意图忽略）

**java代码实现：**
```java
// 01背包核心代码
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}

// 完全背包核心代码
for(int i = 0; i < weight.size(); i++) { // 遍历物品
  for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
    dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
  }
} 
```
```java
// 完全背包完整代码：一维dp数组解法
//先遍历物品，再遍历背包
private static void testCompletePack() {
		int[] weight = {1, 3, 4};
		int[] value = {15, 20, 30};
		int bagWeight = 4;
		int[] dp = new int[bagWeight + 1];
		for (int i = 0; i < weight.length; i++) { // 遍历物品
			for (int j = weight[i]; j <= bagWeight; j++) { // 遍历背包容量
				dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
			}
		}
		for (int maxValue : dp) {
			System.out.println(maxValue + "   ");
		}
	}

//先遍历背包，再遍历物品
private static void testCompletePackAnotherWay() {
	int[] weight = {1, 3, 4};
	int[] value = {15, 20, 30};
	int bagWeight = 4;
	int[] dp = new int[bagWeight + 1];
	for (int i = 1; i <= bagWeight; i++) { // 遍历背包容量
		for (int j = 0; j < weight.length; j++) { // 遍历物品
			if (i - weight[j] >= 0) {
				dp[i] = Math.max(dp[i], dp[i - weight[j]] + value[j]);
			}
		}
	}
	for (int maxValue : dp) {
		System.out.println(maxValue + "   ");
	}
}
```

# 参考资料
[代码随想录之动态规划](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)

