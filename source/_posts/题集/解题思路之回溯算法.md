---
title: 解题思路之回溯算法
tags:
  - LeetCode
categories:
  - 题集
toc: true
abbrlink: 49adf57d
date: 2023-05-19 14:34:49
---

# 什么是回溯算法

回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，回溯函数也就是递归函数。  

回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。

回溯法，一般可以解决如下几种问题：
* 组合问题：N个数里面按一定规则找出k个数的集合
* 切割问题：一个字符串按一定规则有几种切割方式
* 子集问题：一个N个数的集合里有多少符合条件的子集
* 排列问题：N个数按一定规则全排列，有几种排列方式
* 棋盘问题：N皇后，解数独等等

# 解题步骤

1、回溯函数模板返回值以及参数

```java
vector<vector<int>> result;
vector<int> path;
void backtracking(参数)
```

2、终止条件

```java
if (终止条件) {
    存放结果;
    return;
}
```

3、回溯搜索的遍历过程

![VfjGSo.png](https://i.328888.xyz/2023/05/19/VfjGSo.png)

```java
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果;
}
```
for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。  
backtracking是自己调用自己，实现递归。

综上，回溯算法的模板框架如下：
```java
vector<vector<int>> result;
vector<int> path;
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果;
    }
}
```

## 例子：全排列
题目：给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。  
输入：nums = [1,2,3]   
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

抽象成树形结构如下：
![Vf87Gp.png](https://i.328888.xyz/2023/05/19/Vf87Gp.png)

代码实现如下：
```java
class Solution {

	List<List<Integer>> res = new ArrayList<>();// 存放符合条件结果的集合
	LinkedList<Integer> path = new LinkedList<>();// 用来存放符合条件结果
    boolean[] isVisited;
    public List<List<Integer>> permute(int[] nums) {
        isVisited = new boolean[nums.length];
        backTracking(nums);
        return res;
    }
    private void backTracking(int[] nums) {
        // 终止条件
        if (path.size() == nums.length) {
            res.add(new ArrayList<>(path));
            return;
        }
        // 遍历当前数组
        for (int i = 0; i < nums.length; i++) {
            // 处理节点
            if (isVisited[i]) {  continue;}  // 跳过已排列的元素
            isVisited[i] = true; // 标记当前位置元素是否已排列
            path.add(nums[i]);
            // 递归
            backTracking(nums);
            // 回溯
            path.removeLast();
            isVisited[i] = false;
        }
    }
}
```

**扩展**：给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

代码实现如下：
```java
class Solution {
    List<List<Integer>> res = new ArrayList<List<Integer>>();  // 存放符合条件结果的集合
    LinkedList<Integer> path = new LinkedList<>();  // 存放符合条件结果
    Set<Integer> distNums;
    public List<List<Integer>> permuteUnique(int[] nums) {
        // 计数
        Map<Integer, Integer> dict = new HashMap<>();
        for(int num : nums) {dict.put(num, dict.getOrDefault(num, 0)+1);}
        // 唯一出现的数字
        distNums = dict.keySet();
        backTracking(nums,dict);
        return res;
    }
    private void backTracking(int[] nums,Map<Integer, Integer> dict) {
        // 终止条件
        if (path.size() == nums.length) {
            res.add(new ArrayList<>(path));
            return;
        }
        // 遍历所有数字（去重后的）
        for (int num : distNums) {
            // 处理节点
            if (dict.get(num) > 0) {
                path.add(num);
                dict.put(num, dict.get(num) - 1);
                // 递归
                backTracking(nums, dict);
                // 回溯
                dict.put(num, dict.get(num) + 1);
                path.removeLast();
            }
        }
    }
    // 时间复杂度O(n^2)，空间复杂度O(n)
}
```


# 例子：活字印刷

题目：你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。  
输入："AAB"   
输出：8  

代码实现如下：

```java
class Solution {
    public int numTilePossibilities(String tiles) {
        // 统计字符个数
        Map<Character, Integer> dict = new HashMap<>();
        for (char c : tiles.toCharArray()) {
            dict.put(c, dict.getOrDefault(c, 0) + 1);
        }
        Set<Character> tile=new HashSet<>(dict.keySet());
        return dfs(tiles.length(),dict,tile)-1;
    }
    private int dfs(int i, Map<Character, Integer> dict, Set<Character> tile) {
        // 递归终止条件，字符用完了
        if (i == 0) {
            return 1;
        }
        // 遍历当前dict中value大于0的字符（去重后的）
        int res=1;
        for (char c : tile) {
            if (dict.get(c) > 0) {
                dict.put(c, dict.get(c) - 1);
                res += dfs(i - 1, dict, tile);
                dict.put(c, dict.get(c) + 1); // 回溯
            }
        }
        return res;
    }
    // 时间复杂度O(n * n!)，空间复杂度O(∑)
}
```


# 参考资料
[代码随想录之回溯算法](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E5%A4%A7%E7%BA%B2%E5%A6%82%E4%B8%8B)
