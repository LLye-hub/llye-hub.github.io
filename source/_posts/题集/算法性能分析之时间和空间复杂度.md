---
title: 算法性能分析之时间和空间复杂度
tags:
categories:
  - 题集
toc: true
abbrlink: d1fda56a
date: 2023-05-12 15:42:59
---

关于时间复杂度和空间复杂度，刷过一些算法题后多少知道一点，比如单层for循环的时间复杂度为O(n)、数组变量的空间复杂度为O(n)，但是提到大O是什么就说不清了，而且涉及到一些复杂代码时，也说不清时间和空间复杂度。

首先解释下，这里**大O用来表示算法的一般执行性能**，大多情况下，它是算法的最坏情况下的执行性能，比如：插入排序的时间复杂度都说是O(n^2)。


# 时间复杂度
时间复杂度是一个函数，它定性描述该算法的运行时间。更详细的解释可以参见[这篇文章](https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%81.html#%E7%A9%B6%E7%AB%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)  

大数据规模的情况下，算法时间复杂度的排行如下：  
>O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(nlogn)线性对数阶 < O(n^2)平方阶 < O(n^3)立方阶 < O(2^n)指数阶


**举一个例子：** 找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）

**解法一：暴力枚举**    
双层遍历所有字符串比较，一般可能认为时间复杂度为O(n^2)。但其实这里忽略了字符串比较的时间消耗，因为字符串比较是按字典序逐位比较，长度为m的字符串比较的时间复杂度为O(m)，所以暴力枚举的时间复杂度应该是O(m×n×n)。

**解法二：所有字符串排序后遍历**  
先对n个字符串按字典序进行排序，排序后相同的两个字符串一定是挨着的，只要再遍历一遍n个字符串就能找到。

如果用快速排序算法，再加上长度为m的字符串比较，排序步骤的时间复杂度为O(m×nlogn)，遍历步骤的时间复杂度为O(m×n)，所以总的时间复杂度为O(m×nlogn + m×n)，简化后的时间复杂度为O(m×nlogn)。

很明显O(m×nlogn)是要优于O(m×n×n)的。

**强调下上面两种解法仅做时间复杂度说明，非题目最佳解。**


**递归算法的时间复杂度：** 本质上是 **递归的次数 * 每次递归中的操作次数** 。

比如题目：求x的n次方，用for循环的解法时间复杂度是O(n)，那么如果用递归写法呢？一定是O(logn)吗？

```java
int function2(int x, int n) {
    if (n == 0) {
        return 1; // return 1 同样是因为0次方是等于1的
    }
    return function2(x, n - 1) * x;
}
```

从代码层面看，递归了n次，每次进行乘法操作，所以上面代码的时间复杂度为O(n*1)=O(n)，和for循环写法没有差别。那么O(logn)的实现应该是怎样的？

先看下面这段代码，

```java
int function3(int x, int n) {
    if (n == 0) return 1;
    if (n == 1) return x;
    if (n % 2 == 1) {
        return function3(x, n / 2) * function3(x, n / 2)*x;
    }
    return function3(x, n / 2) * function3(x, n / 2);
}
```

代码中有两处递归调用。假设n=16，将上面代码的计算过程抽象为二叉树效果如下：

![VZGP4V.png](https://i.328888.xyz/2023/05/15/VZGP4V.png)

从图中可以看到，共有n-1个节点，也就是说做了n-1次乘法操作，所以时间复杂度还是O(n-1)=O(n)。其实，只要再做个小改动就能实现时间复杂度O(logn)的效果。

```java
int function4(int x, int n) {
		if (n == 0) return 1;
		if (n == 1) return x;
		int t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来，减少了重复计算
		if (n % 2 == 1) {
		return t * t * x;
		}
		return t * t;
}
```

上面的代码中，仅有一个调用，且每次都是 n/2，所以一共调用了 log以2为底n的对数次，再着每次递归做了一次乘法操作，所以时间复杂度为O(logn*1)=O(logn)。


# 空间复杂度

空间复杂度是一个算法在运行过程中占用内存空间大小的量度，利用程序的空间复杂度，可以对程序运行中需要多少内存有个预先估计。空间复杂度(Space Complexity)记作 S(n) 依然使用大O来表示。递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度

常量的空间复杂度为O(1)，一维数组的空间复杂度为O(n)，二维数组的空间复杂度为O(n^2)……

那么，什么情况下，空间复杂度会是O(logn)呢？情况特殊些，一般出现在递归算法中。

**举例分析：斐波那契数列**

常规写法：

```java
int fibonacci(int i) {
       if(i <= 0) return 0;
       if(i == 1) return 1;
       return fibonacci(i-1) + fibonacci(i-2);
}
```

假设i=5，计算过程抽象为二叉树效果如下：

![VZhUDo.png](https://i.328888.xyz/2023/05/15/VZhUDo.png)

每次递归中需要的空间是一个常量，并不会随着n的变化而变化，每次递归的空间复杂度就是O(1)。递归第n个斐波那契数的话，递归调用栈的深度是n。所以，上面代码的空间复杂度为O(1*n)=O(n)。

根据树的结点来看，时间复杂度为O(2^n)，随着n的增大，计算时间消耗呈指数上升，这样的性能是最差的。究其原因，代码中调用了2次递归，导致复杂度非常大，从这个角度，可以做如下优化：

```java
int fibonacci(int first, int second, int n) {
    if (n <= 0) {
        return 0;
    }
    if (n < 3) {
        return 1;
    }
    else if (n == 3) {
        return first + second;
    }
    else {
        return fibonacci(second, first + second, n - 1);
    }
}
```
上面代码中用两个常量来记录当前相加的两个数值，仅有一次递归调用，时间复杂度为O(n)。  

因为递归的深度依然是n，每次递归所需的空间也是常数，所以空间复杂度依然是O(n)。


# 参考资料
[算法性能分析](https://programmercarl.com/)