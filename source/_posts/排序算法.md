---
title: 排序算法
toc: true
abbrlink: '735e5788'
date: 2023-02-17 13:46:19
tags:
categories:
- 练习笔记
---
整理一些数据结构中常用的排序算法原理和java实现

常见排序算法原理简介：
* 冒泡排序（Bubble Sort）：从头到尾不断交换相邻逆序的元素，直到没有交换为止。时间复杂度为 O(n^2)。

* 选择排序（Selection Sort）：每次选择未排序部分中的最小元素，放到已排序部分的末尾。时间复杂度为 O(n^2)。

* 插入排序（Insertion Sort）：从未排序部分中取出元素，将其插入到已排序部分的合适位置，时间复杂度为 O(n^2)。

* 快速排序（Quick Sort）：选择一个元素作为基准，将小于基准的元素放到左边，大于基准的元素放到右边，再对左右两部分分别进行快速排序。时间复杂度为 O(nlogn)。

* 归并排序（Merge Sort）：将数组分成两个部分，对每个部分进行归并排序，然后将两个有序的部分合并成一个有序的数组。时间复杂度为 O(nlogn)。

* 堆排序（Heap Sort）：将待排序的序列建成一个大根堆，然后依次取出堆顶元素，再对剩余的元素进行调整，直到整个序列有序。时间复杂度为 O(nlogn)。

# 快速排序  
[B站视频讲解](https://www.bilibili.com/video/BV1at411T75o/?spm_id_from=333.337.search-card.all.click&vd_source=be633ca02cfced46a016ddb62aefc942)  
## 算法步骤
* 从数组中选择一个元素`t`作为**基准**（pivot） 
  
* 将小于`t`的值放它前面，大于`t`的值放它后面（相同的数可以到任一边），在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作
  
* 递归地（recursive）把小于`t`的子数列和大于`t`的子数列排序

算法时间复杂度为

> 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。

## java实现
```java
public class QuickSort {
    public static void quickSort(int[] arr, int left, int right) {
        if (left >= right) {
            return;
        }
        int pivot = arr[left]; // 基准值
        int i = left, j = right; // 左右指针
        // 左右指针交替遍历，直到重合
        while (i < j) {
        	// 从右到左遍历，直到小于基准值
            while (i < j && arr[j] > pivot) {
                j--;
            }
            arr[i] = arr[j];
            // 从左到右遍历，直到大于基准值
            while (i < j && arr[i] < pivot) {
                i++;
            }
            arr[j] = arr[i];
        }
        // 左右指针重合处即为当前基准值位置，且保证左边所有数都小于基准值，右边所有数都大于基准值
        arr[i] = pivot;
        // 递归，分别对左、右子数组排序
        quickSort(arr, left, i - 1);
        quickSort(arr, i + 1, right);
    }

    public static void main(String[] args) {
        int[] arr = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
        quickSort(arr, 0, arr.length - 1);
        System.out.println(Arrays.toString(arr));
    }
}
```
