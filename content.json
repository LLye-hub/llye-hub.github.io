{"meta":{"title":"LLye","subtitle":"","description":"scsadad","author":"LLye","url":"https://llye-hub.github.io","root":"/"},"pages":[{"title":"Repositories","date":"2023-02-20T08:35:55.813Z","updated":"2023-02-20T08:35:55.813Z","comments":false,"path":"index.html","permalink":"https://llye-hub.github.io/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-02-20T08:35:55.813Z","updated":"2023-02-20T08:35:55.813Z","comments":false,"path":"categories/index.html","permalink":"https://llye-hub.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-02-20T08:35:55.824Z","updated":"2023-02-20T08:35:55.824Z","comments":false,"path":"tags/index.html","permalink":"https://llye-hub.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-02-20T08:35:55.813Z","updated":"2023-02-20T08:35:55.813Z","comments":true,"path":"links/index.html","permalink":"https://llye-hub.github.io/links/index.html","excerpt":"","text":""},{"title":"About Me","date":"2023-11-09T12:08:31.065Z","updated":"2023-11-09T12:08:31.065Z","comments":false,"path":"about/index.html","permalink":"https://llye-hub.github.io/about/index.html","excerpt":"","text":"工作经历 2021.07.01 ~ 至今 | 海拍客 | 数仓开发工程师主要职责： 参与公司业务数据仓库的建设，包括数据采集、数据清洗、数仓模型设计、ETL开发等工作"}],"posts":[{"title":"认识一下拉链表","slug":"认识一下拉链表","date":"2023-11-10T14:20:37.000Z","updated":"2023-11-10T14:20:37.219Z","comments":true,"path":"posts/4e6addf5.html","link":"","permalink":"https://llye-hub.github.io/posts/4e6addf5.html","excerpt":"这是一篇加密文章，需要密码才能继续阅读。","text":"0ae7e196f2221a75e5346dcbb7e124f3a273828722568f616125477033531497 当前文章暂不对外可见，请输入密码后查看！","categories":[{"name":"对照文件存放的目录名称","slug":"对照文件存放的目录名称","permalink":"https://llye-hub.github.io/categories/%E5%AF%B9%E7%85%A7%E6%96%87%E4%BB%B6%E5%AD%98%E6%94%BE%E7%9A%84%E7%9B%AE%E5%BD%95%E5%90%8D%E7%A7%B0/"}],"tags":[{"name":"文章内容的关键词","slug":"文章内容的关键词","permalink":"https://llye-hub.github.io/tags/%E6%96%87%E7%AB%A0%E5%86%85%E5%AE%B9%E7%9A%84%E5%85%B3%E9%94%AE%E8%AF%8D/"},{"name":"private","slug":"private","permalink":"https://llye-hub.github.io/tags/private/"}]},{"title":"java刷题常用code整理","slug":"数据结构与算法笔记/java刷题常用code整理","date":"2023-10-10T10:31:02.000Z","updated":"2023-11-14T04:11:28.112Z","comments":true,"path":"posts/2a5db4cb.html","link":"","permalink":"https://llye-hub.github.io/posts/2a5db4cb.html","excerpt":"","text":"排序问题数组排序123int[] arr = new int[]&#123;1,2,3&#125;;Arrays.sort(arr);System.out.println(Arrays.toString(arr)); List排序1234567List&lt;Integer&gt; arr = new ArrayList&lt;&gt;();arr.add(1);arr.add(2);arr.add(3);Collections.sort(arr);arr.sort((o1, o2) -&gt; o2-o1);System.out.println(arr.toString()); 二维数组排序12int[][] arr2 = new int[][]&#123;&#123;0,1&#125;,&#123;1,2&#125;,&#123;3,0&#125;&#125;;Arrays.sort(arr2, Comparator.comparingInt(o -&gt; o[1])); // 按第二列升序排序 12345678910// 自定义比较器Comparatorint[][] arr2 = new int[][]&#123;&#123;0,1&#125;,&#123;1,2&#125;,&#123;3,0&#125;&#125;;Arrays.sort(price_rating, new MyComparator());static class MyComparator implements Comparator&lt;int[]&gt; &#123; @Override public int compare(int[] arr1, int[] arr2) &#123; return arr1[1] - arr2[1]; &#125;&#125; 最值问题数组求最值123// int[]数组的最大值int[] counts = new int[]&#123;1, 2, 3&#125;;int max = Arrays.stream(counts).max().getAsInt(); 类型转换问题char[]和String互相转换12345String str = &#x27;letter&#x27;;// String转换为char[]char[] strToChars = str.toCharArray();// char[]转换为StringString charsToStr = String.valueOf(chars); int[]和String[]互相转换123// String[] 转换为 int[]String[] strs;int[] nums = Arrays.stream(strs).mapToInt(Integer::parseInt).toArray(); ArrayList方法remove 移除元素12345678// 删除指定元素。remove() 方法仅将对象作为其参数。如果 obj 元素出现多次，则删除在动态数组中最第一次出现的元素。arraylist.remove(Object obj);// 如果list元素是Integer类型，则需要用Integer.valueOf()将 删除元素 从 int 类型转变成一个 Integer 对象。randomNumbers.remove(Integer.valueOf(13)); // 删除指定索引位置的元素arraylist.remove(int index);","categories":[{"name":"数据结构与算法笔记","slug":"数据结构与算法笔记","permalink":"https://llye-hub.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://llye-hub.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"怎么评价是一个好的数仓设计","slug":"数据仓库/怎么评价是一个好的数仓设计","date":"2023-09-15T07:55:18.000Z","updated":"2023-11-09T15:48:25.592Z","comments":true,"path":"posts/a74701e.html","link":"","permalink":"https://llye-hub.github.io/posts/a74701e.html","excerpt":"","text":"好的数仓设计标准应该是数据丰富完善、数据复用性强、数据规范性高。 完善度 dwd层完善度：衡量dwd层的完善度，看ods层被dw&#x2F;dws&#x2F;ads&#x2F;dim层依赖的数量（跨层引用率）。ods层被越多的非dwd层引用，说明越多任务基于原始数据进行开发，各种数据清洗、数据格式化存在重复计算。好的数仓设计一般要求ods层只能被dwd层引用，即跨层引用率为100%。 dw&#x2F;dws&#x2F;ads层完善度：衡量汇总数据的完善度，看仅靠dw&#x2F;dws&#x2F;ads层数据就能满足的查询比例（汇总层查询比例）。若汇总层数据无法满足查询要求，则需要从原始数据自行加工计算。汇总层查询比例不可能完全做到100%，但值越高，说明数仓上层模型建设越完善。 复用度 模型引用系数：⼀个模型被读取，直接产出下游模型的平均数量。若对所有dwd层表（有下游）的模型引用系数取均值，则可衡量dwd层的模型引用系数。系数越大，说明数仓复用度越高。从数据血缘图来看，自下而上一条线的模型设计复用性差，复杂场景下这条线会极其长，而理想的模型设计应是交织的发散型结构 规范度 表分层规范：有多少表不能划属到数仓架构的某一层，一般从表命名前缀体现。 表命名规范：⼀个规范的表命名应该包括所属分层、所属主题域、调度周期、全量&#x2F;增量等信息。 字段命名规范：相同字段应在不同表保持一样的命名。同样是用户id，不能在A表叫user_id，在B表却叫u_id. 数仓规范度越高，表名包含的信息越多，在数据地图查找表越方便，也更利于提高模型表复用度。","categories":[{"name":"数据仓库","slug":"数据仓库","permalink":"https://llye-hub.github.io/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"数仓","slug":"数仓","permalink":"https://llye-hub.github.io/tags/%E6%95%B0%E4%BB%93/"}]},{"title":"数仓分层","slug":"数据仓库/数仓分层","date":"2023-09-09T11:54:03.000Z","updated":"2023-11-09T15:48:18.721Z","comments":true,"path":"posts/96c137c4.html","link":"","permalink":"https://llye-hub.github.io/posts/96c137c4.html","excerpt":"","text":"为什么要分层试想一下没有数仓分层的以下场景： 有一个需求，计算每个用户日gmv，然后从交易系统抽取数据，并求和计算得到一张 A 表。又来了一个需求，计算每个地区的日gmv，这时发现能再 A 表的基础上能聚合加工得到 B 表。一段时间后，需要每个地区的日净gmv（不包含退款），这时 B 表和 A 表都不能支持，然后又从交易系统重复抽取数据。 上面场景比较简单化，实际中，在没有划分数仓分层的情况下，我们可能会做出一套表依赖结构混乱，甚至出现循环依赖的数据体系。 类比图书管理，如果没有书架和分类标识，图书随意堆叠在一起，每次都需要重复搬书翻找，十分地耗时耗力。当有了书架和分类摆放，每次按照标识就能快速定位书籍位置。 因此，我们需要一套行之有效的数据组织和管理方法来让我们的数据体系更有序，这就是谈到的数据分层。 分层的好处数据分层并不能解决所有的数据问题，但是，数据分层却可以给我们带来如下的好处： （1）清晰数据结构：每一个数据分层都有对应的作用域，在使用数据的时候能更方便的定位和理解。（2）数据血缘追踪：提供给业务人员或下游系统的数据服务时都是目标数据，目标数据的数据来源一般都来自于多张表数据。若出现目标数据异常时，清晰的血缘关系可以快速定位问题所在。而且，血缘管理也是元数据管理重要的一部分。（2）减少重复开发：数据的逐层加工原则，下层包含了上层数据加工所需要的全量数据，这样的加工方式避免了每个数据开发人员都重新从源系统抽取数据进行加工。（3）数据关系条理化：源系统间存在复杂的数据关系，比如客户信息同时存在于核心系统、信贷系统、理财系统、资金系统，取数时该如何决策呢？数据仓库会对相同主题的数据进行统一建模，把复杂的数据关系梳理成条理清晰的数据模型，使用时就可避免上述问题了。（4）屏蔽原始数据的影响：数据的逐层加工原则，上层的数据都由下一层的数据加工获取，不允许跳级取数。而原始数据位于数仓的最底层，离应用层数据还有多层的数据加工，所以加工应用层数据的过程中就会把原始数据的变更消除掉，保持应用层的稳定性。 分层架构以呆过的一家公司的数仓架构为例，数仓架构主要分为五层： 1）ods：（Operational Data Store）数据贴源层，将业务系统的数据几乎无处理地存储在数仓系统中，结构上与业务系统基本保持一致。2）dwd：（Data Warehouse Detail）数据明细层，用于隔离业务层和数据仓库，保持和ods层一样的颗粒度，对ods层的数据做一些简单的清洗、去空值、标准化处理。3）dw：（Data Warehouse）数据中间层，在dwd层的基础上，对数据进行轻微的聚合操作，提升公共指标的复用性，减少重复加工操作。4）dws：（Data Warehouse Summary）数据汇总层，以dw层为基础，整合成分析某个主题域的汇总数据，用于提供后续的查询分析服务。该层的数据表会涵盖较多的业务信息，字段较多，一般称为宽表。5）ads：（Application Data Store）数据应用层，为各种数据产品提供个性化的统计指标数据。 此外，还有dim层（维表层），将事实表中重复出现的属性信息抽取出来，用一张表进行规范管理，查询时再与事实表进行关联。","categories":[{"name":"数据仓库","slug":"数据仓库","permalink":"https://llye-hub.github.io/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"数仓","slug":"数仓","permalink":"https://llye-hub.github.io/tags/%E6%95%B0%E4%BB%93/"}]},{"title":"SparkSQL优化之数据倾斜","slug":"SQL/SparkSQL优化之数据倾斜","date":"2023-07-09T02:19:52.000Z","updated":"2023-11-08T03:56:31.674Z","comments":true,"path":"posts/faab1ad7.html","link":"","permalink":"https://llye-hub.github.io/posts/faab1ad7.html","excerpt":"","text":"前言在Spark作业优化场景中，最常见且比较棘手的就是数据倾斜问题。个人认为，具备数据倾斜调优能力对从事数仓开发人员是必备的基本要求。当然，数据倾斜的场景是比较复杂的，针对不同的数据倾斜有不同的处理方案。 如何辨别和定位数据倾斜从Spark作业的执行计划看，若出现某个task任务比其他task任务执行耗时极其久，比如：某个stage有100个task，其中99个task在1min左右就执行成功，但是有1个task却执行了1个小时甚至更久，这种情况显然是出现了数据倾斜。 数据倾斜问题仅出现在shuffle过程，一些会触发shuffle的算子：distinct、groupByKey、reduceByKey、aggregateByKey、countByKey、join、cogroup、repartition等。对应提交的SparkSQL中可能有distinct、count(distinct)、group by、partition by、join等关键词。 常见的数据倾斜场景及解决方案碰到的数据倾斜案例窗口分组数据倾斜倾斜场景业务上有一张消息记录表msg_records，sql要求是取下一次回复消息 12345678910111213141516171819202122232425262728WITH msg_tmp as( select id -- 唯一键，消息id ,from_chat_id -- 消息发送者id ,to_chat_id -- 消息接受者id ,msg_time -- 消息时间 from msg_records)select id ,msg_time ,first_value(if(type = &#x27;reply&#x27;,id,null),true) over(partition by from_chat_id,to_chat_id order by msg_time,id rows between 1 following and unbounded following) as reply_msg_id_n1t -- 取下一次回复消息from( select id ,from_chat_id ,to_chat_id ,msg_time ,&#x27;send&#x27; as type from msg_tmp union all -- 调转，取返回消息 select id ,to_chat_id as from_chat_id ,from_chat_id as to_chat_id ,msg_time ,&#x27;reply&#x27; as type from msg_tmp) t1 sql执行分析有一个task执行耗时1h4373 数据倾斜分析根据窗口函数的分组from_chat_id + to_chat_id分析，数据量出现严重倾斜，表总数据量1亿多，其中，分组from_chat_id=12 and to_chat_id=81867的数据量有30w，其他分组数据量至多3w。 另外，分组from_chat_id=12 and to_chat_id=81867的数据在业务上可定义为脏数据，且first_value()函数计算出的值全为null。 经过测试验证发现，没有 rows between语句 或是 过滤倾斜数据 时，SQL执行很快 综上分析，再对照spark执行计划基本可以定位倾斜原因为窗口数据倾斜和rows between计算耗时 解决方案结合业务知识，在sql逻辑中过滤from_chat_id=12 and to_chat_id=81867的数据 最终，任务执行耗时从1h优化至10min 参考资料美团技术团队：Spark性能优化指南——高级篇","categories":[{"name":"SQL","slug":"SQL","permalink":"https://llye-hub.github.io/categories/SQL/"}],"tags":[{"name":"数据倾斜","slug":"数据倾斜","permalink":"https://llye-hub.github.io/tags/%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/"}]},{"title":"算法思路总结","slug":"数据结构与算法笔记/算法思路总结","date":"2023-06-15T06:16:02.000Z","updated":"2023-06-28T03:05:20.441Z","comments":true,"path":"posts/5f4823a0.html","link":"","permalink":"https://llye-hub.github.io/posts/5f4823a0.html","excerpt":"","text":"ST表ST表（Sparse Table，稀疏表）是一种数据结构，采用了倍增的思想，在O(nlogn)时间构造一个二维表，可以在O(1)时间查询[l,r]区间的最值。主要用于解决RMQ（Range Minimum&#x2F;Maximum Query，区间最值查询）问题。 实现思路： 设F[i,j]表示[i,i+2^j-1]区间的最值，区间长度为2^j 根据倍增思想，长度为2^j的区间能分成两个长度为2^(j-1)的区间，然后分别求两个区间的最值。递推公式：F[i,j]=max(F[i,j-1],F[i+2^(j-1),j-1]) java代码如下： 123456789101112131415161718// 构建ST表int[] lg = new int[n + 1];// 预处理：以2为底的对数，向下取整for (int i = 2; i &lt;= n; ++i) &#123; lg[i] = lg[i &gt;&gt; 1] + 1;&#125;System.out.println(Arrays.toString(lg));// f[i][j] 表示 [i - 2^j + 1, i] 区间的最大值int[][] f = new int[n][lg[n] + 1];for (int i = 0; i &lt; n; ++i) &#123; f[i][0] = chargeTimes[i]; for (int j = 1; j &lt;= lg[i + 1]; ++j) &#123; f[i][j] = Math.max(f[i][j - 1], f[i - (1 &lt;&lt; j - 1)][j - 1]); &#125;&#125;for (int[] tmp : f) &#123; System.out.printf(Arrays.toString(tmp));&#125;","categories":[{"name":"练习笔记","slug":"练习笔记","permalink":"https://llye-hub.github.io/categories/%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"解题思路之贪心算法","slug":"解题思路之贪心算法","date":"2023-05-31T07:37:07.000Z","updated":"2023-06-06T07:05:16.181Z","comments":true,"path":"posts/da0ecc89.html","link":"","permalink":"https://llye-hub.github.io/posts/da0ecc89.html","excerpt":"这是一篇加密文章，需要密码才能继续阅读。","text":"0ae7e196f2221a75e5346dcbb7e124f36deed831076312fa04e0c81d58c043c148e8c22ba19b06abf116e63b513fbe0b5b1ddbf3866dc6a4e231d41e8109c481fc84aff1e6d1f764e5387bbc2a63efcd269076b6d26b9e37133e8c3c6e87e9c29bb7891588fe68135e64e07a5ee665260c228e10e9e2b55e786e2e883ea80bceea0893b36e9e1e963aad143ef29fb21981efea5dca5fe6cbb33adb683110ddbb7085b2538798a7949198817313548b38852832d8eddec8d696ad233fc849508b1de1d97c47860c66db564e474b3cdd7dc05b249a441e1f42d0fe89b797e9a6f338fd5759017bc374582df0e6d42f28361eb0d77c753ec011e1c74dff9ebd735b03ceeea2bf90dbe2c14c2a3da8ce0fa476df707c7a8e1749a23b680aa9b612153300f46bb11388f8217130f8ee7b541cf4431a021a430a3e721ede6cc6a94facb92a5ca4b781e9be77c179c399d4d821 当前文章暂不对外可见，请输入密码后查看！","categories":[{"name":"对照文件存放的目录名称","slug":"对照文件存放的目录名称","permalink":"https://llye-hub.github.io/categories/%E5%AF%B9%E7%85%A7%E6%96%87%E4%BB%B6%E5%AD%98%E6%94%BE%E7%9A%84%E7%9B%AE%E5%BD%95%E5%90%8D%E7%A7%B0/"}],"tags":[{"name":"文章内容的关键词","slug":"文章内容的关键词","permalink":"https://llye-hub.github.io/tags/%E6%96%87%E7%AB%A0%E5%86%85%E5%AE%B9%E7%9A%84%E5%85%B3%E9%94%AE%E8%AF%8D/"},{"name":"private","slug":"private","permalink":"https://llye-hub.github.io/tags/private/"}]},{"title":"SQL之distirbute by rand有坑","slug":"SQL之distirbute-by-rand有坑","date":"2023-05-23T09:29:09.000Z","updated":"2023-06-06T07:05:16.175Z","comments":true,"path":"posts/68201c19.html","link":"","permalink":"https://llye-hub.github.io/posts/68201c19.html","excerpt":"这是一篇加密文章，需要密码才能继续阅读。","text":"0ae7e196f2221a75e5346dcbb7e124f39514e07fde056a265182dbd07146d257904f8da20d3ff0c1b0ef8ab8f0988a5faa61ca39c50eca0bc647f1183468803fdb7eb5d5a7593fd27e5d0d4c591b1b3b437b54ddd77005bf7470681fc084f79e4692262a7f466691839a576636f25cc888052dd1155a41106eb8db3b08946eb959cf163478c34033fb6ecaec8e26b694d3d6c8f1267c9f15b06256e1ca5699e5cac5130527fb77e1f5d169cd7b276a6fb1d18b77ca651179a48e0c7aa93ed2e7b1bf0984864b9f7a1e23e5aff938ca81b5be8200b7bf93fe40d35a21c6bcb5c6c181d8277085c1c77c914826650e9850 当前文章暂不对外可见，请输入密码后查看！","categories":[{"name":"对照文件存放的目录名称","slug":"对照文件存放的目录名称","permalink":"https://llye-hub.github.io/categories/%E5%AF%B9%E7%85%A7%E6%96%87%E4%BB%B6%E5%AD%98%E6%94%BE%E7%9A%84%E7%9B%AE%E5%BD%95%E5%90%8D%E7%A7%B0/"}],"tags":[{"name":"文章内容的关键词","slug":"文章内容的关键词","permalink":"https://llye-hub.github.io/tags/%E6%96%87%E7%AB%A0%E5%86%85%E5%AE%B9%E7%9A%84%E5%85%B3%E9%94%AE%E8%AF%8D/"},{"name":"private","slug":"private","permalink":"https://llye-hub.github.io/tags/private/"}]},{"title":"解题思路之回溯算法","slug":"数据结构与算法笔记/解题思路之回溯算法","date":"2023-05-19T06:34:49.000Z","updated":"2023-06-28T02:03:26.203Z","comments":true,"path":"posts/49adf57d.html","link":"","permalink":"https://llye-hub.github.io/posts/49adf57d.html","excerpt":"","text":"什么是回溯算法回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，回溯函数也就是递归函数。 回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。 回溯法，一般可以解决如下几种问题： 组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 解题步骤1、回溯函数模板返回值以及参数 123vector&lt;vector&lt;int&gt;&gt; result;vector&lt;int&gt; path;void backtracking(参数) 2、终止条件 1234if (终止条件) &#123; 存放结果; return;&#125; 3、回溯搜索的遍历过程 1444 12345for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123; 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果;&#125; for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。backtracking是自己调用自己，实现递归。 综上，回溯算法的模板框架如下： 1234567891011121314vector&lt;vector&lt;int&gt;&gt; result;vector&lt;int&gt; path;void backtracking(参数) &#123; if (终止条件) &#123; 存放结果; return; &#125; for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123; 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果; &#125;&#125; 例子：全排列题目：给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。输入：nums &#x3D; [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 抽象成树形结构如下：3974 代码实现如下： 123456789101112131415161718192021222324252627282930class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();// 存放符合条件结果的集合 LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();// 用来存放符合条件结果 boolean[] isVisited; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; isVisited = new boolean[nums.length]; backTracking(nums); return res; &#125; private void backTracking(int[] nums) &#123; // 终止条件 if (path.size() == nums.length) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; // 遍历当前数组 for (int i = 0; i &lt; nums.length; i++) &#123; // 处理节点 if (isVisited[i]) &#123; continue;&#125; // 跳过已排列的元素 isVisited[i] = true; // 标记当前位置元素是否已排列 path.add(nums[i]); // 递归 backTracking(nums); // 回溯 path.removeLast(); isVisited[i] = false; &#125; &#125;&#125; 扩展：给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 代码实现如下： 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); // 存放符合条件结果的集合 LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); // 存放符合条件结果 Set&lt;Integer&gt; distNums; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; // 计数 Map&lt;Integer, Integer&gt; dict = new HashMap&lt;&gt;(); for(int num : nums) &#123;dict.put(num, dict.getOrDefault(num, 0)+1);&#125; // 唯一出现的数字 distNums = dict.keySet(); backTracking(nums,dict); return res; &#125; private void backTracking(int[] nums,Map&lt;Integer, Integer&gt; dict) &#123; // 终止条件 if (path.size() == nums.length) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; // 遍历所有数字（去重后的） for (int num : distNums) &#123; // 处理节点 if (dict.get(num) &gt; 0) &#123; path.add(num); dict.put(num, dict.get(num) - 1); // 递归 backTracking(nums, dict); // 回溯 dict.put(num, dict.get(num) + 1); path.removeLast(); &#125; &#125; &#125; // 时间复杂度O(n^2)，空间复杂度O(n)&#125; 例子：活字印刷题目：你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。输入：”AAB”输出：8 代码实现如下： 12345678910111213141516171819202122232425262728class Solution &#123; public int numTilePossibilities(String tiles) &#123; // 统计字符个数 Map&lt;Character, Integer&gt; dict = new HashMap&lt;&gt;(); for (char c : tiles.toCharArray()) &#123; dict.put(c, dict.getOrDefault(c, 0) + 1); &#125; Set&lt;Character&gt; tile=new HashSet&lt;&gt;(dict.keySet()); return dfs(tiles.length(),dict,tile)-1; &#125; private int dfs(int i, Map&lt;Character, Integer&gt; dict, Set&lt;Character&gt; tile) &#123; // 递归终止条件，字符用完了 if (i == 0) &#123; return 1; &#125; // 遍历当前dict中value大于0的字符（去重后的） int res=1; for (char c : tile) &#123; if (dict.get(c) &gt; 0) &#123; dict.put(c, dict.get(c) - 1); res += dfs(i - 1, dict, tile); dict.put(c, dict.get(c) + 1); // 回溯 &#125; &#125; return res; &#125; // 时间复杂度O(n * n!)，空间复杂度O(∑)&#125; 参考资料代码随想录之回溯算法","categories":[{"name":"练习笔记","slug":"练习笔记","permalink":"https://llye-hub.github.io/categories/%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://llye-hub.github.io/tags/LeetCode/"}]},{"title":"hiveSQL之深入理解视图","slug":"hiveSQL之深入理解视图","date":"2023-05-17T01:58:48.000Z","updated":"2023-05-23T01:49:28.599Z","comments":true,"path":"posts/2dfa544e.html","link":"","permalink":"https://llye-hub.github.io/posts/2dfa544e.html","excerpt":"这是一篇加密文章，需要密码才能继续阅读。","text":"0ae7e196f2221a75e5346dcbb7e124f3a273828722568f616125477033531497 当前文章暂不对外可见，请输入密码后查看！","categories":[{"name":"对照文件存放的目录名称","slug":"对照文件存放的目录名称","permalink":"https://llye-hub.github.io/categories/%E5%AF%B9%E7%85%A7%E6%96%87%E4%BB%B6%E5%AD%98%E6%94%BE%E7%9A%84%E7%9B%AE%E5%BD%95%E5%90%8D%E7%A7%B0/"}],"tags":[{"name":"文章内容的关键词","slug":"文章内容的关键词","permalink":"https://llye-hub.github.io/tags/%E6%96%87%E7%AB%A0%E5%86%85%E5%AE%B9%E7%9A%84%E5%85%B3%E9%94%AE%E8%AF%8D/"},{"name":"private","slug":"private","permalink":"https://llye-hub.github.io/tags/private/"}]},{"title":"hive之常用元数据表","slug":"hive/hive之常用元数据表","date":"2023-05-16T03:30:36.000Z","updated":"2023-11-08T04:05:15.051Z","comments":true,"path":"posts/b06ccdfe.html","link":"","permalink":"https://llye-hub.github.io/posts/b06ccdfe.html","excerpt":"","text":"hive元数据信息通常存储在关系型数据库，常见的是MySQL数据库。hive元数据信息存储在MySQL库的57张表中。61 存储Hive版本的元数据表（VERSION） VER_ID SCHEMA_VERSION VERSION_COMMENT 1 2.3.0 Hive release version 2.3.0 该表比较重要，如果出现问题，根本进入不了Hive-Cli。比如该表不存在，当启动Hive-Cli时候，就会报错”Table ‘hive.version’ doesn’t exist”。 Hive数据库相关的元数据表（DBS、DATABASE_PARAMS）DBSDBS表存储的是hive中所有库的基本信息 DB_ID DESC DB_LOCATION_URI NAME OWNER_NAME OWNER_TYPE 1 Default Hive database hdfs:&#x2F;&#x2F;localhost:8020&#x2F;user&#x2F;hive&#x2F;warehouse default public ROLE 6 hdfs:&#x2F;&#x2F;localhost:8020&#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;test.db test llye USER DATABASE_PARAMSDATABASE_PARAMS表存储数据库的相关参数，在CREATE DATABASE时候用WITH DBPROPERTIES(property_name=property_value, …)指定的参数。 表字段有：DB_ID、PARAM_KEY、PARAM_VALUE Hive表和视图相关的元数据表（TBLS、TABLE_PARAMS、TBL_PRIVS）TBLSTBLS表存储了表&#x2F;视图的基本信息，表字段有：TBL_ID 、CREATE_TIME 、DB_ID、LAST_ACCESS_TIME(上次访问时间)、OWNER、RETENTION(保留字段)、SD_ID(序列化配置信息)、TBL_NAME、TBL_TYPE、VIEW_EXPANDED_TEXT(视图的详细HQL语句)、VIEW_ORIGINAL_TEXT(视图的原始HQL语句)。 TBL_ID CREATE_TIME DB_ID LAST_ACCESS_TIME OWNER RETENTION SD_ID TBL_NAME TBL_TYPE VIEW_EXPANDED_TEXT VIEW_ORIGINAL_TEXT IS_REWRITE_ENABLED 2 1678874852 1 0 llye 0 2 student MANAGED_TABLE 0 13 1683273717 6 0 llye 0 13 travel_data MANAGED_TABLE 0 16 1684216889 1 0 llye 0 16 test_query VIRTUAL_VIEW (¶select¶`travel_data`.`province`, `travel_data`.`city`, `travel_data`.`attraction`, `travel_data`.`star_level`, `travel_data`.`price`, `travel_data`.`sales`, `travel_data`.`sale_date`¶from¶ `test`.`travel_data`) (¶select¶ *¶from¶ test.travel_data) 0 TABLE_PARAMSTABLE_PARAMS表存储了表&#x2F;视图的属性信息，表字段有：TBL_ID、PARAM_KEY(totalSize,numRows,EXTERNAL)、PARAM_VALUE TBL_ID PARAM_KEY PARAM_VALUE 2 COLUMN_STATS_ACCURATE {“BASIC_STATS”:”true”} 2 numFiles 1 2 numRows 1 2 rawDataSize 5 2 totalSize 6 2 transient_lastDdlTime 1678874879 13 COLUMN_STATS_ACCURATE {“BASIC_STATS”:”true”} 13 numFiles 1 13 numRows 11 13 rawDataSize 597 13 totalSize 608 13 transient_lastDdlTime 1683273753 16 transient_lastDdlTime 1684216889 TBL_PRIVSTBL_PRIVS表存储了表&#x2F;视图的授权信息，表字段有：TBL_GRANT_ID、CREATE_TIME、GRANT_OPTION、GRANTOR(授权执行用户)、GRANTOR_TYPE、PRINCIPAL_NAME(被授权用户)、PRINCIPAL_TYPE、TBL_PRIV、TBL_ID TBL_GRANT_ID CREATE_TIME GRANT_OPTION GRANTOR GRANTOR_TYPE PRINCIPAL_NAME PRINCIPAL_TYPE TBL_PRIV TBL_ID 5 1678874852 1 llye USER llye USER INSERT 2 6 1678874852 1 llye USER llye USER SELECT 2 7 1678874852 1 llye USER llye USER UPDATE 2 8 1678874852 1 llye USER llye USER DELETE 2 39 1683273717 1 llye USER llye USER INSERT 13 40 1683273717 1 llye USER llye USER SELECT 13 41 1683273717 1 llye USER llye USER UPDATE 13 42 1683273717 1 llye USER llye USER DELETE 13 46 1684216889 1 llye USER llye USER INSERT 16 47 1684216889 1 llye USER llye USER SELECT 16 48 1684216889 1 llye USER llye USER UPDATE 16 49 1684216889 1 llye USER llye USER DELETE 16 Hive文件存储信息相关的元数据表（SDS、SD_PARAMS、SERDES、SERDE_PARAMS）由于HDFS支持的文件格式很多，而建Hive表时候也可以指定各种文件格式，Hive在将HQL解析成MapReduce时候，需要知道去哪里，使用哪种格式去读写HDFS文件，而这些信息就保存在这几张表中。 SDSSDS表保存文件存储的基本信息，如INPUT_FORMAT、OUTPUT_FORMAT、是否压缩等。TBLS表中的SD_ID与该表关联，可以获取Hive表的存储信息。 表字段有：SD_ID、CD_ID(字段信息id)、INPUT_FORMAT(文件输入格式)、IS_COMPRESSED(是否压缩)、IS_STOREDASSUBDIRECTORIES(是否以子目录存储)、LOCATION(HDFS路径)、NUM_BUCKETS(分桶数量)、OUTPUT_FORMAT(文件输出格式)、SERDE_ID(序列化类id)。 SD_ID CD_ID INPUT_FORMAT IS_COMPRESSED IS_STOREDASSUBDIRECTORIES LOCATION NUM_BUCKETS OUTPUT_FORMAT SERDE_ID 2 2 org.apache.hadoop.mapred.TextInputFormat 0 0 hdfs:&#x2F;&#x2F;localhost:8020&#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;student -1 org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat 2 13 13 org.apache.hadoop.mapred.TextInputFormat 0 0 hdfs:&#x2F;&#x2F;localhost:8020&#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;test.db&#x2F;travel_data -1 org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat 13 16 16 org.apache.hadoop.mapred.TextInputFormat 0 0 NULL -1 org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat 16 SD_PARAMSSD_PARAMS表保存Hive存储的属性信息，在创建表时候使用STORED BY ‘storage.handler.class.name’ [WITH SERDEPROPERTIES (…)指定。 表字段有：SD_ID、PARAM_KEY、PARAM_VALUE SERDESSERDES表存储序列化使用的类信息 表字段有：SERDE_ID、NAME(序列化类别名)、SLIB(序列化类)。 SERDE_ID NAME SLIB 2 NULL org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe 13 NULL org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe 16 NULL NULL SERDE_PARAMSSERDE_PARAMS表存储了hive表序列化的一些属性信息，比如:行、列分隔符 表字段有：SERDE_ID、PARAM_KEY、PARAM_VALUE SERDE_ID PARAM_KEY PARAM_VALUE 2 serialization.format 1 13 serialization.format 1 Hive表字段相关的元数据表（COLUMNS_V2）COLUMNS_V2表存储了hive表各字段的基本信息。 表字段有：CD_ID、COMMENT、COLUMN_NAME、TYPE_NAME(字段类型)、INTEGER_IDX(字段顺序)。 CD_ID COMMENT COLUMN_NAME TYPE_NAME INTEGER_IDX 2 NULL id int 0 2 NULL name string 1 13 NULL attraction string 2 13 NULL city string 1 13 NULL price double 4 13 NULL province string 0 13 NULL sale_date string 6 13 NULL sales int 5 13 NULL star_level int 3 16 NULL attraction string 2 16 NULL city string 1 16 NULL price double 4 16 NULL province string 0 16 NULL sale_date string 6 16 NULL sales int 5 16 NULL star_level int 3 Hive表分区相关的元数据表（PARTITIONS、PARTITION_KEYS、PARTITION_KEY_VALS、PARTITION_PARAMS）PARTITIONSPARTITIONS表存储hive表分区的基本信息。 表字段有：PART_ID、CREATE_TIME、LAST_ACCESS_TIME、PART_NAME、SD_ID(分区存储ID)、TBL_ID、LINK_TARGET_ID。 PART_ID CREATE_TIME LAST_ACCESS_TIME PART_NAME SD_ID TBL_ID 1 1684221232 0 dt&#x3D;1 18 17 2 1684221294 0 dt&#x3D;2 19 17 PARTITION_KEYSPARTITION_KEYS表存储hive表分区的字段信息。 表字段有：TBL_ID、PKEY_COMMENT、PKEY_NAME、PKEY_TYPE、INTEGER_IDX(分区字段顺序)。 TBL_ID PKEY_COMMENT PKEY_NAME PKEY_TYPE INTEGER_IDX 17 NULL dt string 0 PARTITION_KEY_VALSPARTITION_KEY_VALS表存储hive表分区字段值。 表字段有：PART_ID、PART_KEY_VAL(分区字段值)、INTEGER_IDX(分区字段值顺序)。 PART_ID PART_KEY_VAL INTEGER_IDX 1 1 0 2 2 0 PARTITION_PARAMSPARTITIONS表存储hive表分区的属性信息。 表字段有：PART_ID、PARAM_KEY(numFiles，numRows)、PARAM_VALUE。 PART_ID PARAM_KEY PARAM_VALUE 1 COLUMN_STATS_ACCURATE {“BASIC_STATS”:”true”} 1 numFiles 1 1 numRows 11 1 rawDataSize 4290 1 totalSize 1221 1 transient_lastDdlTime 1684221233 2 COLUMN_STATS_ACCURATE {“BASIC_STATS”:”true”} 2 numFiles 1 2 numRows 4 2 rawDataSize 1564 2 totalSize 1040 2 transient_lastDdlTime 1684221294 其他不常用的元数据表DB_PRIVS：数据库权限信息表。通过GRANT语句对数据库授权后，将会在这里存储。IDXS：索引表，存储Hive索引相关的元数据。INDEX_PARAMS：索引相关的属性信息。TBL_COL_STATS：表字段的统计信息。使用ANALYZE语句对表字段分析后记录在这里。TBL_COL_PRIVS：表字段的授权信息。PART_PRIVS：分区的授权信息。PART_COL_PRIVS：分区字段的权限信息。PART_COL_STATS：分区字段的统计信息。FUNCS：用户注册的函数信息。FUNC_RU：用户注册函数的资源信息。…… 参考资料Hive 元数据表结构详解","categories":[{"name":"hive","slug":"hive","permalink":"https://llye-hub.github.io/categories/hive/"}],"tags":[{"name":"hive元数据","slug":"hive元数据","permalink":"https://llye-hub.github.io/tags/hive%E5%85%83%E6%95%B0%E6%8D%AE/"}]},{"title":"算法性能分析之时间和空间复杂度","slug":"数据结构与算法笔记/算法性能分析之时间和空间复杂度","date":"2023-05-12T07:42:59.000Z","updated":"2023-06-28T02:03:26.123Z","comments":true,"path":"posts/d1fda56a.html","link":"","permalink":"https://llye-hub.github.io/posts/d1fda56a.html","excerpt":"","text":"关于时间复杂度和空间复杂度，刷过一些算法题后多少知道一点，比如单层for循环的时间复杂度为O(n)、数组变量的空间复杂度为O(n)，但是提到大O是什么就说不清了，而且涉及到一些复杂代码时，也说不清时间和空间复杂度。 首先解释下，这里大O用来表示算法的一般执行性能，大多情况下，它是算法的最坏情况下的执行性能，比如：插入排序的时间复杂度都说是O(n^2)。 时间复杂度时间复杂度是一个函数，它定性描述该算法的运行时间。更详细的解释可以参见这篇文章 大数据规模的情况下，算法时间复杂度的排行如下： O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(nlogn)线性对数阶 &lt; O(n^2)平方阶 &lt; O(n^3)立方阶 &lt; O(2^n)指数阶 举一个例子： 找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串） 解法一：暴力枚举双层遍历所有字符串比较，一般可能认为时间复杂度为O(n^2)。但其实这里忽略了字符串比较的时间消耗，因为字符串比较是按字典序逐位比较，长度为m的字符串比较的时间复杂度为O(m)，所以暴力枚举的时间复杂度应该是O(m×n×n)。 解法二：所有字符串排序后遍历先对n个字符串按字典序进行排序，排序后相同的两个字符串一定是挨着的，只要再遍历一遍n个字符串就能找到。 如果用快速排序算法，再加上长度为m的字符串比较，排序步骤的时间复杂度为O(m×nlogn)，遍历步骤的时间复杂度为O(m×n)，所以总的时间复杂度为O(m×nlogn + m×n)，简化后的时间复杂度为O(m×nlogn)。 很明显O(m×nlogn)是要优于O(m×n×n)的。 强调下上面两种解法仅做时间复杂度说明，非题目最佳解。 递归算法的时间复杂度： 本质上是 递归的次数 * 每次递归中的操作次数 。 比如题目：求x的n次方，用for循环的解法时间复杂度是O(n)，那么如果用递归写法呢？一定是O(logn)吗？ 123456int function2(int x, int n) &#123; if (n == 0) &#123; return 1; // return 1 同样是因为0次方是等于1的 &#125; return function2(x, n - 1) * x;&#125; 从代码层面看，递归了n次，每次进行乘法操作，所以上面代码的时间复杂度为O(n*1)&#x3D;O(n)，和for循环写法没有差别。那么O(logn)的实现应该是怎样的？ 先看下面这段代码， 12345678int function3(int x, int n) &#123; if (n == 0) return 1; if (n == 1) return x; if (n % 2 == 1) &#123; return function3(x, n / 2) * function3(x, n / 2)*x; &#125; return function3(x, n / 2) * function3(x, n / 2);&#125; 代码中有两处递归调用。假设n&#x3D;16，将上面代码的计算过程抽象为二叉树效果如下： 3874 从图中可以看到，共有n-1个节点，也就是说做了n-1次乘法操作，所以时间复杂度还是O(n-1)&#x3D;O(n)。其实，只要再做个小改动就能实现时间复杂度O(logn)的效果。 123456789int function4(int x, int n) &#123; if (n == 0) return 1; if (n == 1) return x; int t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来，减少了重复计算 if (n % 2 == 1) &#123; return t * t * x; &#125; return t * t;&#125; 上面的代码中，仅有一个调用，且每次都是 n&#x2F;2，所以一共调用了 log以2为底n的对数次，再着每次递归做了一次乘法操作，所以时间复杂度为O(logn*1)&#x3D;O(logn)。 空间复杂度空间复杂度是一个算法在运行过程中占用内存空间大小的量度，利用程序的空间复杂度，可以对程序运行中需要多少内存有个预先估计。空间复杂度(Space Complexity)记作 S(n) 依然使用大O来表示。递归算法的空间复杂度 &#x3D; 每次递归的空间复杂度 * 递归深度 常量的空间复杂度为O(1)，一维数组的空间复杂度为O(n)，二维数组的空间复杂度为O(n^2)…… 那么，什么情况下，空间复杂度会是O(logn)呢？情况特殊些，一般出现在递归算法中。 举例分析：斐波那契数列 常规写法： 12345int fibonacci(int i) &#123; if(i &lt;= 0) return 0; if(i == 1) return 1; return fibonacci(i-1) + fibonacci(i-2);&#125; 假设i&#x3D;5，计算过程抽象为二叉树效果如下： 7031 每次递归中需要的空间是一个常量，并不会随着n的变化而变化，每次递归的空间复杂度就是O(1)。递归第n个斐波那契数的话，递归调用栈的深度是n。所以，上面代码的空间复杂度为O(1*n)&#x3D;O(n)。 根据树的结点来看，时间复杂度为O(2^n)，随着n的增大，计算时间消耗呈指数上升，这样的性能是最差的。究其原因，代码中调用了2次递归，导致复杂度非常大，从这个角度，可以做如下优化： 1234567891011121314int fibonacci(int first, int second, int n) &#123; if (n &lt;= 0) &#123; return 0; &#125; if (n &lt; 3) &#123; return 1; &#125; else if (n == 3) &#123; return first + second; &#125; else &#123; return fibonacci(second, first + second, n - 1); &#125;&#125; 上面代码中用两个常量来记录当前相加的两个数值，仅有一次递归调用，时间复杂度为O(n)。 因为递归的深度依然是n，每次递归所需的空间也是常数，所以空间复杂度依然是O(n)。 参考资料算法性能分析","categories":[{"name":"练习笔记","slug":"练习笔记","permalink":"https://llye-hub.github.io/categories/%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"hexo+GitHub自建博客遇到的问题","slug":"hexo-GitHub自建博客遇到的问题","date":"2023-05-08T06:48:01.000Z","updated":"2023-05-08T06:49:22.520Z","comments":true,"path":"posts/69a95f3b.html","link":"","permalink":"https://llye-hub.github.io/posts/69a95f3b.html","excerpt":"","text":"hexo文章目录点击不跳转，html没有生成href","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://llye-hub.github.io/tags/hexo/"}]},{"title":"hiveSQL之理解explain参数","slug":"SQL/hiveSQL之理解explain参数","date":"2023-05-08T03:16:49.000Z","updated":"2023-05-08T08:27:00.383Z","comments":true,"path":"posts/2369b6cf.html","link":"","permalink":"https://llye-hub.github.io/posts/2369b6cf.html","excerpt":"","text":"hive官方文档说明 关键字 EXPLAIN 语法： EXPLAIN [EXTENDED|DEPENDENCY|AUTHORIZATION|VECTORIZATION|ANALYZE] query（hive2.3.9版本支持） EXPLAIN EXTENDED是EXPLAIN的扩展，能展示更加详细的信息。除了EXPLAIN打印出的内容，还包括每个标的HDFS读取路径，每个HIVE表的配置信息等，可以查看出表是否被全表扫描。 EXPLAIN DEPENDENCY用于描述一段sql需要的数据来源，输出的是一个json格式的数据，里面包含一下两个部分的内容，input_partitions：描述一段sql依赖的数据来源表分区，里面存储的分区名的列表，格式如下：{“partitionname”:“库名@表名 @分区列&#x3D;分区列的值”} ，如果整段sql包含的所有表都是是非分区表，则显示为空。input_table：描述一段sql依赖的数据来源表，里面存储的是HIVE表名的列表格式如下：{“tablename”:“库名@表名 ”，“tabletype”：表的类型（外部表&#x2F;内部表）} EXPLAIN ANALYZE是EXPLAIN的扩展。EXPLAIN的信息中标示的是预估扫描行数，EXPLAIN ANALYZE但展示信息中也标示了实际扫描行数，格式为：Num rows: (estimated row count)/(actual row count) **执行计划包含三部分内容: ** 查询sql的抽象语法树 所有stage之间的依赖关系 每个stage的具体描述 参数解释 MapReduce: 表示当前任务执行所用的计算机引擎是MapReduce Map Operator Tree: 表示当前描述的Map阶段执行的操作信息。 TableScan: 表示对关键字alias声明的结果集。这里代指表明。 Statistics: 表示对当前阶段的统计信息。例如数据行数和数据量，这两个都是预估值。 Filter Operator: 表示在之前操作（TableScan）的结果集上进行数据的过滤。 Predicate: 表示Filter Operator进行过滤时候使用的谓词，例如 pt_dt &#x3D; 2020-11-11 Select Operator: 表示在之前的结果集上对列进行投影，即列筛选。 Expressions: 表示需要投影的列，即筛选的列。 OutputColNames: 表示输出的列名。 Group By Operator: 表示在之前的结果集上分组聚合。 keys: 表示分组的列。 mode[aggregations]: 表示分组聚合使用的算法.例如 count（）。 Reduce Output Operator: 表示当前描述的是对之前的结果聚合后的输出信息，这里表示Map端聚合后的信息。 key expressions&#x2F;value expressions: MapReduce计算引擎，在Map阶段和Reduce阶段输出的都是键-值对的形式，这里key expression和 key expression 和 value expression 分别描述的就是Map阶段输出的键（key） 和值（value）所用的数据列。key expression指代的就是聚合列。 value expression 指代的就是 聚合的函数。 sort order：表示输出是否进行排序，每个+表示正序排序的一列，每个-表示倒序排序的一列。 Map-Reduce partition columns: 表示Map阶段输出到Reduce阶段的分区列。在HIVE-SQL中可以用distribute by 指代分区的列。 Reduce Operator Tree: 表示当前描述的Reduce阶段执行的操作信息。 Reduce 阶段关键字和Map阶段的含义一样，不同的如下： compressed: 在 File output operator中这个关键词表示文件输出的结果是否进行压缩，FALSE表示不进行输出压缩。 table: 表示正在操作的表。 input format&#x2F;out putformat: 分别表示文件输入和输出的文件类型。 serde:表示读取表数据的序列化和反序列化的方式。","categories":[{"name":"hive","slug":"hive","permalink":"https://llye-hub.github.io/categories/hive/"}],"tags":[{"name":"hiveSQL","slug":"hiveSQL","permalink":"https://llye-hub.github.io/tags/hiveSQL/"}]},{"title":"hiveSQL之groupBy语句增强语法grouping sets/CUBE/rollup","slug":"SQL/hiveSQL之分析函数groupingSet|cube|rollup","date":"2023-05-05T06:01:45.000Z","updated":"2023-05-12T03:37:35.202Z","comments":true,"path":"posts/67bc5d15.html","link":"","permalink":"https://llye-hub.github.io/posts/67bc5d15.html","excerpt":"","text":"本文详细整理了关于group by子句的增强聚合语法grouping sets&#x2F;CUBE&#x2F;rollup的具体用法，语法的hive官方介绍文档 。 测试数据首先声明使用的hive版本为 2.3.9 12345678910111213141516171819202122232425262728293031323334drop table if exists travel_data;create table if not exists travel_data( province string, city string, attraction string, star_level int, Price double, sales int, sale_date string);insert overwrite table travel_dataselect &#x27;河南省&#x27;,&#x27;郑州市&#x27;,&#x27;方特&#x27;,4,312.22,15789,&#x27;2019-02-03&#x27;union allselect &#x27;河南省&#x27;,&#x27;郑州市&#x27;,&#x27;二七广场&#x27;,4,0,5942,&#x27;2019-02-03&#x27;union allselect &#x27;河南省&#x27;,&#x27;郑州市&#x27;,&#x27;河南省博物馆&#x27;,4,1.22,943,&#x27;2019-02-03&#x27;union allselect &#x27;河南省&#x27;,&#x27;洛阳市&#x27;,&#x27;白云山&#x27;,4,324.44,16843,&#x27;2019-02-03&#x27;union allselect &#x27;河南省&#x27;,&#x27;洛阳市&#x27;,&#x27;白马寺&#x27;,4,23.45,2567,&#x27;2019-02-03&#x27;union allselect &#x27;河南省&#x27;,&#x27;洛阳市&#x27;,&#x27;龙门石窟&#x27;,4,45,15784,&#x27;2019-02-03&#x27;union allselect &#x27;广东省&#x27;,&#x27;深圳市&#x27;,&#x27;东部华侨城&#x27;,4,86,9523,&#x27;2019-02-03&#x27;union allselect &#x27;广东省&#x27;,&#x27;深圳市&#x27;,&#x27;欢乐谷&#x27;,4,54,2573,&#x27;2019-02-03&#x27;union allselect &#x27;广东省&#x27;,&#x27;深圳市&#x27;,&#x27;世界之窗&#x27;,4,34,5644,&#x27;2019-02-03&#x27;union allselect &#x27;广东省&#x27;,&#x27;广州市&#x27;,&#x27;长隆&#x27;,4,46,25673,&#x27;2019-02-03&#x27;union allselect &#x27;广东省&#x27;,&#x27;广州市&#x27;,&#x27;广州塔&#x27;,4,35,9735,&#x27;2019-02-03&#x27;; grouping set语句官方说明 The GROUPING SETS clause in GROUP BY allows us to specify more than one GROUP BY option in the same record set. All GROUPING SET clauses can be logically expressed in terms of several GROUP BY queries connected by UNION. Table-1 shows several such equivalent statements. This is helpful in forming the idea of the GROUPING SETS clause. A blank set ( ) in the GROUPING SETS clause calculates the overall aggregate. grouping set子句可以实现对同一个数据集指定多个group by条件，适合多维聚合场景下使用。其执行效果等同于对多个group by查询进行union all操作。 SELECT a, b, SUM(c) FROM tab1 GROUP BY a, b GROUPING SETS ( (a,b) )等同下面语句 SELECT a, b, SUM(c) FROM tab1 GROUP BY a, b SELECT a, b, SUM( c ) FROM tab1 GROUP BY a, b GROUPING SETS ( (a, b), a, b, ( ) )等同下面语句 SELECT a, b, SUM( c ) FROM tab1 GROUP BY a, bUNIONSELECT a, null, SUM( c ) FROM tab1 GROUP BY a, nullUNIONSELECT null, b, SUM( c ) FROM tab1 GROUP BY null, bUNIONSELECT null, null, SUM( c ) FROM tab1 语法 grouping sets子句必须跟在group by语句后，且出现在grouping sets的字段必须出现在group by语句中，但是出现在group by中字段不一定要出现在grouping sets语句中 出现在group by中但是没有在grouping sets中的字段将会被赋值为null grouping__id字段可以区分不同的聚合粒度，表示当前行数据数据哪个分组集合 grouping函数可以处理空值，grouping()接受一个列名作为参数，如果结果对应行使用了参数列做聚合，返回0，此时意味着NULL来自输入数据；否则返回1，此时意味着NULL是grouping sets的占位符。 测试sql：从省&amp;市聚合维度统计销售数量 1234567891011121314select td.province, td.city, IF(grouping(td.city) = 0,td.city,&#x27;城市&#x27;) as city2, -- 进行空值判断，替换输出更有实际意义的值 sum(sales) as sales, grouping__idfrom travel_data tdgroup by td.province, td.city grouping SETS (td.province,td.city)order by grouping__id; 查询结果： 10289 第一列按照province 第二列按照city 第三列按照city分组，并对空值进行替换 第四列按照province或city分组，进行统计计算 第五列grouping__id表示当前行数据属于哪个分组，1表示province，2表示city 测试sql：从省&amp;市、省&amp;日期、省三个聚合维度统计销售数量 12345678910111213141516171819select td.province , td.city, sum(sales) as sales, td.sale_date , grouping__idfrom travel_data tdgroup by td.province , td.city, td.sale_dategrouping SETS ( (td.province , td.city) ,(td.province, td.sale_date) ,td.province )order by grouping__id CUBE语句CUBE函数跟group by语句一起使用，可以对group by的所有字段进行组合再进行聚合计算。 group by a,b,c with CUBE执行效果等同于 group by a, b, c grouping sets ( (a, b, c), (a, b), (b, c), (a, c), (a), (b), (c), ( )) 测试sql 123456789101112131415161718192021222324252627select province , city, sum(sales) as sales, grouping__idfrom travel_datagroup by province,citywith CUBEorder by grouping__id;-- 或者下面这种写法select province , city, sum(sales) as sales, grouping__idfrom travel_datagroup by CUBE(province,city)order by grouping__id; 查询结果： 15315 从上面的结果数据可以看到，对聚合字段 (province,city)使用CUBE函数后，返回结果有4种聚合维度：(province,city)、(province)、(city)、() rollup语句rollup是CUBE的子集，以最左侧的维度为主，从该维度进行层级聚合，可以实现上钻和下钻的效果 group by a,b,c with rollup假设层次结构是 “a “向下钻到 “b “向下钻到 “c”，执行效果等同于 group by a, b, c grouping sets ( (a, b, c), (a, b), (a), ( )) 测试sql 123456789101112131415161718192021222324252627select province , city, sale_date , sum(sales) as sales, grouping__idfrom travel_datagroup by province,city,sale_datewith rolluporder by grouping__id-- 或者下面这种写法select province , city, sale_date , sum(sales) as sales, grouping__idfrom travel_data group by rollup(province,city,sale_date)order by grouping__id 查询结果： 18451 从上面的结果数据可以看到，对聚合字段 (province,city,sale_date)使用rollup函数后，返回结果有4种聚合维度：(province,city,sale_date)、(province,city)、(province)、() grouping__id计算方法从rollup函数的例子可以看到，grouping__id的数值并不是连续的，下面总结下grouping__id计算方法 按group by语句的字段顺序（不理解网上有说法是按字段倒序排序）。所以这里要注意groupby字段顺序变化是会影响grouping__id计算结果的。 对于每个字段，若出现在了当前粒度中，则该字段位置赋值为0，否则为1。 这样就形成了一个二进制数，将这个二进制数转为十进制，即为当前粒度对应的 grouping__id。 以统计粒度 group by province,city,sale_date为例， 字段顺序为:province,city,sale_date 所有聚合维度对应的二进制数为： grouping sets 按字段顺序赋值二进制数 转换为十进制的grouping__id province,city,sale_date 000 0 province,city 001 1 province,sale_date 010 2 province 011 3 city,sale_date 100 4 city 101 5 sale_date 110 6 无 111 7 测试sql： 123456789101112select td.province , city, td.sale_date , sum(sales) as sales, grouping__idfrom travel_data tdgroup by CUBE(td.province,td.city,td.sale_date)order by grouping__id 查询结果： 21146 从上面的结果可以看到，grouping__id的数值与计算规则得出来的一致。hive2.3版本前关于grouping__id的计算方式可能不同，可以参见其他博客 grouping sets和union all性能对比实现逻辑如果说 union all是先聚合再联合，那么 grouping sets就是先联合再聚合。grouping sets根据 N个分组对每条数据进行计算，不在当前分组的字段置为null，将数据量扩展成原来的 N倍，再按 group by的字段做聚合计算。 group by province,city grouping sets ((province,city),province,())计算效果图如下： 21602 …… group by province,city union all …… group by province计算效果图如下： 21729 分析源码，grouping__id在process的时候将newKeysGroupingSets的值赋予具体的行 12345678910111213141516171819202122232425262728293031// org/apache/hadoop/hive/ql/exec/GroupByOperator.javapublic void process(Object row, int tag) throws HiveException &#123; …… if (groupingSetsPresent) &#123; Object[] newKeysArray = newKeys.getKeyArray(); Object[] cloneNewKeysArray = new Object[newKeysArray.length]; for (int keyPos = 0; keyPos &lt; groupingSetsPosition; keyPos++) &#123; cloneNewKeysArray[keyPos] = newKeysArray[keyPos]; &#125; for (int groupingSetPos = 0; groupingSetPos &lt; groupingSets.size(); groupingSetPos++) &#123; for (int keyPos = 0; keyPos &lt; groupingSetsPosition; keyPos++) &#123; newKeysArray[keyPos] = null; &#125; FastBitSet bitset = groupingSetsBitSet[groupingSetPos]; // Some keys need to be left to null corresponding to that grouping set. // 按照bitSet保留原值，对于group by a, b, c 如果bitSet是010，则表示keyPos为0和2就表示ClearBit，需要保留原值，1其他就为null for (int keyPos = bitset.nextClearBit(0); keyPos &lt; groupingSetsPosition; keyPos = bitset.nextClearBit(keyPos+1)) &#123; newKeysArray[keyPos] = cloneNewKeysArray[keyPos]; &#125; // 这里就是给当前这条数据赋予GROUPING_ID的值 newKeysArray[groupingSetsPosition] = newKeysGroupingSets[groupingSetPos]; processKey(row, rowInspector); &#125; &#125; else &#123; processKey(row, rowInspector); &#125; &#125; 下面通过执行计划分析两种方式的差异。 123456789101112explain select province, city, grouping__idfrom travel_data group by province, city grouping SETS ((province,city),province,())order by grouping__id; hive执行计划： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657Explain |-------------------------------------------------------------------------------------------------------------+STAGE DEPENDENCIES: | Stage-1 is a root stage | Stage-2 depends on stages: Stage-1 | Stage-0 depends on stages: Stage-2 | |STAGE PLANS: | Stage: Stage-1 | Map Reduce | Map Operator Tree: | TableScan | alias: travel_data | Statistics: Num rows: 11 Data size: 597 Basic stats: COMPLETE Column stats: NONE | Select Operator | expressions: province (type: string), city (type: string) | outputColumnNames: _col0, _col1 | Statistics: Num rows: 11 Data size: 597 Basic stats: COMPLETE Column stats: NONE | Group By Operator | keys: _col0 (type: string), _col1 (type: string), 0 (type: int) | mode: hash | outputColumnNames: _col0, _col1, _col2 | Statistics: Num rows: 33 Data size: 1791 Basic stats: COMPLETE Column stats: NONE | 这里读取数据后按grouping sets的3个分组维度，将数据由11条扩充为33条 Reduce Output Operator | …… Reduce Operator Tree: | Group By Operator | keys: KEY._col0 (type: string), KEY._col1 (type: string), KEY._col2 (type: int) | mode: mergepartial | outputColumnNames: _col0, _col1, _col2 | Statistics: Num rows: 16 Data size: 868 Basic stats: COMPLETE Column stats: NONE | Select Operator | expressions: _col0 (type: string), _col1 (type: string), _col2 (type: int) | outputColumnNames: _col0, _col1, _col2 | Statistics: Num rows: 16 Data size: 868 Basic stats: COMPLETE Column stats: NONE | …… | Stage: Stage-2 | Map Reduce | Map Operator Tree: | TableScan | Reduce Output Operator | key expressions: _col2 (type: int) | sort order: + | Statistics: Num rows: 16 Data size: 868 Basic stats: COMPLETE Column stats: NONE | value expressions: _col0 (type: string), _col1 (type: string) | Reduce Operator Tree: | Select Operator | expressions: VALUE._col0 (type: string), VALUE._col1 (type: string), KEY.reducesinkkey0 (type: int)| 这里KEY.reducesinkkey0即为grouping__id outputColumnNames: _col0, _col1, _col2 | Statistics: Num rows: 16 Data size: 868 Basic stats: COMPLETE Column stats: NONE | …… | | | Stage: Stage-0 | …… 从上面的执行计划可以看到，Stage-1在读取数据时，在map阶段根据grouping sets有3个分组维度，将数据量扩充至原来的3倍，然后在reduce阶段做group by province,city操作。 1234567891011121314151617explainselect province, cityfrom travel_datagroup by province,cityunion allselect province, NULL as cityfrom travel_datagroup by province ; hive执行计划： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172Explain |--------------------------------------------------------------------------------------------------+STAGE DEPENDENCIES: | Stage-1 is a root stage | Stage-2 depends on stages: Stage-1, Stage-3 | Stage-3 is a root stage | Stage-0 depends on stages: Stage-2 | |STAGE PLANS: | Stage: Stage-1 | Map Reduce | Map Operator Tree: | TableScan | alias: travel_data | Statistics: Num rows: 11 Data size: 597 Basic stats: COMPLETE Column stats: NONE | Select Operator | expressions: province (type: string), city (type: string) | outputColumnNames: province, city | Statistics: Num rows: 11 Data size: 597 Basic stats: COMPLETE Column stats: NONE | Group By Operator | keys: province (type: string), city (type: string) | mode: hash | outputColumnNames: _col0, _col1 | Statistics: Num rows: 11 Data size: 597 Basic stats: COMPLETE Column stats: NONE | 这里数据量没有变化 Reduce Output Operator | …… Reduce Operator Tree: | Group By Operator | keys: KEY._col0 (type: string), KEY._col1 (type: string) | mode: mergepartial | outputColumnNames: _col0, _col1 | Statistics: Num rows: 5 Data size: 271 Basic stats: COMPLETE Column stats: NONE | …… | Stage: Stage-2 | Map Reduce | Map Operator Tree: | TableScan | Union | Statistics: Num rows: 10 Data size: 542 Basic stats: COMPLETE Column stats: NONE | …… | TableScan | Union | Statistics: Num rows: 10 Data size: 542 Basic stats: COMPLETE Column stats: NONE | …… Stage: Stage-3 | Map Reduce | Map Operator Tree: | TableScan | alias: travel_data | Statistics: Num rows: 11 Data size: 597 Basic stats: COMPLETE Column stats: NONE | Select Operator | expressions: province (type: string) | outputColumnNames: province | Statistics: Num rows: 11 Data size: 597 Basic stats: COMPLETE Column stats: NONE | Group By Operator | keys: province (type: string) | mode: hash | outputColumnNames: _col0 | Statistics: Num rows: 11 Data size: 597 Basic stats: COMPLETE Column stats: NONE | 这里数据量没有变化 Reduce Output Operator | …… Reduce Operator Tree: | Group By Operator | keys: KEY._col0 (type: string) | mode: mergepartial | outputColumnNames: _col0 | Statistics: Num rows: 5 Data size: 271 Basic stats: COMPLETE Column stats: NONE | …… | Stage: Stage-0 | …… 从上面的执行计划可以看到，Stage-1和Stage-3都是读取数据，再分别按照group by province,city和group by province做聚合操作，最后在Stage-2做union操作合并数据。union all这种写法对表travel_data重复读取两次，查询性能上比grouping sets写法要差些。在集群空闲的情况下，对两种写法的sql分别执行5次，得到如下结果： grouping sets写法执行5次的耗时: select province, city, grouping__id from travel_data group by province, city grouping SETS ((province,city),province) order by grouping__id ; Time taken: 54.807 seconds, Fetched: 6 row(s)Time taken: 56.261 seconds, Fetched: 6 row(s)Time taken: 52.671 seconds, Fetched: 6 row(s)Time taken: 62.945 seconds, Fetched: 6 row(s)Time taken: 57.337 seconds, Fetched: 6 row(s) union all写法执行5次的耗时: select province,city from travel_data group by province,city union all select province, NULL as city from travel_data group by province; Time taken: 83.91 seconds, Fetched: 6 row(s)Time taken: 94.466 seconds, Fetched: 6 row(s)Time taken: 86.253 seconds, Fetched: 6 row(s)Time taken: 75.509 seconds, Fetched: 6 row(s)Time taken: 88.633 seconds, Fetched: 6 row(s) 可以算出，grouping sets写法的平均耗时为56.8s，union all写法的平均耗时为85.7s，耗时是前者的1.5倍。 所以，grouping sets写法的sql不仅在表达上更加简洁，在查询性能上也更加高效。 参考文章Hive分析函数详解：GROUPING SETS&#x2F;CUBE&#x2F;ROLLUP 从源码深入理解 Spark SQL 中的 Grouping Sets 语句 Hive虚拟列的生成与计算【1】","categories":[{"name":"SQL","slug":"SQL","permalink":"https://llye-hub.github.io/categories/SQL/"}],"tags":[{"name":"grouping sets","slug":"grouping-sets","permalink":"https://llye-hub.github.io/tags/grouping-sets/"}]},{"title":"关于数据仓库建设的一些思考","slug":"数据仓库/关于数据仓库建设的一些思考","date":"2023-04-14T09:02:13.000Z","updated":"2023-11-09T13:55:44.299Z","comments":true,"path":"posts/49066d40.html","link":"","permalink":"https://llye-hub.github.io/posts/49066d40.html","excerpt":"","text":"基于在海拍客的工作经历，沉淀了一些关于数据仓库的思考，没有框架，想到什么写什么 数据仓库解决什么问题？1、避免”烟囱式”开发，减少由于业务变化带来的维护成本烟囱式开发，所有报表都是基于原始数据加工，SQL复杂度高，模型和指标无法复用，大量重复计算逻辑。一但某个业务变化，模型维护成本极高，而且大量的重复计算对资源消耗非常大，极易造成队列阻塞，影响数据产出 2、统一数据指标口径，保证数据一致性：定义一致、计算口径一致、数据源一致 中文博大精深，一个简单的中文词经常包含些隐含信息。 比如交易金额，当需求方说要取今天的交易额的时候，很多时候说的是今天的成功的交易金额，然而在逻辑角度，交易金额指的的订单表上支付金额+优惠券金额，不进行交易状态的条件过滤。 鸡同鸭讲，说的是两个人沟通时说的不是同一个东西。 比如订单的发货时间，对于财务业务，指的是订单表中的delivery_time字段，表示的是供货商提供的物流订单后第一次抓取到发货状态的时间；对于门店用户角度，指的是物流表中最终发送到用户手上那个订单的物流的发货时间。 3、数据结构清晰，方便数据查找和理解数仓的分层设计能明晰每张表的作用域和职责，在需要查询使用时，能快速找到要用的表和理解每个字段的含义 一些博客文章如何避免数仓模型“烟囱式”建设 数仓常见问题以及解决方案！","categories":[{"name":"数据仓库","slug":"数据仓库","permalink":"https://llye-hub.github.io/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"}],"tags":[]},{"title":"数仓建模之关于流量域建设","slug":"数据仓库/数仓建模之关于流量域建设","date":"2023-04-14T08:56:16.000Z","updated":"2023-05-08T02:05:14.131Z","comments":true,"path":"posts/bbbc8dfb.html","link":"","permalink":"https://llye-hub.github.io/posts/bbbc8dfb.html","excerpt":"这是一篇加密文章，需要密码才能继续阅读。","text":"0ae7e196f2221a75e5346dcbb7e124f3b1b3c5930620d283013007149d4c4935b69ce92f61658828479c839b5ea9198d1bda489f76e02aefb6c8c1b6c4f32fd31f36e698664f02671ce11c574fe5628c2d85825c7895fbc00177c55eaf6dc5335488610a8b88d894b09d84d011efc5134b4573dfbe48ed2bf6c239d1fecd49fc54f965b6c70627686bc4d8b5209339f82930e76524144c0f1b5aaa60eef52f119b05e4136dc067e5e8ca67e8e0772186df70f115b895d7d8f368b79708fb1e4c54851da8d44365f6047c0fad077890a16bdd1a6ce5d908272fbbf4f3ee0664dfd07c0471c47bd5506baa027cb755c66a44a1e7277f99d9e2ee2202bd050c0bff1e7d335c69ba839e217bb9e0d3c3eebe6e72bacfd7dda5938764aa615d6f61ed67ed2b24bdcd393e307a817bb140ddb80654ca6f812585d0c73d00616a462225de61da0fc1629df0558f3ee47d9cecd1800ddc7e1d26428f625b965c2e48ac61c2a647927e16629ad85603f6a9378530d503ae19fbace06786266ea4e64eac41d7f818b58581c1086db366efa626abcfc9b024e24da4a29a84e2109cfe15b3fc4f486af813e69865ed2f2ae6b0b48844db76d51998001273c492f1ba476fb840b757be323d45fc5e3fe94eccb2131d4490c4ca9fda3b8088132ec133e5af1c60a7c297a3496af60720a9f2eeca0cf3cc43f5ddd4af9a1297eb760d777ea0626e3a9ad3e2168591d480999c1e7d13dfeb07f4835a8c12500d23c84a42935d3581287ab81ac6ffc7a61afb2eac4dd07742903b802d69292c3d7c56ffa992fa2556e2fc12cc6e52e60a3effa93e3d295e2b7149769d628962d5157c1d24ae1e28b632e676e76f487194ce8c0a434727916a1b8864513f4d69fa39d6a11d868a01dd69c0af40db273372ca9e8c832fea678c5842f86ee27e302472f3101ffbcbf7acc58cdbd720be68548958012f88480fd3af182ea95d5641a911905cc06e3ae93106941854c87263e3fba2445b0ee9b5e5ef894c1a4bba66165a51e1d256d8d186e704ed5e03ae2708a34c0fd18d12cc364164c8b49862a30ccb66621a9a00e10b911882fa0a44156c9686c81e3d0af11c400cc49f94663aa6db8511244e709be165369752e37546cdf7f5d4426a8a45088b2c546ffddb0710c07bdf0256f1e62514037ffdddb1245e6b6ab90d6503a50236f96dacbbe60d1353df2e9edd3b9ff638e32aa3dd29941692520119ba4ad15b060b64f1fb75bfa9e260011a92286c6033803626c66224641b78cd9d7c6e6b8ce6d3b439dd55e05dc95d4bca8009f5cc4d91aa275b41a3f558acbd64c86ea7ba7ebffaaff75acae85274fe26e0d739cf8cdcbf891c2a81a1c9e7bc3a4be7812357246c8a6ada9174133ebbc096984f8b324d5d2a13bb2a3ca4ca6cb44e971ea79ec807547e4421c5dc012bd4c633f805d07718f3906f4f28b7f2457e4c6d4badb98b7a126f3e170d32635bcca3aaa493acce8ef23435e755908f907c4d2786521d3fc0eba03d272015a567009ded9cf1b1730b8b40c7d3b16d9d9fdb734727e277da59dc74f90d3ab88019fa0f31a42161b568de2f8e79321055ff90c038bc71ae84799c93b9bc40aaa4b0ce38fea856e3479dcae13bcb0972ea996c083ea6d3abd6cb45844127558d16f547fa24c6b600fbd84d747f0590f3058fb1d4c5609c8e1a9b926d7b2f3ef3d119557c8519cb2cf49d6027256b75ff51844347463da6205855fca3987416daa6cff5f216c3dd3f5488d10f76f63cea20ac8c9f40f1ad6f7b87b412f1ce8de19e9a8b413bc57e4f5c3c63f680c7d7f71f31f8922b1907815a3e87e2db2a7433b7a2f93f6dd5b703d8c43ed34ee84e652d7225d0cda6dc1cf28cb8704e4cc70588542d8076d687197f40575d4b178184474d2c5a147b883f0fd88a7081f4947ecfaddece704619ac093393174f43a6808f48e40fffc1fc1d7427374af1b9b4e8fb15f47e7ffec46b7292c75eeedb6ce93c94d4c36c246873c258485a41864fc7a46f8beb92d89c7a76631bc6c7440400a7417b7c151bf482784d6a53a5455501f5bb2b54a74ab67e511a2f10bece2173f7112ad3a0c8f15091c2c47d4ae3855cc64489451368c480c1c90ac71b2361bb9986e528406361bed5f02a4fb96cb6cfe72c1f4c45576ce8c3e27342a0ebfe955789bb237ec99277552b8414761f9b16f102752c1214920120acf1195b569a03c59d137fd0ea84f3c7353e07b997ffd31bee3308e82865c8c2f8dc2890e40334a597a92a8148836004df6043b0b392b589e06788a7d50db7ae5535a667095d024108c1ba4ce20566f6536873142b9f265264ebd22d2f0c088661623aadffe6352a41b171d7ca497764c62d401724befe18cad6fac3e20c032edf3e2d2dc3a238d4e236306f20351b729663c275b680df6cc4cc7e092cb4d38474b5c64308f2e2154bf970bebe78433a8312d0aa3b95f2f4cd60e68719de146ff4759b7c25f65e9877299659fb46b497bde07f779553e11a58313f63f773b6aa0f82dcc3da4b0485fcf5b3653f9d5787b942394ebf39c32e6fb60ecb70b98a58e84304ced0d872ef39c167770187e525257037b02161d860367fee54a5968feb47437d461a3a14c292bc3986d581583d7638445636f15a9d04107079212c85922cefae5f920845a3723ae5c3a80abd1f16b9d0987affce63a11f3a0200b4bdf3a7348e14ce0315c21b3a0e88e12f807a76dd29bd28da5afe2bad26a7e43cfe67ad5a8d84c1fb84fb17243201726a8689d779cf2c54a5791e058edf06c9cdc4c62cfb089df793afe3d2dfb7644b1f96d777a162eff743b07c7ddf2372dd776b6bda368393adad97f4fbbea18ad20bac990f87d0debf5e522337d23ee768842719119b488a7173afc6715ab33cdfbc0336b2b31effe16e41844ca32747be8825de94fb9f7514837160aee9dfb8cb4c3b730bd65c89d5523d40bc3c8bda3a9a151e17bb4856d4fee4726fb3628eda438c0d22b3fced83b2418197b7c9965df8a326f8d6658ca1caa22ad46e3c7e46f943eb1dffc5556ca85a3d618498fbfb5c09b9e4a38e1996bf847a511ac945f8491c46697c516baa9e83634a8b27855e2410a83c610b0937c1f713308ff1c125c73c9929820df66acc9a78415a76cb8d86dcabd91f9e6c02e6d08768a0737b5699ade547a8d090ad96fe38bed82440081c65eb7ca6d86f4b61943372dc98fecfa7cfebc8db6ffb80b1f1c6e4c3536f09446a47a0b5df66f6a4133c9318d01cb5ee1a9226bc4d3aa14e7b901d16bf22bc56aef2b2d5ed66b5c6f159efed8bf2d1555b32a8c7cb445b8fd993611b5947abdd028d636ccd9c4895b5f45aa8826ea917a41fd49dd826ead8b6b4088ae64cffd807288f6a3d168e70cc7893e7cbe88380cb1e813b81db3b3d2bb7e3eb54bc872b29ffc73811163260d95d27efe2d2e8945dd816dce0c3d2807bb10c1055067d9d59fbd54e05d595c38d04f3830bf71b40622f0416e2fcb70b6bfdb55927bac01268bc317ec56e407470cff6b06b3eea63501d35bcb8af3e5487105301a0afde02f6b469dd58a4d252262a5a43ae1fc6492cd1bbe4b7da02e245eccb221eb1f9fd97a48e7c5e908f43af3017ce7d4e291f7a678468583ace28776ac51745251e6b8b16dfe585aacc73bac1db6dd9ebf0cf0b466825df633dfb53021f4dca52972b2d182a3149bebe845c6cc94a5f34a727889e8897dc785d929ba83749ab61ff5594e08f5fa142610ccea383bd9151ccd3a74b9872b288957c0add337f16eb7788fe34597d5598a35fb8872e9e5e206920eb980414fbe3c7f65cf39fa35b419eb17344a2d232ca412009a3788cd4177a72af316fec6ba69a1b76058980a5fcc2480da36895d041c3b4239a6a670d4abee60bc53a9173206d55b4a3452d094387e0213e156ee0580d0e1dd82e6e9bc0288ae9396089d3eef255eb470332d724a5d453a18db7fd0b1137a74d011442c24c15f310d05988d2304afa22a757dfa35857e238baf36b10283dcf811a759b27a3db5fbb60d953cdd42c58e1842b80f346cc4aa82bbf7a85397a5d60e5757f2a44c7bf47fc652555fc85fa11e2623a232ca8560cc93f2929d57955c15137f399563f9b01fc810cf50f4c32287efd131258cab8bd479b5833b3df2d3df6a94ce4fa4c9bf875be24327e59d85c4cbeea7c796381a7bf540bf1f496bc5f958daa7533d86d971602c8dbcfa8bd9c596cddeca84d05c01a1bbae669e6e92a1ea8f1227ba221a86b6c905d0f9df293d27868998607edd2d1ebba12eb9768142eccee0d18cccb25d0aac038be2218e8f64b971d95f341aab5c230acc24d7a03daeaa027a2bf17f5c2c79cf5d7d8a3573b4ea5f44b85a547e64480808a93f0ff4daef8f83fae63ae0a3a0bc32abf3a6bd6285847e2eaab0fb019dba860d7216ba38002ad8a4270496177fa78784c0937ef124b91b0f77b7ff0bb54fc755e5d8fd3f639e0663916ed0aa7d5f287aaa8d4c04f220ed0ddae3d3a3b6166c961d53c4812f3d993e4451d435b32394fe2913a0b239bde9a7b82fb5f1bd720e556d7e4e612260544313fef021e413921265bc69676a64ab45419aeb7f2d678395a9241fcca6db464b3c8481df56c4f10936e95439b667c32082c38a1ecc6cdea745a2f2a668fb64c3727b5f7eed1d4411fe3e0436d085b946cda1a3e01d883e5bf3d40a3ce32305676d00a19d531a4550e5a0cfa5161d301098a1baec7d7ea880f846fafb2006fc100fd632832ef08ad130df1fc5b85e4c519d3f05fa384ccb9b297ddf8ff3ef286e19f29bf5dd0a944f02d3092302b571459e7a07248560d78c9631115d2a52016bce02b00270f048204668e34e88136d7bd1e07696189b41f2f152169c0935e562ff3e735055465a452fb968f2eec318b4a7f438e397a453147c1512d07a0c03a15f3fcdba0799708ba4bc2188559abdddcba6681bf67a414841ed29a363a8f75b6df538ba4e572670b7891aa657180817590019c8d97345022b1d675539f717c39c60424fe20d5a11f44746c33d380556a606c463fc09aa33bc73043c7451cb097714b40527e9e5f4a9f46e1e4f54d2b219e4bcde7047e8254641db8ae94bbdd19e9a11b44e60f0d76cec2802b53708996ea2ec22ef328b524df75d6ec21043c80a41790fb55bc4bee3a6b9e0aef05d44f21e2b53c6e64839a01c750913fe7d18f46e7117fdd9956fe94910959f9c105e4ae06d42843089f7cab106f9785ead20084d2a702fa8468fa97d7aa964be426d3392841d26c434c83cc9b6971ef2b6def987e0588c38909db6f0c33b757dd743387af5f4cb7c08ecf98272e314c85602e21c2561720ccc6d5841e7db5ab0b6a29e97f1d85c60e24d6c7a859fa6990df13 当前文章暂不对外可见，请输入密码后查看！","categories":[{"name":"数据仓库","slug":"数据仓库","permalink":"https://llye-hub.github.io/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"private","slug":"private","permalink":"https://llye-hub.github.io/tags/private/"},{"name":"数仓建模","slug":"数仓建模","permalink":"https://llye-hub.github.io/tags/%E6%95%B0%E4%BB%93%E5%BB%BA%E6%A8%A1/"}]},{"title":"在hive中嵌入自定义数据处理函数-UDF函数","slug":"在hive中嵌入自定义数据处理函数-UDF函数","date":"2023-04-11T09:04:03.000Z","updated":"2023-04-18T07:45:38.183Z","comments":true,"path":"posts/cafe49d7.html","link":"","permalink":"https://llye-hub.github.io/posts/cafe49d7.html","excerpt":"","text":"","categories":[{"name":"hive","slug":"hive","permalink":"https://llye-hub.github.io/categories/hive/"}],"tags":[{"name":"写UDF","slug":"写UDF","permalink":"https://llye-hub.github.io/tags/%E5%86%99UDF/"}]},{"title":"hiveSQL之全面认识窗口函数","slug":"SQL/hiveSQL之全面认识窗口函数","date":"2023-03-31T02:46:52.000Z","updated":"2023-04-07T03:23:39.244Z","comments":true,"path":"posts/ed2327bc.html","link":"","permalink":"https://llye-hub.github.io/posts/ed2327bc.html","excerpt":"","text":"本文内容来自文章Hive SQL大厂必考常用窗口函数及面试题 受岗位性质和工作内容影响，在我从事数仓开发工作至今，对于窗口函数的使用场景都很基础，常用的也只有row_number、sum、max&#x2F;min，偶尔碰到些其他场景，因为不熟悉，可能就需要反复查看官方文档确认。 所以在上面文章阅读过程中，基于个人理解，重新梳理写了本文 窗口函数概述hive官方介绍 窗口函数也称为OLAP函数，是数据分析最常用到的函数，熟练的掌握窗口函数的各种用法和骚操作对从事数据工作者是很重要的。 与聚合函数将多条记录聚合为一条不同，窗口函数每条记录都会执行，执行前后数据量不变，且窗口函数兼具分组和排序两种功能。 窗口函数用法基本语法1&lt;窗口函数&gt; over ([partition by &lt;列名&gt;] [order by &lt;排序列名&gt;] [window_frame]) 其中： &lt;窗口函数&gt;: 指需要使用的分析函数，如row_number()、sum()等。 over() : 用来指定函数执行的窗口范围，这个数据窗口大小可能会随着行的变化而变化。如果括号中什么都不写，则意味着窗口包含满足where条件的所有行，窗口函数基于所有行进行计算 window_frame: 在分组窗口基础上，可以进一步指定窗口计算边界 设置窗口1）partition by子句窗口划分分组条件 12345SELECT uid, score, sum(score) OVER(PARTITION BY uid) AS sum_scoreFROM exam_record 2）order by子句窗口排序条件 12345SELECT uid, score, sum(score) OVER(ORDER BY uid) AS sum_scoreFROM exam_record 3）指定窗口大小指定窗口大小，又称为窗口框架。框架是重新定义窗口计算边界，框架有两种范围限定方式： 一种是使用 ROWS 子句，通过指定当前行之前或之后的固定数目的行来限制分区中的行数。 另一种是使用 RANGE 子句，按照排列序列的当前值，根据相同值来确定分区中的行数。 语法ORDER BY 字段名 RANGE|ROWS 边界规则0 | [BETWEEN 边界规则1 AND 边界规则2]，边界规则的可取值如下： current row：当前行 n preceding：当前行及往前n行数据 unbounded preceding：第一行至当前行数据 n following：当前行及往后n行数据 unbounded following：当前行至最后一行数据 需要注意的是， 使用框架时必须有order by子句 若仅有order by子句而未指定框架，则默认框架语句为range unbounded preceding and current row，详情见文章 4）window_name给窗口指定一个别名WINDOW my_window_name AS (PARTITION BY uid ORDER BY score)，适用于一个窗口被多次使用，可以使sql简洁清晰，也易于维护 12345678910SELECT uid, score, rank() OVER my_window_name AS rk_num, row_number() OVER my_window_name AS row_num, dense_rank() OVER my_window_name AS dr_numFROM exam_recordWHERE score&gt;=60ORDER BY uidWINDOW my_window_name AS (PARTITION BY uid ORDER BY score) 窗口函数分类窗口函数： first_value: 返回计算窗口内按排序条件的第一个值，语法first_value(exp_str,true|false) last_value: 返回计算窗口内按排序条件的最后一个值，语法last_value(exp_str,true|false) lag: 返回相对当前行，第前n行的数据，语法lag(exp_str,offset,defval) over(partition by .. order by …) lead: 返回相对当前行，第后n行的数据，语法lead(exp_str,offset,defval) over(partition by .. order by …) 配合over语句使用的聚合函数： sum count([distinct]) max min avg 分析函数： row_number: 连续排序——1、2、3、4 rank: 并列跳号排序——1、1、3、4 dense_rank: 并列连续排序——1、1、2、3 percent_rank: 将某个数值在数据集中的rank()排位作为数据集的百分比值返回，每行按照公式(rank-1) &#x2F; (rows-1)进行计算，百分比值的范围为 0 到 1。可用于计算值在数据集内的相对位置。语法percent_rank(exp_str) cume_dist: 如果按升序排列，则统计：小于等于当前值的行数&#x2F;总行数。 如果是降序排列，则统计：大于等于当前值的行数&#x2F;总行数。 语法cume_dist(exp_str) ntiles: 将分组数据按照顺序平均切分成n组，并返回当前切片值。语法ntiles(n)。 如果不能平均分配，则优先分配较小编号的切片，并且各个切片中能放的行数最多相差 1。 可简单理解为，有 n 个桶，按编号 1-n 的顺序逐个将分组数据放到每个桶内，直至数据分配完毕。","categories":[{"name":"SQL","slug":"SQL","permalink":"https://llye-hub.github.io/categories/SQL/"}],"tags":[{"name":"hiveSQL","slug":"hiveSQL","permalink":"https://llye-hub.github.io/tags/hiveSQL/"}]},{"title":"读书笔记之数据仓库工具箱维度建模权威指南(第3版)","slug":"阅读笔记/读书笔记之数据仓库工具箱维度建模权威指南-第3版","date":"2023-03-29T06:31:37.000Z","updated":"2023-04-18T08:14:08.029Z","comments":true,"path":"posts/4142350a.html","link":"","permalink":"https://llye-hub.github.io/posts/4142350a.html","excerpt":"这是一篇加密文章，需要密码才能继续阅读。","text":"0ae7e196f2221a75e5346dcbb7e124f36deed831076312fa04e0c81d58c043c17806a367438824993e46b7303f74bdc03c0e9ef99e6f77cba23b77d5795720fb095d0c0e430a499f25eafc1f85fa0f26957e29e45a080da2e8c46c303015a2e2d6358f33b7831aac9e0a2fb3efa003c3cd5eaad97f9f54582e1da9d3f386f64442896e98805a10458108864bf0ef61af265291b4e35171a4ad62b9b68d2af755a6d3a47e23cfd7745f64e906d3d8ee534e387db252f45c508dac4c9ea64049c4a1c46c527800821ef48f838cbb99cc8ee5868166e758e4d826c9191045615239b0bba54723f534af3edc77073e5d173076bcc9d21377398813eebbe67fc13a41ea9b5290197772c51657848492cf450b25cb0fbda050d9f647c76c2ebd3459fd832323e2b8429cc279db814182e50790c0d6be8eb77aeae5900968ddad7ed661712e64bfcdbfc1fef9de209b4c86198573b24d0c8b0c0411af81c363f39c9f2a39a50a4e90b788ba333b563d188038926a4b8395a1fc54527e2e32d417c5ce6f0ab609334238dbf3f9e8a2a14c98c2324bc4e10e89bf085eec861d6b7bb63ba368b0b19eaf6554dce238e24f2eb6adae45ba88b31a41e358062f923d36aa294c5c69aef6cf5bd7e0ac159e04dec4c9afcc6782871a78be29a1af865d6bee02567373df4c8613a2eca0addc868f95d36def19cdf52874a6c37f8a73f02e7406aba0c30837fa9f3f5824054821260a56a37ccd83dc8bf48d55c6aa8a8cf54902233ae65c8539507f899f69cdd4578e899ca62eef20dbc2c62d93024f91675dbb3c44433526d59ccfb6c05b07789cff3c7bd2cc00a1abcb17b4fc14fab6a0e54a9c5468694c93a2b47dcfdffb36940d04ce71a420b1be7b7f34b4d7affc4372014c4022636cd353a115c0cbf51871ba41d55c14f2dac1ac1aaf1bfc8f7ea941568819a2a3fff8d5d45baf70a186d14ab11f375333786ec21e5c2c899504a9ffedba9864a1ed410fc0f58dd54d0200d0c39885ee14a485527caa2873936f60d4f7b84c34cce55e813a133ba372f781098969dacd4822610fb052f127c250bc50751f6f898875e0d8e4f2651497822fe62ce2fd9fcc8a2d157f870d1567e9975390486f1649f47d7bd22d2c47d6e8123f0d9a0867d731624d11c059793bfffcf417442ce4613c032d7fe5dc8b3f3a5dc5928ca0203636dad75632ff16d3a60447404feed43c0abe71f8c230b7448bcbd5a8b2fbb6bc6fde25b66bb65119415b55883fa33045f15360a426b8e57e3d1883b7e275259b408bfe2dbd99489a169defdde7cd9d3f1ebacb81189a59580199edbe0fdc72c80e15ab587b9e14abe0f7e4b635b4bbde877e75ef8b80b5b3330086c5a21104e737d1abae006ac6ca62e5910562b8dd19e83011e5b3099d270b238fc9d281476d06df4ba20b62eaa1db8ab10fb9e767162c78277f2b35ad15ed94a1f93fa9c1350a9b2cc42aec7f1b2742d3dc1deec41b7bdecad8d211b1b61bf6a4fa1a7354c57857f7f3091e64b7997a9392f61fd3d83fa37ebcd824fbd8e228134d72ff5207950a1bb1c83e68c6d7786dddad528cfa8f56cc5bda0195457edeec78abbcb9b8d4c05cc2c61cb0461db5d8954feecc1fe224f19f8756785cc826673959038e4a4800e158887a9dade68e86b099f1687be6418dc3482c001135ecf21d1366dbc41aa1284b08434a6c9612aaeeb6 当前文章暂不对外可见，请输入密码后查看！","categories":[{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://llye-hub.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"private","slug":"private","permalink":"https://llye-hub.github.io/tags/private/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://llye-hub.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"内置函数之reflect","slug":"内置函数之reflect","date":"2023-03-22T09:39:53.000Z","updated":"2023-03-29T03:43:07.269Z","comments":true,"path":"posts/1d24daf8.html","link":"","permalink":"https://llye-hub.github.io/posts/1d24daf8.html","excerpt":"","text":"","categories":[{"name":"SQL","slug":"SQL","permalink":"https://llye-hub.github.io/categories/SQL/"}],"tags":[{"name":"内置函数","slug":"内置函数","permalink":"https://llye-hub.github.io/tags/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"}]},{"title":"搭建spark on yarn源码调试","slug":"spark/搭建spark-on-yarn源码调试","date":"2023-03-21T09:02:06.000Z","updated":"2023-03-29T03:43:07.272Z","comments":true,"path":"posts/5e1f3fb0.html","link":"","permalink":"https://llye-hub.github.io/posts/5e1f3fb0.html","excerpt":"","text":"参考文章Spark3.0.1各种集群模式搭建及spark on yarn日志配置Spark on Yarn集群搭建详细过程 环境准备jdk8+Hadoop3.3.1 spark的几种部署方式Spark作为准实时大数据计算引擎，Spark的运行需要依赖资源调度和任务管理，Spark自带了standalone模式资源调度和任务管理工具，运行在其他资源管理和任务调度平台上，如Yarn、Mesos、Kubernates容器等。 spark的搭建和Hadoop差不多，主要有下面几种部署方式： Local：多用于本地测试，如在eclipse，idea中写程序测试等。 Standalone：Standalone是Spark自带的一个资源调度框架，它支持完全分布式。 Yarn：Hadoop生态圈里面的一个资源调度框架，Spark也是可以基于Yarn来计算的。 基于个人学习需求，本文仅记录Local模式部署过程。 下载spark源码下载地址 解压 1tar -zcvf spark-3.2.0-bin-hadoop3.2.tgz 配置环境变量 1234567# 编辑# SPARK_HOME=/Users/llye/workspace/spark-3.2.0-bin-hadoop3.2 # export PATH=$SPARK_HOME/bin:$PATHvi ~/.bash_profile # 生效source ~/.bash_profile 本地local模式测试样例 12cd $SPARK_HOME/bin run-example SparkPi 10 # 可计算出结果 2426 1spark-shell # 启动成功，说明Local模式部署成功 2764 启动成功后，访问http://localhost:4040/ 即可进行web UI监控页面访问 Standalone模式（未完成，不具参考性）配置Spark on Yarn集群 修改spark-env.sh文件 12345678910111213cd $SPARK_HOME/confcat &gt; spark-env.sh &lt;&lt; EOFJAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_301.jdk/Contents/Home/SCALA_HOME=/Users/llye/soft/scala/HADOOP_HOME=/Users/llye/soft/hadoop-3.3.1/HADOOP_CONF_DIR=/Users/llye/soft/hadoop-3.3.1/etc/hadoop/YARN_CONF_DIR=/Users/llye/soft/hadoop-3.3.1/etc/hadoop/etc/hadoop/SPARK_MASTER_HOST=spark # 主节点机器名称SPARK_MASTER_PORT=7077 # 默认端口号7077SPARK_HOME=/Users/llye/workspace/spark-3.2.0-bin-hadoop3.2/SPARK_LOCAL_DIRS=/Users/llye/workspace/spark-3.2.0-bin-hadoop3.2/SPARK_LIBARY_PATH=/Library/Java/JavaVirtualMachines/jdk1.8.0_301.jdk/Contents/Home/lib/:/Users/llye/soft/hadoop-3.3.1/lib/native/EOF 修改slaves配置文件 1234cd $SPARK_HOME/sbin vi slaves# spark001# spark002 将spark目录发送到其他机器 创建workers文件，指定Worker节点： 123456cd $SPARK_HOME/confcat &gt; workers &lt;&lt; EOFworker1worker2worker3EOF 启动Spark on Yarn集群1cd $SPARK_HOME/sbin 在Spark节点上启动Spark Master节点： 1start-master.sh 在Worker节点上启动Spark Worker节点： 1start-worker.sh spark://spark:7077 登录Spark on Yarn集群登录Master： 登录Worker：http://localhost:8081/","categories":[{"name":"spark","slug":"spark","permalink":"https://llye-hub.github.io/categories/spark/"}],"tags":[{"name":"spark on yarn","slug":"spark-on-yarn","permalink":"https://llye-hub.github.io/tags/spark-on-yarn/"}]},{"title":"hive本机安装","slug":"hive/hive本机安装","date":"2023-03-15T02:49:23.000Z","updated":"2023-05-05T03:32:22.681Z","comments":true,"path":"posts/47d5b7b0.html","link":"","permalink":"https://llye-hub.github.io/posts/47d5b7b0.html","excerpt":"","text":"参考文章 Hive源码系列（一）hive2.1.1+hadoop2.7.3环境搭建 Hive安装超详细教程 Hive架构与源码分析 Hive:源码解析之本地环境搭建 环境准备jdk8 + Hadoop3.3.1 下载安装下载地址 解压安装包 1tar -zxvf apache-hive-2.3.9-bin.tar.gz 环境变量配置 12345678910# 编辑# HIVE_HOME=/Users/llye/soft/hive-2.3.9# export PATH=$HIVE_HOME/bin:$PATHvi ~/.bash_profile # 生效source ~/.bash_profile# 验证hive --version 修改配置文件 1cd $HIVE_HOME/conf vi hive-site.xml编辑内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;configuration&gt; &lt;!-- 以mysql作为hive元数据库 --&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:mysql://localhost:3306/hivedb?createDatabaseIfNotExist=true&amp;amp;characterEncoding=UTF-8&amp;amp;useSSL=false&amp;amp;serverTimezone=GMT&lt;/value&gt; &lt;description&gt;hive metastore连接串&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt; &lt;value&gt;com.mysql.cj.jdbc.Driver&lt;/value&gt; &lt;description&gt;Hive metastore JDBC驱动&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt; &lt;value&gt;root&lt;/value&gt; &lt;description&gt;Mysql登录账号&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;rootroot&lt;/value&gt; &lt;description&gt;Mysql登录密码&lt;/description&gt; &lt;/property&gt; &lt;!-- 忽略HIVE 元数据库版本的校验，如果非要校验就得进入MYSQL升级版本 --&gt; &lt;property&gt; &lt;name&gt;hive.metastore.schema.verification&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.cli.print.current.db&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.cli.print.header&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;!-- 配置hive用户名、密码 --&gt; &lt;property&gt; &lt;name&gt;hive.jdbc_passwd.auth.root&lt;/name&gt; &lt;value&gt;rootroot&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.jdbc_passwd.auth.llye&lt;/name&gt; &lt;value&gt;rootroot&lt;/value&gt; &lt;/property&gt; &lt;!-- hiveserver2 --&gt; &lt;!-- 配置用户安全认证方式 --&gt; &lt;property&gt; &lt;name&gt;hive.server2.authentication&lt;/name&gt; &lt;value&gt;NONE&lt;/value&gt; &lt;description&gt; Expects one of [nosasl, none, ldap, kerberos, pam, custom]. Client authentication types. NONE: no authentication check LDAP: LDAP/AD based authentication KERBEROS: Kerberos/GSSAPI authentication CUSTOM: Custom authentication provider (Use with property hive.server2.custom.authentication.class) PAM: Pluggable authentication module NOSASL: Raw transport &lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.server2.custom.authentication.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.hive.contrib.auth.CustomPasswdAuthenticator&lt;/value&gt; &lt;description&gt;配置用于权限认证的类【这里实际没有】&lt;/description&gt; &lt;/property&gt; &lt;!-- 指定 hiveserver2 jdbc连接的 host+port --&gt; &lt;property&gt; &lt;name&gt;hive.server2.thrift.bind.host&lt;/name&gt; &lt;value&gt;localhost&lt;/value&gt; &lt;description&gt;hiveserver2 jdbc连接的 host&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.server2.thrift.port&lt;/name&gt; &lt;value&gt;10000&lt;/value&gt; &lt;description&gt;hiveserver2 jdbc连接的端口号&lt;/description&gt; &lt;/property&gt; &lt;!-- 配置webUI界面 host+port --&gt; &lt;property&gt; &lt;name&gt;hive.server2.webui.host&lt;/name&gt; &lt;value&gt;localhost&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.server2.webui.port&lt;/name&gt; &lt;value&gt;10002&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 下载连接MySQL的驱动包到hive的lib目录下 mysql-connector-java-8.0.17.jar下载地址 初始化hive元数据库 12cd $HIVE_HOME/binschematool -initSchema -dbType mysql -verbose 验证初始化是否成功 12-- mysql的hivedb库中，若展示多个数据表，即代表初始化成功show tables; 18886 启动hive 1234$HADOOP_HOME/sbin/start-dfs.sh &amp;$HADOOP_HOME/sbin/start-yarn.shcd $HIVE_HOME hive 遇到启动报错org.apache.hadoop.hdfs.server.namenode.SafeModeException): Cannot create directory /tmp/hive时，执行命令hdfs dfsadmin -safemode leave关闭HDFS安全模式 验证 123456-- 建表create table student(id int, name string);-- 插入数据insert into table student values(1, &#x27;abc&#x27;);-- 查询数据select * from student; 20880 beeline连接hiveserver2hadoop配置 1cd $HADOOP_HOME/etc/hadoop vi core-site.xml补充内容如下： 12345678910111213141516&lt;property&gt; &lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt; &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt; &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hadoop.proxyuser.llye.groups&lt;/name&gt; &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hadoop.proxyuser.llye.hosts&lt;/name&gt; &lt;value&gt;*&lt;/value&gt;&lt;/property&gt; 重启hadoop 12$HADOOP_HOME/sbin/stop-all.sh &amp;$HADOOP_HOME/sbin/start-all.sh 启动metastore 配置了hive的环境变量，任意文件夹下执行即可 1hive --service metastore 启动hiveserver2 配置了hive的环境变量，任意文件夹下执行即可 123hiveserver2# 或hive --service hiveserver2 若hiveserver2启动失败，检查1000端口是否被占用，命令lsof -i:10000和kill -9 xxx beeline连接 1234beelinebeeline&gt; !connect jdbc:hive2://localhost:10000/default# 或beeline -u jdbc:hive2://localhost:10000/default 遇到报错问题的参考： beeline连接hiveserver2报错：User: root is not allowed to impersonate root Hive JDBC：Permission denied: user&#x3D;anonymous, access&#x3D;EXECUTE, inode&#x3D;”&#x2F;tmp” 客户端jdbc连接hive库启动metastore和hiveserver2 12345hive --service metastorehiveserver2# 或hive --service hiveserver2 DBeaver连接，设置jdbc URL：jdbc:hive2://localhost:10000/default hive源码编译解压安装包 1tar -zxvf apache-hive-2.3.9-src.tar.gz 编译源码 进入解压目录 1mvn clean package -DskipTests -Phadoop-2 -Pdist 编译过程中报错An error has occurred in JavaDocs report generation:Exit code: 1 - javadoc: error - invalid flag: -author，解决方案: 1234567891011121314151617181920212223242526&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;maven.javadoc.plugin.version&#125;&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;resourcesdoc.xml&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;javadoc&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;compile&lt;/phase&gt; &lt;configuration&gt; &lt;encoding&gt;$&#123;project.build.sourceEncoding&#125;&lt;/encoding&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;show&gt;public&lt;/show&gt; &lt;doclet&gt;com.sun.jersey.wadl.resourcedoc.ResourceDoclet&lt;/doclet&gt; &lt;docletArtifacts&gt; …… &lt;/docletArtifacts&gt; &lt;additionalparam&gt;-output $&#123;project.build.outputDirectory&#125;/resourcedoc.xml&lt;/additionalparam&gt; &lt;!-- pom文件中加上此项配置 --&gt; &lt;useStandardDocletOptions&gt;false&lt;/useStandardDocletOptions&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 导入idea 从hive的解压目录中选择pom.xml文件导入 调试代码 进入解压目录 123cd packaging/target/apache-hive-2.3.9-bin/apache-hive-2.3.9-binhive --debug -hiveconf hive.root.logger=DEBUG,console 成功时，界面出现： 1Listening for transport dt_socket at address: 8000 JVM会监听8000端口，等待客户端调试连接。 进入idea配置远程连接如下：33738 hive的CLI的入口类为：src/java/org/apache/hadoop/hive/cli/CliDriver.java，断点调试成功如下：33872","categories":[{"name":"hive","slug":"hive","permalink":"https://llye-hub.github.io/categories/hive/"}],"tags":[{"name":"hive安装","slug":"hive安装","permalink":"https://llye-hub.github.io/tags/hive%E5%AE%89%E8%A3%85/"}]},{"title":"hadoop本机安装","slug":"hadoop/hadoop本机安装","date":"2023-03-15T02:49:02.000Z","updated":"2023-05-05T02:56:45.176Z","comments":true,"path":"posts/2cb81866.html","link":"","permalink":"https://llye-hub.github.io/posts/2cb81866.html","excerpt":"","text":"参考文章 Hive源码系列（一）hive2.1.1+hadoop2.7.3环境搭建 Hadoop【单机安装-测试程序WordCount】 Hadoop 安装有三种方式： 单机模式：安装简单，几乎不用做任何配置，但仅限于调试用途； 伪分布模式：在单节点上同时启动 NameNode、DataNode、JobTracker、TaskTracker、Secondary Namenode 等 5 个进程，模拟分布式运行的各个节点； 完全分布式模式：正常的 Hadoop 集群，由多个各司其职的节点构成。 本人选择的是伪分布模式安装 下载安装 下载地址 解压安装包 1tar -zxvf hadoop-3.3.1.tar.gz 环境变量配置 12345678910# 编辑# HADOOP_HOME=/Users/llye/soft/hadoop-3.3.1# export PATH=$HADOOP_HOME/bin:$PATHvi ~/.bash_profile # 生效source ~/.bash_profile# 验证hadoop version 修改配置文件 1cd $HADOOP_HOME/etc/hadoop vi core-site.xml编辑内容如下： 1234567&lt;configuration&gt;&lt;!-- 配置分布式文件系统的schema和ip以及port,默认8020--&gt;&lt;property&gt;&lt;name&gt;fs.defaultFS&lt;/name&gt;&lt;value&gt;hdfs://localhost:8020&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt; vi hdfs-site.xml编辑内容如下： 1234567&lt;configuration&gt;&lt;!-- 配置副本数，注意，伪分布模式只能是1。--&gt;&lt;property&gt;&lt;name&gt;dfs.replication&lt;/name&gt;&lt;value&gt;1&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt; vi hadoop-env.sh编辑内容如下： 1export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_301.jdk/Contents/Home vi mapred-site.xml编辑内容如下： 12345678910111213141516171819&lt;configuration&gt;&lt;property&gt;&lt;name&gt;mapreduce.framework.name&lt;/name&gt;&lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;yarn.app.mapreduce.am.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;mapreduce.map.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;mapreduce.reduce.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt; vi yarn-site.xml编辑内容如下： 12345678&lt;configuration&gt;&lt;!-- Site specific YARN configuration properties --&gt;&lt;property&gt;&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;&lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt; ssh免密码登录 123ssh-keygen -t rsa -P &#x27;&#x27; -f ~/.ssh/id_rsacat ~/.ssh/id_rsa.pub&gt;&gt; ~/.ssh/authorized_keyschmod 0600~/.ssh/authorized_keys 以前安装其他软件已操作过，所以此步骤忽略 格式化namenode 1hdfs namenode -format 忽略SHUTDOWN_MSG: Shutting down NameNode at localhost/127.0.0.1 有INFO common.Storage: Storage directory /tmp/hadoop-llye/dfs/name has been successfully formatted.即说明操作成功。 启动 12$HADOOP_HOME/sbin/start-dfs.sh &amp;$HADOOP_HOME/sbin/start-yarn.sh 验证 12345678910root@localhost hadoop % jps11440 11169 74514 NameNode # 名称节点74756 SecondaryNameNode74999 ResourceManager75098 NodeManager75834 Jps19771 Launcher74620 DataNode # 数据节点 访问UI：ip+port All Applications：http://localhost:8088/cluster/apps Applications running on this node：http://localhost:8042/node/allApplications12685 Browse Hdfs：http://localhost:9870/12779 这里需要注意的是，因为安装的是3.x版本，所以端口号为9870 若安装的是2.x版本，则端口号为50070 12892 测试程序 测试一 12cd $HADOOP_HOMEhadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-3.3.1.jar pi 2 100 测试二 123456789101112131415161718192021222324252627cd $HADOOP_HOME# 创建一个hdfs目录hdfs dfs -mkdir /wordcount# 造数据# hello hadoop# hello world# hello hadoop# hello hangzhou# hello hangzhou# hello hadoopmkdir wordCountcd wordCounttouch wc.inputvi wc.inputcat wc.input# 上传本地文件到指定目录hdfs dfs -put wc.input /wordcount# 运行mr程序cd $HADOOP_HOMEhadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-3.3.1.jar wordcount /wordcount/ /wordcount/output# 查看mr计算结果hadoop fs -cat /wordcount/output/part-r-00000 停止 12$HADOOP_HOME/sbin/stop-dfs.sh &amp;$HADOOP_HOME/sbin/stop-yarn.sh 补充：hadoop启动会遇到的问题 namenode启动失败，使用jps命令查看时无namenode进程 解决办法： 执行命令hdfs namenode -format重新格式化namenode 执行命令hadoop-daemon.sh start namenode单独启动namenode，若是其他哪个进程挂了也可以采取这种方式。（本地尚未试过这种解决方式） 修改core-site.xml和hdfs-site.xml配置，再重新格式化namenode。因为系统重启后namenode和datanode的信息被清理了 core-site.xml补充配置如下： &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/Users/llye/hadoop/tmp&lt;/value&gt; &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt; hdfs-site.xml补充配置如下： &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;/Users/llye/hadoop/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/Users/llye/hadoop/tmp/dfs/data&lt;/value&gt; &lt;/property&gt; 若执行命令hdfs namenode -format报错：17893上面报错原因是权限不够，无法再目录内新建文件，解决办法是执行命令sudo chmod -R a+w /Users/llye/hadoop，再格式化namenode就ok了。 修改配置后，系统启动后会默认路径下的文件作为namenode、datanode的配置信息","categories":[{"name":"hadoop","slug":"hadoop","permalink":"https://llye-hub.github.io/categories/hadoop/"}],"tags":[{"name":"hadoop安装","slug":"hadoop安装","permalink":"https://llye-hub.github.io/tags/hadoop%E5%AE%89%E8%A3%85/"}]},{"title":"终端常用命令汇总","slug":"shell/终端常用命令汇总","date":"2023-03-15T02:29:05.000Z","updated":"2023-03-21T08:09:18.234Z","comments":true,"path":"posts/84fddb38.html","link":"","permalink":"https://llye-hub.github.io/posts/84fddb38.html","excerpt":"","text":"获取本机ip地址12345678910#!/bin/shlocal_ip=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk &#x27;&#123;print $2&#125;&#x27;|tr -d &quot;addr:&quot;​`echo &quot;$&#123;local_ip&#125;&quot;ifconfig -a //和window下执行此命令一样道理，返回本机所有ip信息grep inet //截取包含ip的行grep -v 127.0.0.1 //去掉本地指向的那行grep -v inet6 //去掉包含inet6的行awk &#123; print $2&#125; //$2 表示默认以空格分割的第二组 同理 $1表示第一组​tr -d &quot;addr:&quot; //删除&quot;addr:&quot;这个字符串 https://blog.csdn.net/finghting321/article/details/108476650 查找文件1find / -iname $filename 2&gt; /dev/null","categories":[{"name":"shell","slug":"shell","permalink":"https://llye-hub.github.io/categories/shell/"}],"tags":[{"name":"shell命令","slug":"shell命令","permalink":"https://llye-hub.github.io/tags/shell%E5%91%BD%E4%BB%A4/"}]},{"title":"终端免密登录mysql","slug":"shell/终端免密登录mysql","date":"2023-03-14T07:29:49.000Z","updated":"2023-03-14T08:04:15.277Z","comments":true,"path":"posts/b31f5f52.html","link":"","permalink":"https://llye-hub.github.io/posts/b31f5f52.html","excerpt":"","text":"参考资料：Mysql Shell免密登录的思考及实际应用案例 常见终端登录mysql的方式是通过命令mysql -u&#123;user&#125; -p&#123;password&#125;，每次登录都需要输入一长串命令和参数，我觉得麻烦，且这种方式下密码直接暴露出来是不安全的 虽然也可用命令mysql -u&#123;user&#125; -p + 手动输入密码，也是麻烦的，而且还要记密码 所以，如果仅用命令mysql即可实现登录，那得多方便 从网上搜索后发现，可以通过明文配置文件的方式实现mysql免密登录 具体命令如下： 1234567891011121314# 编辑配置文件# [mysql]# user=xxx# password=xxxsudo vi /etc/my.cnf# 查看文件内容cat /etc/my.cnf# 指定mysql server仅从这个配置文件读取参数mysql --defaults-file=/etc/my.cnf# 验证读取配置情况mysql --defaults-file=/etc/my.cnf --print-defaults 2126","categories":[{"name":"shell","slug":"shell","permalink":"https://llye-hub.github.io/categories/shell/"}],"tags":[{"name":"免密登录","slug":"免密登录","permalink":"https://llye-hub.github.io/tags/%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"}]},{"title":"sql练习之连续登录问题","slug":"数据结构与算法笔记/sql练习之连续登录问题","date":"2023-03-10T08:22:38.000Z","updated":"2023-06-28T02:03:26.192Z","comments":true,"path":"posts/67cc9ac.html","link":"","permalink":"https://llye-hub.github.io/posts/67cc9ac.html","excerpt":"","text":"题目来源 题目要求求出连续3天登录的用户id 数据12345678910111213141516CREATE TABLE if not exists one.user_login( id int COMMENT &#x27;用户主键&#x27;, dt varchar(20) COMMENT &#x27;登录日期&#x27; );insert into user_login values(1001,&#x27;2021-12-12&#x27;);insert into user_login values(1002,&#x27;2021-12-12&#x27;);insert into user_login values(1001,&#x27;2021-12-13&#x27;);insert into user_login values(1001,&#x27;2021-12-14&#x27;);insert into user_login values(1001,&#x27;2021-12-16&#x27;);insert into user_login values(1002,&#x27;2021-12-16&#x27;);insert into user_login values(1001,&#x27;2021-12-19&#x27;);insert into user_login values(1002,&#x27;2021-12-17&#x27;);insert into user_login values(1001,&#x27;2021-12-20&#x27;); 解题解法一：自关联12345678910111213141516171819202122232425select distinct idfrom ( SELECT id from ( select a.id , a.dt as dt1 , b.dt as dt2 from user_login a left join user_login b on a.id = b.id and (b.dt between DATE_SUB(a.dt, interval 2 day) and a.dt) ) tmp1 group by id, dt1 having count(1) = 3 )tmp2;","categories":[{"name":"练习笔记","slug":"练习笔记","permalink":"https://llye-hub.github.io/categories/%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"sql练习","slug":"sql练习","permalink":"https://llye-hub.github.io/tags/sql%E7%BB%83%E4%B9%A0/"}]},{"title":"SQL之窗口函数的边界","slug":"SQL/SQL之窗口函数的边界","date":"2023-02-28T08:25:40.000Z","updated":"2023-03-01T07:30:20.176Z","comments":true,"path":"posts/5af52219.html","link":"","permalink":"https://llye-hub.github.io/posts/5af52219.html","excerpt":"","text":"前言窗口函数常用于在SQL数据分析计算各种统计指标，也是日常sql开发中常见的函数了，但是最近发现自己在这方面存在一些误解 比如下面这段sql 1234select col1 ,sum(col2) over(partition by col1 order by col3) as sum1 ,sum(col2) over(partition by col1) as sum2from (select * from (VALUES(&#x27;a&#x27;,1,4),(&#x27;a&#x27;,2,7),(&#x27;a&#x27;,3,6)) t(col1,col2,col3)) a 第一眼感觉sum1和sum2字段计算值是一样的，但实际运行出来的结果为(mysql+hiveSQL) col1 sum1 sum2 a 1 6 a 4 6 a 6 6 从执行结果上来看，sum1字段为窗口内的累加值，sum2字段值为窗口内所有值之和 为什么有无order by差异这么大有人会说，聚合函数sum()的窗口内有order by子句时，计算结果本就是累加性质。从执行结果上来看，这么说是对的，但是这种解释太流于表面，并没有真正从函数定义上解释为什么 这里重新回顾下窗口函数基本语法： 1&lt;window_function&gt; over (partition by &lt;column_name&gt; order by &lt;column_name&gt; &lt;window_frame&gt;) 主要有四个部分： window_function：函数，比如：sum、row_number、first_value partition by：窗口分区子句 order by：窗口排序子句 window_frame：窗口框架，限制窗口的边界大小 对照基本语法，有order by子句的执行结果就是计算窗口边界为起始行至当前行的sum结果，即sum(col2) over(partition by col1 order by col3)等同于sum(col2) over(partition by col1 order by col3 rows between unbounded preceding and current row) 窗口函数的官方说明mysql官方文档 hive官方文档 mysql关于窗口函数的window_frame有如下说明：3239 hive关于窗口函数的window_frame有如下说明：3328 根据以上官方说明可知，当window_frame子句和order by子句都没有时，窗口计算默认包含窗口内的所有数据，即window_frame=ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING；当仅有order by子句，没有window_frame子句时，窗口计算默认仅包含排序后起始行至当前行的数据，即window_frame=ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW","categories":[{"name":"SQL","slug":"SQL","permalink":"https://llye-hub.github.io/categories/SQL/"}],"tags":[{"name":"窗口函数","slug":"窗口函数","permalink":"https://llye-hub.github.io/tags/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"}]},{"title":"关于Java PriorityQueue类的使用场景","slug":"数据结构与算法笔记/关于Java-PriorityQueue类的使用场景","date":"2023-02-23T08:53:35.000Z","updated":"2023-06-28T02:03:26.234Z","comments":true,"path":"posts/76a5661e.html","link":"","permalink":"https://llye-hub.github.io/posts/76a5661e.html","excerpt":"","text":"最近在leetcode刷题的时候，发现很多题推荐解法是用优先队列的特性，比如：滑动窗口的最大值 、丑数 以前完全没有用个这个类，所以在此整理一下对优先队列的认识和刷题场景 优先队列的特性很明显，优先队列也是一种队列，只不过其出队顺序和一般队列不同，优先队列的出队顺序是按照一定的优先级来的，也就是说出队规则可以随意定制 优先队列ADT是一种数据结构，它支持插入、删除最小值操作（返回并删除最小元素）、删除最大值操作（返回并删除最大元素） 优先队列的主要操作：优先队列是元素的容器，每个元素有一个相关的键值 insert(key, data)：插入键值为key的数据到优先队列中，元素以其key进行排序 deleteMin&#x2F;deleteMax：删除并返回最小&#x2F;最大键值的元素 getMinimum&#x2F;getMaximum：返回最小&#x2F;最大剑指的元素，但不删除它 优先队列的辅助操作： 第k最小&#x2F;第k最大：返回优先队列中键值为第k个最小&#x2F;最大的元素 大小（size）：返回优先队列中的元素个数 堆排序（Heap Sort）：基于键值的优先级将优先队列中的元素进行排序 在某些场景下，比如要求队列中的最小元素先出即可用优先队列，在java中的实现类为java.util.PriorityQueue。 认识下PriorityQueue类的方法创建对象12345678// 默认情况下，优先级队列的头是队列中最小的元素，元素将按升序从队列中移除PriorityQueue&lt;Integer&gt; nums = new PriorityQueue&lt;&gt;();// 借助 Comparator 接口自定义元素的顺序，头是队列中最大的元素，按降序从队列中移除PriorityQueue&lt;int[]&gt; win = new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;() &#123; public int compare(int[] a, int[] b) &#123; return a[0] != b[0] ? b[0] - a[0] : b[1] - a[1]; &#125;&#125;); 插入元素：add、offer12345678910111213141516171819202122232425class Main &#123; public static void main(String[] args) &#123; //创建优先队列 PriorityQueue&lt;Integer&gt; numbers = new PriorityQueue&lt;&gt;(); //使用add()方法，如果队列已满，则会引发异常 numbers.add(4); numbers.add(2); System.out.println(&quot;PriorityQueue: &quot; + numbers); //使用offer()方法，如果队列已满，则返回false numbers.offer(1); System.out.println(&quot;更新后的PriorityQueue: &quot; + numbers); &#125;&#125;/* * 输出结果： * PriorityQueue: [2, 4] * 更新后的PriorityQueue: [1, 4, 2] * * 以上结果中，队列的头是最小元素 */ 访问元素：peek12345678//使用 peek() 方法int number = nums.peek();System.out.println(&quot;访问元素: &quot; + number);/* * 输出结果： * 访问元素: 1 */ 删除元素：remove、poll12345678910111213//使用remove()方法，从队列中删除指定的元素boolean result = numbers.remove(2);System.out.println(&quot;元素2是否已删除? &quot; + result);//使用poll()方法，返回并删除队列的头int number = numbers.poll();System.out.println(&quot;使用poll()删除的元素: &quot; + number);/* * 输出结果： * 元素2是否已删除? true * 使用poll()删除的元素: 1 */ 是否包含元素：contains12345678//使用contains()方法，从队列中搜索指定的元素，找到则返回true，否则false。boolean result = numbers.contains(4);System.out.println(&quot;队列中是否有元素 4 ？&quot; + result);/* * 输出结果： * 队列中是否有元素 4 ？ true */ 刷题场景滑动窗口的最大值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。 //示例: //输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3//输出: [3,3,5,5,6,7] //解释:// 滑动窗口的位置 最大值//--------------- -----//[1 3 -1] -3 5 3 6 7 3// 1 [3 -1 -3] 5 3 6 7 3// 1 3 [-1 -3 5] 3 6 7 5// 1 3 -1 [-3 5 3] 6 7 5// 1 3 -1 -3 [5 3 6] 7 6// 1 3 -1 -3 5 [3 6 7] 7import java.util.Comparator;import java.util.PriorityQueue;/* * 解题思路：利用优先队列的特性，规定堆顶元素就是窗口最大值 * */class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; int len = nums.length; PriorityQueue&lt;int[]&gt; win = new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;() &#123; // 重新定义出队规则 @Override public int compare(int[] a, int[] b) &#123; return a[0] != b[0] ? b[0] - a[0] : b[1] - a[1]; &#125; &#125;); // 初始化窗口 for (int i = 0; i &lt; k; ++i) &#123; win.offer(new int[]&#123;nums[i], i&#125;); &#125; // 创建指定长度的结果数组 int[] res = new int[len-k+1]; // 第一个窗口的最大值 res[0] = win.peek()[0]; // 遍历滑动窗口 for (int i = k; i &lt; len; ++i) &#123; // 添加新元素 win.offer(new int[]&#123;nums[i], i&#125;); // 删除窗口长度外的元素 while (win.peek()[1] &lt;= i - k) &#123; win.poll(); &#125; // 返回当前窗口的最大值 res[i - k + 1] = win.peek()[0]; &#125; return res; &#125;&#125; 丑数12345678910111213141516171819202122232425262728293031323334353637383940// 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。// 示例: // 输入: n = 10// 输出: 12// 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 // 说明:// 1 是丑数。 // n 不超过1690。import java.util.HashSet;import java.util.PriorityQueue;import java.util.Set;/* * 解题思路：最小堆，需借助java的PriorityQueue类的特性实现：https://www.cainiaojc.com/java/java-priorityqueue.html * 初始化堆，将最小丑数1放入堆 * 每次取出堆顶元素x，x元素也是堆中最小的丑数，需排除重复元素，依次将 2x,3x,5x 加入堆 * 第n次取出的堆顶元素就是第n个丑数 * */class Solution &#123; public int nthUglyNumber(int n) &#123; int[] factors = &#123;2,3,5&#125;; PriorityQueue&lt;Long&gt; heap = new PriorityQueue&lt;Long&gt;(); //优先级队列的头是队列中最小的元素 heap.offer(1L); // 初始化最小堆，放入最小丑数1 int ugly = 0; for(int i=0; i&lt;n; i++)&#123; long cur = heap.poll(); //返回并删除队列的头，即最小元素 ugly = (int) cur; for (int factor : factors)&#123; long next = cur*factor; //检查是否有重复元素 if(!heap.contains(next))&#123; heap.offer(next); &#125; &#125; &#125; return ugly; &#125;&#125; 数据流中的中位数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* 解题思路：优先队列* 利用优先队列的特性实现，队头是最大值* */class MedianFinder &#123; // 初始化两个优先队列，分别存放 小于等于 和 大于 中位数的数值 PriorityQueue&lt;Integer&gt; queueMin; PriorityQueue&lt;Integer&gt; queueMax; /** initialize your data structure here. */ public MedianFinder() &#123; // queueMin队头为队列最大值，queueMax对头为队列最小值 queueMin = new PriorityQueue&lt;Integer&gt;((a,b) -&gt;(b-a)); queueMax = new PriorityQueue&lt;Integer&gt;((a,b) -&gt;(a-b)); &#125; public void addNum(int num) &#123; // num小于等于中位数，则num放入queueMin队列；num大于中位数，则num放入queueMax队列 // 注意if条件语句的先后顺序很重要 if (queueMin.isEmpty() || num &lt;= queueMin.peek()) &#123; queueMin.add(num); // queueMin队列大小超出，则将max(queueMin)元素放入queueMax队列 if (queueMin.size() &gt; queueMax.size() + 1) &#123; queueMax.add(queueMin.poll()); &#125; &#125; else &#123; queueMax.add(num); // queueMax队列大小超出，则将min(queueMin)元素放入queueMin队列 if (queueMax.size() &gt; queueMin.size()) &#123; queueMin.add(queueMax.poll()); &#125; &#125; &#125; public double findMedian() &#123; // 从数据流中读出奇数个数值 if (queueMin.size() &gt; queueMax.size()) &#123; return queueMin.peek(); &#125; // 从数据流中读出偶数个数值 return (queueMin.peek() + queueMax.peek()) / 2.0; &#125;&#125;/** * Your MedianFinder object will be instantiated and called as such: * MedianFinder obj = new MedianFinder(); * obj.addNum(num); * double param_2 = obj.findMedian(); */ 参考资料数据结构与算法(4)——优先队列和堆 Java PriorityQueue","categories":[{"name":"练习笔记","slug":"练习笔记","permalink":"https://llye-hub.github.io/categories/%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"https://llye-hub.github.io/tags/java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://llye-hub.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"hive、Spark和Maxcompute的SQL语法对比分析","slug":"SQL/hive、Spark和Maxcompute的SQL语法对比分析","date":"2023-02-21T02:33:16.000Z","updated":"2023-02-22T06:42:32.480Z","comments":true,"path":"posts/e6b1209.html","link":"","permalink":"https://llye-hub.github.io/posts/e6b1209.html","excerpt":"","text":"having 差异差异点hive和spark支持窗口函数后带havingmaxcomputer 的having语法只支持 在 group 和 distinct 后使用 举例1234select order_id,sum(trd_amt) over(partition by province) as trd_amt_stdfrom orderhaving trd_amt_std&gt;0 以上sql在hive中可以运行，但是在maxcomputer中会提示错误，错误如下：998 替换方案在语句中使用子查询，将having替换为where 1234567select *from(select order_id,sum(trd_amt) over(partition by province) as trd_amt_stdfrom order) awhere a.trd_amt_std&gt;0 maxcomputer - cross join 超过一定条数后，依然会提示笛卡尔积风险差异点hive可以使用 cross join语法来表示笛卡尔积关联maxcomputer 的cross join，在条数超过一定数据量后，会提示笛卡尔积风险 举例1234567select a.*,b.*from(select * from table_a) across join(select * from table_b) b 以上sql在hive中可以运行，但是在maxcomputer中会提示错误，错误如下：3459 替换方案在左右笛卡尔积表中新增常量字段，用于关联 12345678select a.*,b.*from(select *,1 as cro_col from table_a) across join(select *,1 as cro_col from table_b) bon a.cro_col=b.cro_col 不等值join 差异差异点1、spark 支持不等值join语法2、hive 2.2.0版本之前不支持不等值语法，2.2.0及以后支持不等值join语法50293、maxcomputer不支持不等值语法5161 举例测试sql 12345678910111213141516171819202122232425with table_a as (select 1 as id_a,&#x27;testa&#x27; as value_a union all select 4 as id_a ,&#x27;testd&#x27; as value_a),table_b as (select 3 as id_b,&#x27;testc&#x27; as value_b union all select 2 as id_b ,&#x27;testb&#x27; as value_b)select table_a.id_a,table_a.value_a,table_b.id_b,table_b.value_bfrom table_aleft join table_bon table_a.id_a &lt; table_b.id_b sql说明 :该sql准备了两张表table_a和table_b用于连接测试使用left join on语法，但是关联关系使用的是 &lt; 不等值关联符号 maxcomputer运行结果8387maxcomputer会报异常： FAILED: ODPS-0130071:[15,4] Semantic analysis exception - expect equality expression (i.e., only use ‘&#x3D;’ and ‘AND’) for join condition without mapjoin hint 提示的是期望join的是等值表达式 hive1.2.1运行结果8655 hive会报错： Error while compiling statement: FAILED: SemanticException [Error 10017]: line 15:3 Both left and right aliases encountered in JOIN ‘id_b’ 提示的是在join中遇到左右别名 不得不说，hive的错误信息有点云里雾里，其实就是不等值join造成的。 hive2.2.3运行结果8935 hive 2.2.0+版本顺利得到正确结果 spark运行结果 9030 spark2.3也顺利得到结果 替换方案针对不等值join的替换方案有两种 1、针对小表，使用mapjoin，避免join操作 2、将on的不等值关联语句放入where语句中 由于mapjoin避免shuffle，性能较好，再可以的情况下，优先使用方案1 1、针对小表，使用mapjoin，避免join操作maxcomputer中的mapjoin hint语法为： &#x2F;*+ mapjoin() *&#x2F; ，详情请查看mapjoin hint 12345678910111213141516with table_a as (select 1 as id_a,&#x27;testa&#x27; as value_a),table_b as (select 2 as id_b,&#x27;testb&#x27; as value_b)select /*+ mapjoin(table_b) */table_a.id_a,table_a.value_a,table_b.id_b,table_b.value_bfrom table_aleft join table_bon table_a.id_a&lt;table_b.id_b 可以看到，使用mapjoin hint语法后，sql在maxcomputer中运行正确，顺利拿到了预期结果11513 2、将on的不等值关联语句放入where语句中inner join 比较简单 12345678910111213141516171819202122232425262728293031with table_a as (select 1 as id_a,&#x27;testa&#x27; as value_a,1 as join_col union all select 4 as id_a ,&#x27;testd&#x27; as value_a ,1 as join_col),table_b as (select 2 as id_b,&#x27;testb&#x27; as value_b,1 as join_col union all select 3 as id_b ,&#x27;testc&#x27; as value_b ,1 as join_col)selecttable_a.id_a,table_a.value_a,table_b.id_b,table_b.value_bfrom table_ainner join table_bon table_a.join_col=table_b.join_colwhere table_a.id_a&lt;table_b.id_b 可以看到，将&lt;判断语句放入where后，sql在maxcomputer运行正确，顺利拿到了预期结果15481 left join 比较复杂，建议使用map hint，实在没办法在使用此方案 123456789101112131415161718192021222324252627282930313233343536373839404142with table_a as (select 1 as id_a,&#x27;testa&#x27; as value_a,1 as join_col union all select 4 as id_a ,&#x27;testd&#x27; as value_a ,1 as join_col),table_b as (select 2 as id_b,&#x27;testb&#x27; as value_b,1 as join_col union all select 3 as id_b ,&#x27;testc&#x27; as value_b ,1 as join_col)-- 能关联上的部分,join_part as (selecttable_a.id_a,table_a.value_a,table_b.id_b,table_b.value_bfrom table_ainner join table_bon table_a.join_col=table_b.join_colwhere table_a.id_a&lt;table_b.id_b)-- 以自己为主表，left join能关联上的部分，实现 left join不等值效果select table_a.id_a,table_a.value_a,join_part.id_b,join_part.value_bfrom table_aleft join join_parton table_a.id_a=join_part.id_a 可以看到，将&lt;判断语句放入where后，sql在maxcomputer运行正确，顺利拿到了预期结果20590 array_contains 差异差异点spark的array_contains支持类型的隐式转换hive和maxcomputer array_contains不支持，只支持同类型使用 举例测试sql 1select array_contains(split(&quot;1,2,3,4&quot;,&quot;,&quot;),1) sql说明该sql首先使用split一个字符串获取一个array对象用于测试，之后使用array_contains函数进行判断split后的array对象为一个string数组，而判断被包含的数字【1】为一个int 对象 maxcomputer运行结果21270maxcomputer会报异常： FAILED: ODPS-0130071:[1,44] Semantic analysis exception - invalid type INT of argument 2 for function array_contains, expect STRING, implicit conversion is not allowed 提示的是array_contains第二个参数期望的是string，但是传入的是int，隐式类型转换不支持 hive运行结果21581 hive会报错： Error while compiling statement: FAILED: SemanticException [Error 10016]: line 1:43 Argument type mismatch ‘1’: “string” expected at function ARRAY_CONTAINS, but “int” is found 提示的是array_contains函数期望的是string，但是传入的是int，类型不匹配 spark运行结果 21888 spark能顺利产出结果，结果为true，那么为什么spark可以成功呢？ 大概率是spark智能的将1从int转换为了string类型，使得类型得以匹配，通过explain查看物理执行计划来验证 22046 在上图标红的地方可以看到，spark在物理执行计划层面，将int的1隐式的转换为了string类型，验证了我们一开始的猜想。 替换方案既然知道了在hive和maxcomputer中是类型不匹配导致的array_contains函数报错，那么只需要显示的将类型进行转换即可 1select array_contains(split(&quot;1,2,3,4&quot;,&quot;,&quot;),cast(1 as string)) 字段类型转换 ARRAY&lt;&gt; to STRING差异点spark的array_contains支持类型的隐式转换 hive和maxcomputer array_contains不支持，只支持同类型使用 举例测试sql 1select cast(array(1, 2, 3, 4) as string) as array_to_string; maxcompute运行结果 23397 maxcompute报异常：FAILED: ODPS-0130141:[1,8] Illegal implicit type cast - cannot cast from ARRAY to STRING 提示的是 ARRAY&lt;&gt;类型字段 不能强制转换为 STRING 类型 hive运行结果 23614 hive报异常：SQL语义错误: Error while compiling statement: FAILED: ClassCastException org.apache.hadoop.hive.serde2.typeinfo.ListTypeInfo cannot be cast to org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo 提示的是不同类型不能强转 spark运行结果 23905 spark能顺利产出结果 替换方案使用 array_join函数 将array的元素拼接成字符串，再在首尾加上 ‘[ ‘ 和 ‘]’ 字符可以还原spark上的运行结果 1select concat(&#x27;[&#x27;,array_join(array(1, 2, 3, 4),&#x27;,&#x27;),&#x27;]&#x27;) as array_to_string; 24798 📢注意macxcompute的array_join函数默认会忽略null元素，可在array_join函数中设置 nullreplacement 参数替代NULL元素2494124997 日期格式to_date(‘xxx’,’yyyyMMddHHmmss’)差异点hive语法中，to_date函数用法为：to_date(string timestamp)，返回DATE类型，格式为 yyyy-mm-dd ，仅有一个参数，支持用format格式解析 spark语法中，to_date函数用法为：to_date(date_str[, fmt]) ，返回DATE类型，格式为 yyyy-mm-dd ，支持用format格式解析日期 maxcompute语法中，to_date函数用法为：to_date(string , string )，返回DATETIME类型，格式为 yyyy-mm-dd hh:mi:ss ，支持用format格式解析日期 📢这里要注意的是，虽然spark和maxcompute中，to_date函数都支持用format格式解析日期，format格式是有差异的，主要表现在 分钟 位的格式 spark的format格式：yyyy为4位数的年，MM为2位数的月，dd为2位数的日，HH为24小时制的时，mm为2位数的分钟，ss为2位数的秒，ff3为3位精度毫秒maxcompute的format格式：yyyy为4位数的年，mm为2位数的月，dd为2位数的日，hh为24小时制的时，mi为2位数的分钟，ss为2位数的秒，ff3为3位精度毫秒 举例测试sql 1select to_date(&#x27;20221118123456&#x27;,&#x27;yyyyMMddHHmmss&#x27;),to_date(&#x27;2022-11-18 12:34:56&#x27;,&#x27;yyyy-MM-dd HH:mm:ss&#x27;); maxcompute运行结果26234 maxcompute报异常： FAILED: ODPS-0121095:Invalid arguments - format string has second part, but doesn’t have minute part : yyyyMMddHHmmss hive运行结果26438 hive报异常： Arguments length mismatch ‘’yyyyMMddhhmmss’’: to_date() requires 1 argument, got 2 提示的是to_date函数仅有1个参数 去掉format参数后的运行结果为：26628 从结果可以看到，to_date不能解析 yyyyMMddhhmmss 和 yyyyMMdd 格式 spark运行结果26749 spark能顺利产出结果 替换方案format格式修改：yyyy为4位数的年，mm为2位数的月，dd为2位数的日，hh为24小时制的时，mi为2位数的分钟，ss为2位数的秒，ff3为3位精度毫秒 修改后的能正常产出结果：26925 另，常见使用to_date报错sql为 date_format(date_add(to_date(pay_time,’yyyyMMddHHmmss’),2),’yyyyMMddHHmmss’) ，解读sql的作用是对 pay_time 加 2 天，建议用 UDF 修改这段sql为 yt_date_add(pay_time,2)，修改后简洁明了 date日期函数差异点spark和hive的date函数支持将标准的日期string转换为date类型 maxcomputer date函数只支持标准的日期string，带时分秒的时间string不支持 举例测试sql 1select date(&#x27;2022-12-21&#x27;),date(&#x27;2022-12-21 01:22:01&#x27;); maxcompute运行结果27758 maxcomputer对标准的日期string【2022-12-21】转换正确 但是对带时分秒的string转为错误，直接为null hive运行结果27897 结果符合预期 spark运行结果27976 spark能顺利产出结果 替换方案如果是为了格式转换，使用自定义 yt_date_format 函数 如果是为了获取date类型，使用 to_date函数 12select yt_date_format(&#x27;2022-12-21 01:22:01&#x27;,&#x27;yyyy-MM-dd&#x27;),to_date(&#x27;2022-12-21 01:22:01&#x27;); 28656 from_unixtime函数差异点spark和hive的from_unixtime函数将时间戳转换成格式化string类型，当时间戳为负数时，正常转换 maxcomputer from_unixtime函数转换负数时间戳时，存在时间便宜 举例测试sqlselect ‘1018-10-15 00:00:00’ – yyyyMMddHHmmss 时间戳,unix_timestamp(‘1018-10-15 00:00:00’) –时间戳,from_unixtime(unix_timestamp(‘1018-10-15 00:00:00’),’yyyyMMddHHmmss’) –转换格式 maxcompute运行结果29054 可以看到，原先日期为 ‘1018-10-15 00:00:00’,转换成yyyyMMddHHmmss格式原本期望为 10181015000000 但是实际结果为10181008235417,和预期不符合 hive运行结果29229 hive结果符合预期 spark运行结果29312 spark产出结果正确 替换方案使用自定义 yt_date_format 函数 123select &#x27;1018-10-15 00:00:00&#x27; -- yyyyMMddHHmmss 时间戳,unix_timestamp(&#x27;1018-10-15 00:00:00&#x27;) --时间戳,yt_date_format(&#x27;1018-10-15 00:00:00&#x27;,&#x27;yyyyMMddHHmmss&#x27;) --转换格式 30206使用自定义udf后正确 concat_ws差异差异点spark的concat_ws会支持类型的隐式转换 hive和maxcomputer concat_ws不支持，只支持同类型使用 举例测试sql 1select concat_ws(&quot;,&quot;,array(1,2,3)) maxcompute运行结果30829 报错提示数据类型不对，concat_ws只能处理ARRAY数据类型，而sql中是ARRAY数据类型，官方文档 中有详细说明31054 hive运行结果31125 报错提示数据类型不对，与maxcompute一个意思，concat_ws传入数组必须是Array类型 spark运行结果 31254 spark执行结果符合预期 替换方案使用阿里云提供的array_join函数 1select array_join(array(1,2,3),&quot;,&quot;); 31789","categories":[{"name":"SQL","slug":"SQL","permalink":"https://llye-hub.github.io/categories/SQL/"}],"tags":[{"name":"Maxcompute","slug":"Maxcompute","permalink":"https://llye-hub.github.io/tags/Maxcompute/"}]},{"title":"mysql和hiveSQL的语法差别","slug":"mysql和hiveSQL的语法差别","date":"2023-02-17T08:06:16.000Z","updated":"2023-03-02T08:18:42.316Z","comments":true,"path":"posts/e912f2da.html","link":"","permalink":"https://llye-hub.github.io/posts/e912f2da.html","excerpt":"","text":"最近在牛客网上刷sql题，但编程语言居然只支持mysql，一些函数用法上与平时工作使用的hiveSQL有较大差别，所以在这篇博客中整理一下两种语法的函数使用差异 mysql内置函数 hive内置函数 日期、时间函数 函数用途 mysql函数 mysql用法 hive函数 hiveSQL用法 日期、时间格式化 date_format date_format(‘2008-08-08 22:23:01’, ‘%Y%m%d%H%i%s’) date_format date_format(‘2008-08-08 22:23:01’, ‘yyyyMMddHHmmss’) 日期、时间加 date_add date_add(‘2008-08-08 22:23:01’,interval 1 day&#x2F;hour&#x2F;minute&#x2F;second&#x2F;microsecond&#x2F;week&#x2F;month&#x2F;quarter&#x2F;year)，返回dateTime格式 date_add date_add(‘2008-08-08 22:23:01’,1)，只加days，返回date格式 日期、时间减 date_sub date_sub(‘2008-08-08 22:23:01’,interval 1 day&#x2F;hour&#x2F;minute&#x2F;second&#x2F;microsecond&#x2F;week&#x2F;month&#x2F;quarter&#x2F;year)，返回dateTime格式 date_sub date_sub(‘2008-08-08 22:23:01’,1)，只加days，返回date格式 日期相差 datediff datediff(‘2008-08-08 22:22:00’,’2008-08-07 22:23:00’) datediff datediff(‘2008-08-08 22:22:00’,’2008-08-07 22:23:00’)","categories":[{"name":"SQL","slug":"SQL","permalink":"https://llye-hub.github.io/categories/SQL/"}],"tags":[]},{"title":"排序算法","slug":"排序算法","date":"2023-02-17T05:46:19.000Z","updated":"2023-06-28T02:03:26.242Z","comments":true,"path":"posts/735e5788.html","link":"","permalink":"https://llye-hub.github.io/posts/735e5788.html","excerpt":"","text":"整理一些数据结构中常用的排序算法原理和java实现 常见排序算法原理简介： 冒泡排序（Bubble Sort）：从头到尾不断交换相邻逆序的元素，直到没有交换为止。时间复杂度为 O(n^2)。 选择排序（Selection Sort）：每次选择未排序部分中的最小元素，放到已排序部分的末尾。时间复杂度为 O(n^2)。 插入排序（Insertion Sort）：从未排序部分中取出元素，将其插入到已排序部分的合适位置，时间复杂度为 O(n^2)。 快速排序（Quick Sort）：选择一个元素作为基准，将小于基准的元素放到左边，大于基准的元素放到右边，再对左右两部分分别进行快速排序。时间复杂度为 O(nlogn)。 归并排序（Merge Sort）：将数组分成两个部分，对每个部分进行归并排序，然后将两个有序的部分合并成一个有序的数组。时间复杂度为 O(nlogn)。 堆排序（Heap Sort）：将待排序的序列建成一个大根堆，然后依次取出堆顶元素，再对剩余的元素进行调整，直到整个序列有序。时间复杂度为 O(nlogn)。 快速排序B站视频讲解 算法步骤 从数组中选择一个元素t作为基准（pivot） 将小于t的值放它前面，大于t的值放它后面（相同的数可以到任一边），在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作 递归地（recursive）把小于t的子数列和大于t的子数列排序 算法时间复杂度为 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 java实现123456789101112131415161718192021222324252627282930313233public class QuickSort &#123; public static void quickSort(int[] arr, int left, int right) &#123; if (left &gt;= right) &#123; return; &#125; int pivot = arr[left]; // 基准值 int i = left, j = right; // 左右指针 // 左右指针交替遍历，直到重合 while (i &lt; j) &#123; // 从右到左遍历，直到小于基准值 while (i &lt; j &amp;&amp; arr[j] &gt; pivot) &#123; j--; &#125; arr[i] = arr[j]; // 从左到右遍历，直到大于基准值 while (i &lt; j &amp;&amp; arr[i] &lt; pivot) &#123; i++; &#125; arr[j] = arr[i]; &#125; // 左右指针重合处即为当前基准值位置，且保证左边所有数都小于基准值，右边所有数都大于基准值 arr[i] = pivot; // 递归，分别对左、右子数组排序 quickSort(arr, left, i - 1); quickSort(arr, i + 1, right); &#125; public static void main(String[] args) &#123; int[] arr = &#123;3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5&#125;; quickSort(arr, 0, arr.length - 1); System.out.println(Arrays.toString(arr)); &#125;&#125;","categories":[{"name":"练习笔记","slug":"练习笔记","permalink":"https://llye-hub.github.io/categories/%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"解题思路之动态规划","slug":"数据结构与算法笔记/解题思路之动态规划","date":"2023-02-16T09:11:19.000Z","updated":"2023-06-28T03:04:55.824Z","comments":true,"path":"posts/d6cdfd6a.html","link":"","permalink":"https://llye-hub.github.io/posts/d6cdfd6a.html","excerpt":"","text":"什么是动态规划动态规划，英文：Dynamic Programming，简称DP。简单理解，动态规划的每一个状态都能由上一个状态推导而来 解题步骤以斐波那契数列为例，动态规划问题可以拆解为五步曲： 1、确定dp数组和下标含义：第n个斐波那契数是dp[n] 2、确定递推公式（也可叫状态转移方程）：dp[n] = dp[n-1] + dp[n-2] 3、dp数组初始化：dp[0] = 0; dp[1] = 1 4、确定遍历顺序：从前到后遍历，dp[n]依赖dp[n-1]和dp[n-2] 5、举例推导dp数组：当n=10时，dp数组应该为：0 1 1 2 3 5 8 13 21 34 55 背包问题334 01背包解法详细讲解 有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。举例：n&#x3D;3, w&#x3D;4, weight&#x3D;[1,3,4], value&#x3D;[15,20,30] 暴力解法： 利用回溯算法枚举所有组合，每个物品有取和不取两个状态，时间复杂度是O(2^n)。 解法一：二维dp数组解题五步曲： 1、dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少 2、不放物品i时，dp[i][j] &#x3D; dp[i-1][j]； 放物品i时，dp[i][j] &#x3D; dp[i - 1][j - weight[i]] + value[i]，dp[i - 1][j - weight[i]]为背包容量为j - weight[i]的时候不放物品i的最大价值 3、初始化背包容量j=0时，最大价值一定为0，dp[i][0]=0初始化i=0时各容量下背包能装入的最大价值，当j&lt;weight[0]时，dp[0][j]&#x3D;0；当j&gt;=weight[0]时，dp[0][j]&#x3D;value[0]&#96; 4、双层遍历背包和物品，顺序没有关系，先遍历物品易理解 5、举例推导：n=3, w=4, weight=[1,3,4], value=[15,20,30] 1232 java代码实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class BagProblem &#123; public static void main(String[] args) &#123; int[] weight = &#123;1,3,4&#125;; int[] value = &#123;15,20,30&#125;; int bagSize = 4; testWeightBagProblem(weight,value,bagSize); &#125; /** * 动态规划获得结果 * @param weight 物品的重量 * @param value 物品的价值 * @param bagSize 背包的容量 */ public static void testWeightBagProblem(int[] weight, int[] value, int bagSize)&#123; // 创建dp数组 int goods = weight.length; // 获取物品的数量 int[][] dp = new int[goods][bagSize + 1]; // 初始化dp数组 // 创建数组后，其中默认的值就是0 for (int j = weight[0]; j &lt;= bagSize; j++) &#123; dp[0][j] = value[0]; &#125; // 填充dp数组 for (int i = 1; i &lt; weight.length; i++) &#123; for (int j = 1; j &lt;= bagSize; j++) &#123; if (j &lt; weight[i]) &#123; /** * 当前背包的容量都没有当前物品i大的时候，是不放物品i的 * 那么前i-1个物品能放下的最大价值就是当前情况的最大价值 */ dp[i][j] = dp[i-1][j]; &#125; else &#123; /** * 当前背包的容量可以放下物品i * 那么此时分两种情况： * 1、不放物品i * 2、放物品i * 比较这两种情况下，哪种背包中物品的最大价值最大 */ dp[i][j] = Math.max(dp[i-1][j] , dp[i-1][j-weight[i]] + value[i]); &#125; &#125; &#125; // 打印dp数组 for (int i = 0; i &lt; goods; i++) &#123; for (int j = 0; j &lt;= bagSize; j++) &#123; System.out.print(dp[i][j] + &quot;\\t&quot;); &#125; System.out.println(&quot;\\n&quot;); &#125; &#125;&#125; ###解法二：一维dp数组 在使用二维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]) 可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]) 与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。 解题五步曲： 1、dp[j]表示容量为j的背包能装下的最大价值 2、不放物品i时，dp[j] = dp[j]；放物品i时，dp[j] = dp[j - weight[i]] + value[i]为背包容量为j - weight[i]的时候不放物品i的最大价值所以dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) 3、初始化背包容量j=0时，dp[j]=0 4、双层遍历物品和背包，背包倒序遍历，因为当前dp[j]来自上一层左侧的值，如果正序遍历，左侧的值都被当前层覆盖了 5、举例推导：n=3, w=4, weight=[1,3,4], value=[15,20,30] 9689 java代码实现： 12345678910111213141516171819202122public static void main(String[] args) &#123; int[] weight = &#123;1, 3, 4&#125;; int[] value = &#123;15, 20, 30&#125;; int bagWight = 4; testWeightBagProblem(weight, value, bagWight);&#125;public static void testWeightBagProblem(int[] weight, int[] value, int bagWeight)&#123; int wLen = weight.length; //定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值 int[] dp = new int[bagWeight + 1]; //遍历顺序：先遍历物品，再遍历背包容量 for (int i = 0; i &lt; wLen; i++)&#123; for (int j = bagWeight; j &gt;= weight[i]; j--)&#123; dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]); &#125; &#125; //打印dp数组 for (int j = 0; j &lt;= bagWeight; j++)&#123; System.out.print(dp[j] + &quot; &quot;); &#125;&#125; 完全背包解法详细讲解 有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。举例：n&#x3D;3, w&#x3D;4, weight&#x3D;[1,3,4], value&#x3D;[15,20,30] 01背包和完全背包唯一不同就是体现在遍历顺序上 。01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。而完全背包的物品是可以添加多次的，所以要从小到大去遍历。可以借由二维dp数组解法理解，在01背包中当前状态继承自上层左侧，在完全背包中当前状态继承自本层左侧，所以压缩成一维数组解法，01背包内嵌的循环倒序遍历，完全背包内嵌的循环是正序遍历。 01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！ 二维dp数组解题五步曲： 1、dp[i][j] 表示从下标为[0-i]的物品里可重复任意取，放进容量为j的背包，价值总和最大是多少 2、不放物品i时，dp[i][j] &#x3D; dp[i-1][j]；放物品i时，dp[i][j] &#x3D; dp[i][j - weight[i]] + value[i]，dp[i][j - weight[i]]为背包容量为j - weight[i]的时候，在[0-i]的物品里可重复任意取的最大价值 3、初始化背包容量j=0时，最大价值一定为0，dp[i][0]=0初始化i=0时各容量下背包能装入的最大价值，当j&lt;weight[0]时，dp[0][j]&#x3D;0；当j&gt;=weight[0]时，dp[0][j]&#x3D;dp[0][j-weight[0]]+value[0]&#96; 4、双层遍历背包和物品，顺序没有关系，先遍历物品易理解 5、举例推导：n=3, w=4, weight=[1,3,4], value=[15,20,30]。（示意图忽略） java代码实现： 12345678910111213// 01背包核心代码for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); &#125;&#125;// 完全背包核心代码for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品 for(int j = weight[i]; j &lt;= bagWeight ; j++) &#123; // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334// 完全背包完整代码：一维dp数组解法//先遍历物品，再遍历背包private static void testCompletePack() &#123; int[] weight = &#123;1, 3, 4&#125;; int[] value = &#123;15, 20, 30&#125;; int bagWeight = 4; int[] dp = new int[bagWeight + 1]; for (int i = 0; i &lt; weight.length; i++) &#123; // 遍历物品 for (int j = weight[i]; j &lt;= bagWeight; j++) &#123; // 遍历背包容量 dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]); &#125; &#125; for (int maxValue : dp) &#123; System.out.println(maxValue + &quot; &quot;); &#125; &#125;//先遍历背包，再遍历物品private static void testCompletePackAnotherWay() &#123; int[] weight = &#123;1, 3, 4&#125;; int[] value = &#123;15, 20, 30&#125;; int bagWeight = 4; int[] dp = new int[bagWeight + 1]; for (int i = 1; i &lt;= bagWeight; i++) &#123; // 遍历背包容量 for (int j = 0; j &lt; weight.length; j++) &#123; // 遍历物品 if (i - weight[j] &gt;= 0) &#123; dp[i] = Math.max(dp[i], dp[i - weight[j]] + value[j]); &#125; &#125; &#125; for (int maxValue : dp) &#123; System.out.println(maxValue + &quot; &quot;); &#125;&#125; 参考资料代码随想录之动态规划","categories":[{"name":"练习笔记","slug":"练习笔记","permalink":"https://llye-hub.github.io/categories/%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://llye-hub.github.io/tags/LeetCode/"}]},{"title":"hiveSQL之生成连续数字","slug":"SQL/hiveSQL之生成连续数字","date":"2023-02-08T08:03:36.000Z","updated":"2023-02-20T08:51:28.974Z","comments":true,"path":"posts/3ce3d37f.html","link":"","permalink":"https://llye-hub.github.io/posts/3ce3d37f.html","excerpt":"","text":"sql要求生成100以内的全部整数 涉及udtf函数posexplode(ARRAY&lt;T&gt; a) 官方说明 Return: Returns a row-set with two columns (pos int,val T), one row for each element from the array. Description: posexplode() is similar to explode but instead of just returning the elements of the array it returns the element as well as its position in the original array. 用法示例：有如下一张表myTable (array&lt;int&gt;)myCol [100,200,300] [400,500,600] 执行hive sql 12345678-- 造数据with myTable as ( select array(100,200,300) as myCol union all select array(300,400,500) as myCol)-- 查询sqlSELECT posexplode(myCol) AS (pos, val) FROM myTable 得到结果为： (int)pos (int)val 0 100 1 200 2 300 0 400 1 500 2 600 sql实现借助posexplode返回的pos即可实现 12345select posexplode(split(space(99), &#x27; &#x27;)) as (pos, val)-- 返回的pos字段即为[0,99]区间的100个整数-- 或者下面这种写法select posexplode(split(repeat(&#x27;,&#x27;,99), &#x27;,&#x27;)) as (pos, val) 实例场景数据重复扩容10倍12345678910-- 造数据with myTable as ( select &#x27;张三&#x27; as name union all select &#x27;李四&#x27; as name)-- 将myTable的每行数据重复复制为5行SELECT name ,posexplode(split(space(4), &#x27; &#x27;)) AS (pos, val) FROM myTable 得到结果为： name pos val 张三 0 张三 1 张三 2 张三 3 张三 4 李四 0 李四 1 李四 2 李四 3 李四 4 生成指定范围内的连续日期123456789with subquery as ( select split(space(datediff(&#x27;2023-1-31&#x27;,&#x27;2022-11-30&#x27;)), &#x27; &#x27;) as x) select date_add(&#x27;2022-11-30&#x27;, pos) as new_datefrom subquery t lateral view posexplode(x) pe as pos, val","categories":[{"name":"SQL","slug":"SQL","permalink":"https://llye-hub.github.io/categories/SQL/"}],"tags":[{"name":"SQL高级语法","slug":"SQL高级语法","permalink":"https://llye-hub.github.io/tags/SQL%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}]},{"title":"SparkSQL之conf参数","slug":"SQL/SparkSQL之conf参数","date":"2023-02-03T08:15:46.000Z","updated":"2023-02-20T08:51:28.966Z","comments":true,"path":"posts/5e220c44.html","link":"","permalink":"https://llye-hub.github.io/posts/5e220c44.html","excerpt":"","text":"官方说明传送门资源参数num-executors 参数说明：该参数用于设置Spark作业总共要用多少个Executor进程来执行。Driver在向YARN集群管理器申请资源时，YARN集群管理器会尽可能按照你的设置来在集群的各个工作节点上，启动相应数量的Executor进程。这个参数非常之重要，如果不设置的话，默认只会给你启动少量的Executor进程，此时你的Spark作业的运行速度是非常慢的。 参数调优建议：每个Spark作业的运行一般设置50~100个左右的Executor进程比较合适，设置太少或太多的Executor进程都不好。设置的太少，无法充分利用集群资源；设置的太多的话，大部分队列可能无法给予充分的资源。 executor-memory 参数说明：该参数用于设置每个Executor进程的内存。Executor内存的大小，很多时候直接决定了Spark作业的性能，而且跟常见的JVM OOM异常，也有直接的关联。 参数调优建议：每个Executor进程的内存设置4G~8G较为合适。但是这只是一个参考值，具体的设置还是得根据不同部门的资源队列来定。可以看看自己团队的资源队列的最大内存限制是多少，num-executors乘以executor-memory，是不能超过队列的最大内存量的。此外，如果你是跟团队里其他人共享这个资源队列，那么申请的内存量最好不要超过资源队列最大总内存的1&#x2F;3~1&#x2F;2，避免你自己的Spark作业占用了队列所有的资源，导致别的同学的作业无法运行。 ##executor-cores 参数说明：该参数用于设置每个Executor进程的CPU core数量。这个参数决定了每个Executor进程并行执行task线程的能力。因为每个CPU core同一时间只能执行一个task线程，因此每个Executor进程的CPU core数量越多，越能够快速地执行完分配给自己的所有task线程。 参数调优建议：Executor的CPU core数量设置为2~4个较为合适。同样得根据不同部门的资源队列来定，可以看看自己的资源队列的最大CPU core限制是多少，再依据设置的Executor数量，来决定每个Executor进程可以分配到几个CPU core。同样建议，如果是跟他人共享这个队列，那么num-executors * executor-cores不要超过队列总CPU core的1&#x2F;3~1&#x2F;2左右比较合适，也是避免影响其他同学的作业运行。 driver-memory 参数说明：该参数用于设置Driver进程的内存。 参数调优建议：Driver的内存通常来说不设置，或者设置1G左右应该就够了。唯一需要注意的一点是，如果需要使用collect算子将RDD的数据全部拉取到Driver上进行处理，那么必须确保Driver的内存足够大，否则会出现OOM内存溢出的问题。 spark.default.parallelism 参数说明：该参数用于设置每个stage的默认task数量。这个参数极为重要，如果不设置可能会直接影响你的Spark作业性能。 参数调优建议：Spark作业的默认task数量为500~1000个较为合适。很多同学常犯的一个错误就是不去设置这个参数，那么此时就会导致Spark自己根据底层HDFS的block数量来设置task的数量，默认是一个HDFS block对应一个task。通常来说，Spark默认设置的数量是偏少的（比如就几十个task），如果task数量偏少的话，就会导致你前面设置好的Executor的参数都前功尽弃。试想一下，无论你的Executor进程有多少个，内存和CPU有多大，但是task只有1个或者10个，那么90%的Executor进程可能根本就没有task执行，也就是白白浪费了资源！因此Spark官网建议的设置原则是，设置该参数为num-executors * executor-cores的2~3倍较为合适，比如Executor的总CPU core数量为300个，那么设置1000个task是可以的，此时可以充分地利用Spark集群的资源。 spark.storage.memoryFraction 参数说明：该参数用于设置RDD持久化数据在Executor内存中能占的比例，默认是0.6。也就是说，默认Executor 60%的内存，可以用来保存持久化的RDD数据。根据你选择的不同的持久化策略，如果内存不够时，可能数据就不会持久化，或者数据会写入磁盘。 参数调优建议：如果Spark作业中，有较多的RDD持久化操作，该参数的值可以适当提高一些，保证持久化的数据能够容纳在内存中。避免内存不够缓存所有的数据，导致数据只能写入磁盘中，降低了性能。但是如果Spark作业中的shuffle类操作比较多，而持久化操作比较少，那么这个参数的值适当降低一些比较合适。此外，如果发现作业由于频繁的gc导致运行缓慢（通过spark web ui可以观察到作业的gc耗时），意味着task执行用户代码的内存不够用，那么同样建议调低这个参数的值。 spark.shuffle.memoryFraction 参数说明：该参数用于设置shuffle过程中一个task拉取到上个stage的task的输出后，进行聚合操作时能够使用的Executor内存的比例，默认是0.2。也就是说，Executor默认只有20%的内存用来进行该操作。shuffle操作在进行聚合时，如果发现使用的内存超出了这个20%的限制，那么多余的数据就会溢写到磁盘文件中去，此时就会极大地降低性能。 参数调优建议：如果Spark作业中的RDD持久化操作较少，shuffle操作较多时，建议降低持久化操作的内存占比，提高shuffle操作的内存占比比例，避免shuffle过程中数据过多时内存不够用，必须溢写到磁盘上，降低了性能。此外，如果发现作业由于频繁的gc导致运行缓慢，意味着task执行用户代码的内存不够用，那么同样建议调低这个参数的值。 广播相关spark.sql.broadcastTimeoutspark.kryoserializer.buffer.max&#x3D;128Mspark.sql.shuffle.partitions&#x3D;1000spark.sql.orc.compression.codec&#x3D;zlibspark.sql.files.maxPartitionBytes&#x3D;65536","categories":[{"name":"SQL","slug":"SQL","permalink":"https://llye-hub.github.io/categories/SQL/"}],"tags":[]},{"title":"hiveSQL之set参数","slug":"SQL/hiveSQL之set参数","date":"2023-02-03T08:14:57.000Z","updated":"2023-02-20T08:51:28.979Z","comments":true,"path":"posts/4547a6e2.html","link":"","permalink":"https://llye-hub.github.io/posts/4547a6e2.html","excerpt":"","text":"官方传送门hive.merge.mapfilesDefault Value: truemap-only任务结束时合并小文件 hive.merge.mapredfilesDefault Value: truemap-reduce任务结束时合并小文件 hive.optimize.cte.materialize.threshold默认情况下是-1（关闭）；当开启（大于0），比如设置为2，则如果with..as语句被引用2次及以上时，会把with..as语句生成的table物化，从而做到with..as语句只执行一次，来提高效率","categories":[{"name":"SQL","slug":"SQL","permalink":"https://llye-hub.github.io/categories/SQL/"}],"tags":[]},{"title":"hiveSQL命令之alter partition","slug":"hiveSQL命令之alter-partition","date":"2023-02-02T06:02:26.000Z","updated":"2023-02-21T06:18:34.677Z","comments":true,"path":"posts/8a94c1da.html","link":"","permalink":"https://llye-hub.github.io/posts/8a94c1da.html","excerpt":"","text":"msck repair table https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-ExchangePartition","categories":[{"name":"SQL","slug":"SQL","permalink":"https://llye-hub.github.io/categories/SQL/"}],"tags":[{"name":"改分区","slug":"改分区","permalink":"https://llye-hub.github.io/tags/%E6%94%B9%E5%88%86%E5%8C%BA/"}]},{"title":"hadoop命令之distcp分布式拷贝","slug":"hadoop/hadoop命令之distcp分布式拷贝","date":"2023-02-01T02:06:03.000Z","updated":"2023-02-20T08:58:42.949Z","comments":true,"path":"posts/bcc5bdf2.html","link":"","permalink":"https://llye-hub.github.io/posts/bcc5bdf2.html","excerpt":"","text":"distcp用途DistCp（分布式拷贝）是用于大规模集群内部和集群之间拷贝的工具。使用Map&#x2F;Reduce实现文件分发，错误处理和恢复，以及报告生成。DistCp将文件和目录的列表作为map任务的输入，每个任务会完成源列表中部分文件的拷贝。 distcp用法命令行中可以指定多个源目录 12# hadoop distcp source_dir1 [source_dir2 source_dir3……] target_dir 集群内拷贝 12# hadoop distcp [hdfs://nn:8020]/db/table_a/partition=1 [hdfs://nn:8020]/db/table_b/partition=1 不同集群间拷贝，DistCp必须运行在目标端集群上 12# hadoop distcp hdfs://nn1:8020/db/table_a/partition=1 hdfs://nn2:8020/db/table_b/partition=1 常用参数选项-overwrite源文件覆盖同名目标文件 -update拷贝目标目录下不存在而源目录下存在的文件，当文件大小不一致时，源文件覆盖同名目标文件 -delete删除目标目录下存在，但源目录下不存在的文件，需要配合-update或-overwrite使用 -p[rbugpcaxt]控制是否保留源文件的属性，-p默认全部保留，常用的为-pbugp。修改次数不会被保留。并且当指定 -update 时，更新的状态不会 被同步，除非文件大小不同（比如文件被重新创建）。 标识 含义 备注 r replication number 文件副本数 b block size 文件块大小 u user 用户 g group 组 p permission 文件权限 c checksum-type 校验和类型 a acl x xattr t timestamp 时间戳 -m控制拷贝时的map任务最大个数如果没使用-m选项，DistCp会尝试在调度工作时指定map数目&#x3D;min(total_bytes&#x2F;bytes.per.map,20*num_task_trackers)， 其中bytes.per.map默认是256MB。 应用实例表结构一致的两表互相拷贝数据1234567891011121314151617181920212223242526272829303132333435#********************************************************************************# ** 功能描述：通过hdfs文件路径拷贝的方式，实现表结构完全相同的表互相拷贝数据#********************************************************************************# 指定源路径、目标路径source_dir=/db/table_a/partition=1target_dir=/db/table_b/partition=1db_name=db_atarget_tbl_name=db_a.table_b# 判断源路径是否存在，不存在则返回hadoop fs -test -e $source_dirif [ $? -ne 0 ];then echo &quot;源路径$source_dir不存在&quot; exit 1fi# 判断目标路径是否存在，不存在则创建hadoop fs -test -e $target_dirif [ $? -ne 0 ];then hadoop fs -mkdir $target_dir echo &quot;目标路径$target_dir不存在，创建成功&quot;fi# 开始拷贝echo &quot;开始hdfs文件拷贝，source_dir=$source_dir，target_dir=$target_dir&quot;hadoop distcp -overwrite -delete -pbugp $source_dir $target_dirif [ $? -eq 0 ];then echo &quot;hdfs文件拷贝成功&quot;else echo &quot;hdfs文件拷贝失败&quot; exit -1fi# 刷新目标表的metastore信息hive -database $db_name -v -e &quot;msck repair table $target_tbl_name;&quot;if [ $? -eq 0 ];then echo &quot;$target_tbl_name表的metastore信息刷新成功&quot; exit 0fi 参考资料DistCp使用指南Hadoop中文网：DistCp","categories":[{"name":"hadoop","slug":"hadoop","permalink":"https://llye-hub.github.io/categories/hadoop/"}],"tags":[{"name":"hadoop命令","slug":"hadoop命令","permalink":"https://llye-hub.github.io/tags/hadoop%E5%91%BD%E4%BB%A4/"},{"name":"hdfs文件拷贝","slug":"hdfs文件拷贝","permalink":"https://llye-hub.github.io/tags/hdfs%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D/"}]},{"title":"Shell命令之set-e","slug":"Shell命令之set-e","date":"2023-01-31T09:26:54.000Z","updated":"2023-02-20T08:35:55.810Z","comments":true,"path":"posts/ba81765c.html","link":"","permalink":"https://llye-hub.github.io/posts/ba81765c.html","excerpt":"","text":"","categories":[{"name":"shell","slug":"shell","permalink":"https://llye-hub.github.io/categories/shell/"}],"tags":[{"name":"shell命令","slug":"shell命令","permalink":"https://llye-hub.github.io/tags/shell%E5%91%BD%E4%BB%A4/"}]},{"title":"hadoop基本命令","slug":"hadoop/hadoop基本命令","date":"2023-01-31T09:10:11.000Z","updated":"2023-02-20T08:35:55.810Z","comments":true,"path":"posts/b24f0feb.html","link":"","permalink":"https://llye-hub.github.io/posts/b24f0feb.html","excerpt":"","text":"hadoop fs -cphadoop fs -rm -rhadoop distcp -overwrite -delete -phadoop fs -mkdir -p","categories":[{"name":"hadoop","slug":"hadoop","permalink":"https://llye-hub.github.io/categories/hadoop/"}],"tags":[{"name":"hadoop命令","slug":"hadoop命令","permalink":"https://llye-hub.github.io/tags/hadoop%E5%91%BD%E4%BB%A4/"}]},{"title":"hive动态分区","slug":"hive/hive动态分区","date":"2023-01-30T09:01:49.000Z","updated":"2023-02-20T08:35:55.811Z","comments":true,"path":"posts/44d3528f.html","link":"","permalink":"https://llye-hub.github.io/posts/44d3528f.html","excerpt":"","text":"","categories":[{"name":"hive","slug":"hive","permalink":"https://llye-hub.github.io/categories/hive/"}],"tags":[{"name":"动态分区","slug":"动态分区","permalink":"https://llye-hub.github.io/tags/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA/"}]},{"title":"SparkSQL无法处理hive表中的空ORC文件","slug":"spark/Spark SQL无法处理hive表中的空ORC文件","date":"2022-12-16T09:56:46.000Z","updated":"2023-02-20T08:50:42.761Z","comments":true,"path":"posts/1f69e18b.html","link":"","permalink":"https://llye-hub.github.io/posts/1f69e18b.html","excerpt":"","text":"碰到了什么问题起因是在使用SparkSQL查询表时，遇到报错：java.lang.RuntimeException: serious problem at OrcInputFormat.generateSplitsInfo116172之后，换了hiveSQL执行成功，但这并不算排查成功，排查应尽可能追根究底，以后才能做到举一反三，所以基于网上资料和个人理解写了这篇博客 问题分析定位问题根据报错的java类名+方法名（OrcInputFormat.generateSplitsInfo），可以判断问题出现在读取orc文件阶段。 查看HDFS文件查看表存储路径下的文件，发现有1个空文件418 为什么会有空文件1、sparkSQL建表2、表写入数据时，sql最后做了distribute by操作，产生了空文件 sparksql读取空文件的时候，因为表是orc格式的，导致sparkSQL解析orc文件出错。但是用hive却可以正常读取。 网上搜罗的解决办法问题原因基本清晰了，就是读取空文件导致的报错，如果非得用SparkSQL执行查询语句，这里提供几种解决方案： 1、修改表存储格式为parquet这种方法是网上查询到的，但在实际数仓工作中，对于已在使用中的表来说，删表重建操作是不允许的，所以不推荐 2、参数设置：set hive.exec.orc.split.strategy=ETL既然已经定位到是空文件读取的问题，那就从文件读取层面解决。 自建集群Spark源码： 12345678910111213141516171819202122232425262728// org/apache/hadoop/hive/ql/io/orc/OrcInputFormat.javaswitch(context.splitStrategyKind) &#123; case BI: // BI strategy requested through config splitStrategy = new BISplitStrategy(context, fs, dir, children, isOriginal, deltas, covered); break; case ETL: // ETL strategy requested through config splitStrategy = new ETLSplitStrategy(context, fs, dir, children, isOriginal, deltas, covered); break; default: // HYBRID strategy if (avgFileSize &gt; context.maxSize) &#123; splitStrategy = new ETLSplitStrategy(context, fs, dir, children, isOriginal, deltas, covered); &#125; else &#123; splitStrategy = new BISplitStrategy(context, fs, dir, children, isOriginal, deltas, covered); &#125; break;&#125;// ./repository/org/spark-project/hive/hive-exec/1.2.1.spark2/hive-exec-1.2.1.spark2.jar!/org/apache/hadoop/hive/conf/HiveConf.classHIVE_ORC_SPLIT_STRATEGY(&quot;hive.exec.orc.split.strategy&quot;, &quot;HYBRID&quot;, new StringSet(new String[]&#123;&quot;HYBRID&quot;, &quot;BI&quot;, &quot;ETL&quot;&#125;), &quot;This is not a user level config. BI strategy is used when the requirement is to spend less time in split generation as opposed to query execution (split generation does not read or cache file footers). ETL strategy is used when spending little more time in split generation is acceptable (split generation reads and caches file footers). HYBRID chooses between the above strategies based on heuristics.&quot;) 也就是说，默认是HYBRID（混合模式读取，根据平均文件大小和文件个数选择ETL还是BI模式）。 BI策略以文件为粒度进行split划分 ETL策略会将文件进行切分，多个stripe组成一个split HYBRID策略为：当文件的平均大小大于hadoop最大split值（默认256 * 1024 * 1024）时使用ETL策略，否则使用BI策略。 ETLSplitStrategy和BISplitStrategy两种策略在对getSplits方法采用了不同的实现方式，BISplitStrategy在面对空文件时会出现空指针异常，ETLSplitStrategy则帮我们过滤了空文件。 123456789101112131415161718192021222324252627282930313233// org.apache.hadoop.hive.ql.io.orc.OrcInputFormat.BISplitStrategy#getSplitspublic List&lt;OrcSplit&gt; getSplits() throws IOException &#123; List&lt;OrcSplit&gt; splits = Lists.newArrayList(); for (FileStatus fileStatus : fileStatuses) &#123; String[] hosts = SHIMS .getLocationsWithOffset(fs, fileStatus) // 对空文件会返回一个空的TreeMap .firstEntry() // null .getValue() // NPE .getHosts(); OrcSplit orcSplit = new OrcSplit(fileStatus.getPath(), 0, fileStatus.getLen(), hosts, null, isOriginal, true, deltas, -1); splits.add(orcSplit); &#125; // add uncovered ACID delta splits splits.addAll(super.getSplits()); return splits;&#125;// org.apache.hadoop.hive.ql.io.orc.OrcInputFormat.ETLSplitStrategy#getSplitspublic List&lt;SplitInfo&gt; getSplits() throws IOException &#123; List&lt;SplitInfo&gt; result = Lists.newArrayList(); for (FileStatus file : files) &#123; FileInfo info = null; if (context.cacheStripeDetails) &#123; info = verifyCachedFileInfo(file); &#125; // ignore files of 0 length（此处对空文件做了过滤） if (file.getLen() &gt; 0) &#123; result.add(new SplitInfo(context, fs, file, info, isOriginal, deltas, true, dir, covered)); &#125; &#125; return result;&#125; 本质上是一个BUG，Spark2.4版本中解决了这个问题。 123456789101112131415// org.apache.hadoop.hive.ql.io.orc.OrcInputFormat.BISplitStrategy#getSplitspublic List&lt;OrcSplit&gt; getSplits() throws IOException &#123; List&lt;OrcSplit&gt; splits = Lists.newArrayList(); for (FileStatus fileStatus : fileStatuses) &#123; String[] hosts = SHIMS.getLocationsWithOffset(fs, fileStatus).firstEntry().getValue() .getHosts(); OrcSplit orcSplit = new OrcSplit(fileStatus.getPath(), 0, fileStatus.getLen(), hosts, null, isOriginal, true, deltas, -1); splits.add(orcSplit); &#125; // add uncovered ACID delta splits splits.addAll(super.getSplits()); return splits;&#125; 了解了spark读取orc文件策略，那么就设置避免混合模式使用根据文件大小分割读取，不根据文件来读取 1set hive.exec.orc.split.strategy=ETL 经测试无效。原因分析：1、参数未生效2、hdfs文件有两个，大小为49B和7.45G，文件的平均大小肯定是大于256M的，所以按默认HYBRID策略规则应本就是采取的ETL策略split ORC文件 3、参数设置：spark.sql.hive.convertMetastoreOrc=true关于参数的官方介绍 Since Spark 2.3, Spark supports a vectorized ORC reader with a new ORC file format for ORC files. To do that, the following configurations are newly added. The vectorized reader is used for the native ORC tables (e.g., the ones created using the clause USING ORC) when spark.sql.orc.impl is set to native and spark.sql.orc.enableVectorizedReader is set to true. For the Hive ORC serde tables (e.g., the ones created using the clause USING HIVE OPTIONS (fileFormat ‘ORC’)), the vectorized reader is used when spark.sql.hive.convertMetastoreOrc is also set to true. 经测试有效。若仍报错，可尝试搭配spark.sql.orc.impl&#x3D;native使用。 补充知识13745hive.exec.orc.split.strategy参数控制在读取ORC表时生成split的策略。对于一些较大的ORC表，可能其footer较大，ETL策略可能会导致其从hdfs拉取大量的数据来切分split，甚至会导致driver端OOM，因此这类表的读取建议使用BI策略。对于一些较小的尤其有数据倾斜的表（这里的数据倾斜指大量stripe存储于少数文件中），建议使用ETL策略。另外，spark.hadoop.mapreduce.input.fileinputformat.split.minsize参数可以控制在ORC切分时stripe的合并处理。具体逻辑是，当几个stripe的大小小于spark.hadoop.mapreduce.input.fileinputformat.split.minsize时，会合并到一个task中处理。可以适当调小该值，以此增大读ORC表的并发。 参考资料SPARK查ORC格式HIVE数据报错NULLPOINTEREXCEPTIONSparkSQL读取ORC表时遇到空文件","categories":[{"name":"SQL","slug":"SQL","permalink":"https://llye-hub.github.io/categories/SQL/"}],"tags":[{"name":"ORC","slug":"ORC","permalink":"https://llye-hub.github.io/tags/ORC/"}]},{"title":"资料汇总","slug":"资料汇总","date":"2022-12-16T03:46:24.000Z","updated":"2023-06-08T06:24:01.416Z","comments":true,"path":"posts/76d5a95a.html","link":"","permalink":"https://llye-hub.github.io/posts/76d5a95a.html","excerpt":"","text":"SparkSpark SQL Limit 介绍及优化Spark性能优化指南——基础篇Spark性能优化指南——高级篇Spark 入门看这篇就够了（万字长文） 大数据笔记大数据入门指南 数据结构与算法代码随想录 数据治理存储和计算资源都节省 30%，网易云音乐数据治理实践 数据仓库如何避免数仓模型“烟囱式”建设数仓常见问题以及解决方案！深入理解数据仓库建模 数据库数据库内核杂谈系列 流量数仓用户流量数仓建设思考（一）：基于漏斗模型的通用建设 数据分析如何成为一名数据分析师（二）——统计学之描述性统计低代码指标平台，构建人人可用的敏捷指标工具 乱七八糟的2万字揭秘阿里巴巴数据治理平台建设经验触达场景下的智能化实践40亿个QQ号，限制1G内存，如何去重？","categories":[{"name":"资料","slug":"资料","permalink":"https://llye-hub.github.io/categories/%E8%B5%84%E6%96%99/"}],"tags":[]},{"title":"get_json_object在sql中的高级用法","slug":"SQL/get_json_object在sql中的高级用法","date":"2022-12-16T03:46:24.000Z","updated":"2023-11-09T14:44:29.788Z","comments":true,"path":"posts/5f45fcd7.html","link":"","permalink":"https://llye-hub.github.io/posts/5f45fcd7.html","excerpt":"","text":"语法介绍12get_json_object(String json_string, String path)-- return string get_json_object函数是用来根据指定路径提取json字符串中的json对象，并返回json对象的json字符串 现有困惑关于这个函数最常见的用法就是get_json_object(&#39;&#123;&quot;a&quot;:&quot;b&quot;&#125;&#39;, &#39;$.a&#39;)，返回结果b但$.a这种path写法仅适用于简单的多层嵌套json字符串解析，碰到嵌套层有json数组时就难以解析了比如，要提取下面这段json中的所有weight对象的值 123456789&#123; &quot;store&quot;: &#123; &quot;fruit&quot;:[&#123;&quot;weight&quot;:8,&quot;type&quot;:&quot;apple&quot;&#125;, &#123;&quot;weight&quot;:9,&quot;type&quot;:&quot;pear&quot;&#125;], //json数组 &quot;bicycle&quot;:&#123;&quot;price&quot;:19.95,&quot;color&quot;:&quot;red&quot;&#125; &#125;, &quot;email&quot;:&quot;amy@only_for_json_udf_test.net&quot;, &quot;owner&quot;:&quot;amy&quot; &#125; 通过$.store.fruit.weight路径是无法提取的，$.store.fruit[0].weight这种写法仅能获取json数组中第一个json字符串中weight对象的值，也总不能用[0]、[1]、[2]……的方式无穷尽取值吧 到这里思维就限制住了，遇到这种情况时，以前的方式是通过正则表达式处理具体实现如下：首先将item_properties按指定分隔符split为array数组，再利用explode函数将array数组的元素逐行输出，最终得到的item_propertie即为单个json字符串，可根据$.提取指定json对象的值， 12345678910-- item_properties = [&#123;&quot;id&quot;:42,&quot;name&quot;:&quot;包装&quot;,&quot;sort&quot;:0,&quot;type&quot;:1&#125;-- ,&#123;&quot;id&quot;:43,&quot;name&quot;:&quot;种类&quot;,&quot;sort&quot;:0,&quot;type&quot;:1&#125;-- ,&#123;&quot;id&quot;:44,&quot;name&quot;:&quot;规格&quot;,&quot;sort&quot;:0,&quot;type&quot;:2&#125;-- ,&#123;&quot;id&quot;:63,&quot;name&quot;:&quot;保质期(天)&quot;,&quot;sort&quot;:0,&quot;type&quot;:2&#125;-- ,&#123;&quot;id&quot;:100,&quot;name&quot;:&quot;适用年龄&quot;,&quot;sort&quot;:0,&quot;type&quot;:2&#125;-- ,&#123;&quot;id&quot;:101,&quot;name&quot;:&quot;储存条件&quot;,&quot;sort&quot;:0,&quot;type&quot;:2&#125;]select get_json_object(item_propertie,&#x27;$.id&#x27;)from table_alateral view explode(split(regexp_replace(substr(item_properties,2,length(item_properties)-2),&#x27;\\\\&#125;\\\\,\\\\&#123;&#x27;,&#x27;\\\\&#125;\\\\|\\\\|\\\\&#123;&#x27;),&#x27;\\\\|\\\\|&#x27;)) tmp as item_propertie 但上面这种处理方式存在bug，将json数据split为array数组时，必须保证指定分隔符不出现在单个json字符串中，比如上述case中是用&#125;,&#123;替换为&#125;||&#123;，再以||作为分隔符split，如若在单个json字符串中也出现了&#125;,&#123;或是||就会导致解析失败 怎么高级了突然有一天在翻看hive官方文档时发现path支持的通配符* 1234$ : 表示根节点. : 表示子节点[] : [number]表示数组下标，从0开始* : []的通配符，返回整个数组 所以，一开始的问题应该按如下解法： 123456789-- jsonArray = &#123;&quot;store&quot;:-- &#123;-- &quot;fruit&quot;:[&#123;&quot;weight&quot;:8,&quot;type&quot;:&quot;apple&quot;&#125;, &#123;&quot;weight&quot;:9,&quot;type&quot;:&quot;pear&quot;&#125;],-- &quot;bicycle&quot;:&#123;&quot;price&quot;:19.95,&quot;color&quot;:&quot;red&quot;&#125;-- &#125;, -- &quot;email&quot;:&quot;amy@only_for_json_udf_test.net&quot;, -- &quot;owner&quot;:&quot;amy&quot;&#125;select get_json_object(jsonArray, &#x27;$.store.fruit[*].weight&#x27;);-- return [8,9] 笔者个人认为，高级之处在于写法极其清爽，按照以前用正则表达式的处理方法，需要多道处理才能得到结果[8,9]，而且其中还有隐性风险，但是现在$.store.fruit[*].weight这种极简语法既避免了风险，又清晰易理解","categories":[{"name":"SQL","slug":"SQL","permalink":"https://llye-hub.github.io/categories/SQL/"}],"tags":[{"name":"SQL高级语法","slug":"SQL高级语法","permalink":"https://llye-hub.github.io/tags/SQL%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"}]}],"categories":[{"name":"对照文件存放的目录名称","slug":"对照文件存放的目录名称","permalink":"https://llye-hub.github.io/categories/%E5%AF%B9%E7%85%A7%E6%96%87%E4%BB%B6%E5%AD%98%E6%94%BE%E7%9A%84%E7%9B%AE%E5%BD%95%E5%90%8D%E7%A7%B0/"},{"name":"数据结构与算法笔记","slug":"数据结构与算法笔记","permalink":"https://llye-hub.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"name":"数据仓库","slug":"数据仓库","permalink":"https://llye-hub.github.io/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"},{"name":"SQL","slug":"SQL","permalink":"https://llye-hub.github.io/categories/SQL/"},{"name":"练习笔记","slug":"练习笔记","permalink":"https://llye-hub.github.io/categories/%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"hive","slug":"hive","permalink":"https://llye-hub.github.io/categories/hive/"},{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://llye-hub.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"name":"spark","slug":"spark","permalink":"https://llye-hub.github.io/categories/spark/"},{"name":"hadoop","slug":"hadoop","permalink":"https://llye-hub.github.io/categories/hadoop/"},{"name":"shell","slug":"shell","permalink":"https://llye-hub.github.io/categories/shell/"},{"name":"资料","slug":"资料","permalink":"https://llye-hub.github.io/categories/%E8%B5%84%E6%96%99/"}],"tags":[{"name":"文章内容的关键词","slug":"文章内容的关键词","permalink":"https://llye-hub.github.io/tags/%E6%96%87%E7%AB%A0%E5%86%85%E5%AE%B9%E7%9A%84%E5%85%B3%E9%94%AE%E8%AF%8D/"},{"name":"private","slug":"private","permalink":"https://llye-hub.github.io/tags/private/"},{"name":"刷题","slug":"刷题","permalink":"https://llye-hub.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"数仓","slug":"数仓","permalink":"https://llye-hub.github.io/tags/%E6%95%B0%E4%BB%93/"},{"name":"数据倾斜","slug":"数据倾斜","permalink":"https://llye-hub.github.io/tags/%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://llye-hub.github.io/tags/LeetCode/"},{"name":"hive元数据","slug":"hive元数据","permalink":"https://llye-hub.github.io/tags/hive%E5%85%83%E6%95%B0%E6%8D%AE/"},{"name":"hexo","slug":"hexo","permalink":"https://llye-hub.github.io/tags/hexo/"},{"name":"hiveSQL","slug":"hiveSQL","permalink":"https://llye-hub.github.io/tags/hiveSQL/"},{"name":"grouping sets","slug":"grouping-sets","permalink":"https://llye-hub.github.io/tags/grouping-sets/"},{"name":"数仓建模","slug":"数仓建模","permalink":"https://llye-hub.github.io/tags/%E6%95%B0%E4%BB%93%E5%BB%BA%E6%A8%A1/"},{"name":"写UDF","slug":"写UDF","permalink":"https://llye-hub.github.io/tags/%E5%86%99UDF/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://llye-hub.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"内置函数","slug":"内置函数","permalink":"https://llye-hub.github.io/tags/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"name":"spark on yarn","slug":"spark-on-yarn","permalink":"https://llye-hub.github.io/tags/spark-on-yarn/"},{"name":"hive安装","slug":"hive安装","permalink":"https://llye-hub.github.io/tags/hive%E5%AE%89%E8%A3%85/"},{"name":"hadoop安装","slug":"hadoop安装","permalink":"https://llye-hub.github.io/tags/hadoop%E5%AE%89%E8%A3%85/"},{"name":"shell命令","slug":"shell命令","permalink":"https://llye-hub.github.io/tags/shell%E5%91%BD%E4%BB%A4/"},{"name":"免密登录","slug":"免密登录","permalink":"https://llye-hub.github.io/tags/%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"},{"name":"sql练习","slug":"sql练习","permalink":"https://llye-hub.github.io/tags/sql%E7%BB%83%E4%B9%A0/"},{"name":"窗口函数","slug":"窗口函数","permalink":"https://llye-hub.github.io/tags/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"},{"name":"java","slug":"java","permalink":"https://llye-hub.github.io/tags/java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://llye-hub.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Maxcompute","slug":"Maxcompute","permalink":"https://llye-hub.github.io/tags/Maxcompute/"},{"name":"SQL高级语法","slug":"SQL高级语法","permalink":"https://llye-hub.github.io/tags/SQL%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"},{"name":"改分区","slug":"改分区","permalink":"https://llye-hub.github.io/tags/%E6%94%B9%E5%88%86%E5%8C%BA/"},{"name":"hadoop命令","slug":"hadoop命令","permalink":"https://llye-hub.github.io/tags/hadoop%E5%91%BD%E4%BB%A4/"},{"name":"hdfs文件拷贝","slug":"hdfs文件拷贝","permalink":"https://llye-hub.github.io/tags/hdfs%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D/"},{"name":"动态分区","slug":"动态分区","permalink":"https://llye-hub.github.io/tags/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA/"},{"name":"ORC","slug":"ORC","permalink":"https://llye-hub.github.io/tags/ORC/"}]}