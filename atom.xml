<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LLye</title>
  
  
  <link href="https://llye-hub.github.io/atom.xml" rel="self"/>
  
  <link href="https://llye-hub.github.io/"/>
  <updated>2023-11-14T05:28:13.241Z</updated>
  <id>https://llye-hub.github.io/</id>
  
  <author>
    <name>LLye</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>认识一下拉链表</title>
    <link href="https://llye-hub.github.io/posts/4e6addf5.html"/>
    <id>https://llye-hub.github.io/posts/4e6addf5.html</id>
    <published>2023-11-13T04:20:37.000Z</published>
    <updated>2023-11-14T05:28:13.241Z</updated>
    
    
    
    
    <category term="数据仓库" scheme="https://llye-hub.github.io/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
    
    <category term="拉链表" scheme="https://llye-hub.github.io/tags/%E6%8B%89%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>java刷题常用code整理</title>
    <link href="https://llye-hub.github.io/posts/2a5db4cb.html"/>
    <id>https://llye-hub.github.io/posts/2a5db4cb.html</id>
    <published>2023-10-10T10:31:02.000Z</published>
    <updated>2023-11-14T04:11:28.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h1><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure><h2 id="list排序"><a href="#List排序" class="headerlink" title="List排序"></a>List排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">arr.add(<span class="number">1</span>);</span><br><span class="line">arr.add(<span class="number">2</span>);</span><br><span class="line">arr.add(<span class="number">3</span>);</span><br><span class="line">Collections.sort(arr);</span><br><span class="line">arr.sort((o1, o2) -&gt; o2-o1);</span><br><span class="line">System.out.println(arr.toString());</span><br></pre></td></tr></table></figure><h2 id="二维数组排序"><a href="#二维数组排序" class="headerlink" title="二维数组排序"></a>二维数组排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">Arrays.sort(arr2, Comparator.comparingInt(o -&gt; o[<span class="number">1</span>])); <span class="comment">// 按第二列升序排序</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义比较器Comparator</span></span><br><span class="line"><span class="type">int</span>[][] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">Arrays.sort(price_rating, <span class="keyword">new</span> <span class="title class_">MyComparator</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt; &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> arr1[<span class="number">1</span>] - arr2[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最值问题"><a href="#最值问题" class="headerlink" title="最值问题"></a>最值问题</h1><h2 id="数组求最值"><a href="#数组求最值" class="headerlink" title="数组求最值"></a>数组求最值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int[]数组的最大值</span></span><br><span class="line"><span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Arrays.stream(counts).max().getAsInt();</span><br></pre></td></tr></table></figure><h1 id="类型转换问题"><a href="#类型转换问题" class="headerlink" title="类型转换问题"></a>类型转换问题</h1><h2 id="char和string互相转换"><a href="#char-和String互相转换" class="headerlink" title="char[]和String互相转换"></a>char[]和String互相转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&#x27;letter&#x27;</span>;</span><br><span class="line"><span class="comment">// String转换为char[]</span></span><br><span class="line"><span class="type">char</span>[] strToChars = str.toCharArray();</span><br><span class="line"><span class="comment">// char[]转换为String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">charsToStr</span> <span class="operator">=</span> String.valueOf(chars);</span><br></pre></td></tr></table></figure><h2 id="int和string互相转换"><a href="#int-和String-互相转换" class="headerlink" title="int[]和String[]互相转换"></a>int[]和String[]互相转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String[] 转换为 int[]</span></span><br><span class="line">String[] strs;</span><br><span class="line"><span class="type">int</span>[] nums = Arrays.stream(strs).mapToInt(Integer::parseInt).toArray();</span><br></pre></td></tr></table></figure><h1 id="arraylist方法"><a href="#ArrayList方法" class="headerlink" title="ArrayList方法"></a>ArrayList方法</h1><h2 id="remove-移除元素"><a href="#remove-移除元素" class="headerlink" title="remove 移除元素"></a>remove 移除元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定元素。remove() 方法仅将对象作为其参数。如果 obj 元素出现多次，则删除在动态数组中最第一次出现的元素。</span></span><br><span class="line">arraylist.remove(Object obj);</span><br><span class="line"><span class="comment">// 如果list元素是Integer类型，则需要用Integer.valueOf()将 删除元素 从 int 类型转变成一个 Integer 对象。</span></span><br><span class="line">randomNumbers.remove(Integer.valueOf(<span class="number">13</span>));</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 删除指定索引位置的元素</span></span><br><span class="line">arraylist.remove(<span class="type">int</span> index);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;排序问题&quot;&gt;&lt;a href=&quot;#排序问题&quot; class=&quot;headerlink&quot; title=&quot;排序问题&quot;&gt;&lt;/a&gt;排序问题&lt;/h1&gt;&lt;h2 id=&quot;数组排序&quot;&gt;&lt;a href=&quot;#数组排序&quot; class=&quot;headerlink&quot; title=&quot;数组排序&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="数据结构与算法笔记" scheme="https://llye-hub.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="刷题" scheme="https://llye-hub.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>怎么评价是一个好的数仓设计</title>
    <link href="https://llye-hub.github.io/posts/a74701e.html"/>
    <id>https://llye-hub.github.io/posts/a74701e.html</id>
    <published>2023-09-15T07:55:18.000Z</published>
    <updated>2023-11-09T15:48:25.592Z</updated>
    
    <content type="html"><![CDATA[<p>好的数仓设计标准应该是数据丰富完善、数据复用性强、数据规范性高。</p><h2 id="完善度"><a href="#完善度" class="headerlink" title="完善度"></a>完善度</h2><ul><li><p>dwd层完善度：衡量dwd层的完善度，看ods层被dw&#x2F;dws&#x2F;ads&#x2F;dim层依赖的数量（跨层引用率）。ods层被越多的非dwd层引用，说明越多任务基于原始数据进行开发，各种数据清洗、数据格式化存在重复计算。好的数仓设计一般要求ods层只能被dwd层引用，即跨层引用率为100%。</p></li><li><p>dw&#x2F;dws&#x2F;ads层完善度：衡量汇总数据的完善度，看仅靠dw&#x2F;dws&#x2F;ads层数据就能满足的查询比例（汇总层查询比例）。若汇总层数据无法满足查询要求，则需要从原始数据自行加工计算。汇总层查询比例不可能完全做到100%，但值越高，说明数仓上层模型建设越完善。</p></li></ul><h2 id="复用度"><a href="#复用度" class="headerlink" title="复用度"></a>复用度</h2><ul><li>模型引用系数：⼀个模型被读取，直接产出下游模型的平均数量。若对所有dwd层表（有下游）的模型引用系数取均值，则可衡量dwd层的模型引用系数。系数越大，说明数仓复用度越高。从数据血缘图来看，自下而上一条线的模型设计复用性差，复杂场景下这条线会极其长，而理想的模型设计应是交织的发散型结构</li></ul><h2 id="规范度"><a href="#规范度" class="headerlink" title="规范度"></a>规范度</h2><ul><li><p>表分层规范：有多少表不能划属到数仓架构的某一层，一般从表命名前缀体现。</p></li><li><p>表命名规范：⼀个规范的表命名应该包括所属分层、所属主题域、调度周期、全量&#x2F;增量等信息。</p></li><li><p>字段命名规范：相同字段应在不同表保持一样的命名。同样是用户id，不能在A表叫user_id，在B表却叫u_id.</p></li></ul><p>数仓规范度越高，表名包含的信息越多，在数据地图查找表越方便，也更利于提高模型表复用度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好的数仓设计标准应该是数据丰富完善、数据复用性强、数据规范性高。&lt;/p&gt;
&lt;h2 id=&quot;完善度&quot;&gt;&lt;a href=&quot;#完善度&quot; class=&quot;headerlink&quot; title=&quot;完善度&quot;&gt;&lt;/a&gt;完善度&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;dwd层完善度：衡量dwd层的完善</summary>
      
    
    
    
    <category term="数据仓库" scheme="https://llye-hub.github.io/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
    
    <category term="数仓" scheme="https://llye-hub.github.io/tags/%E6%95%B0%E4%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>数仓分层</title>
    <link href="https://llye-hub.github.io/posts/96c137c4.html"/>
    <id>https://llye-hub.github.io/posts/96c137c4.html</id>
    <published>2023-09-09T11:54:03.000Z</published>
    <updated>2023-11-09T15:48:18.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要分层"><a href="#为什么要分层" class="headerlink" title="为什么要分层"></a>为什么要分层</h1><p>试想一下没有数仓分层的以下场景：</p><p>有一个需求，计算每个用户日gmv，然后从交易系统抽取数据，并求和计算得到一张 A 表。<br>又来了一个需求，计算每个地区的日gmv，这时发现能再 A 表的基础上能聚合加工得到 B 表。<br>一段时间后，需要每个地区的日净gmv（不包含退款），这时 B 表和 A 表都不能支持，然后又从交易系统重复抽取数据。  </p><p>上面场景比较简单化，实际中，在没有划分数仓分层的情况下，我们可能会做出一套表依赖结构混乱，甚至出现循环依赖的数据体系。</p><p>类比图书管理，如果没有书架和分类标识，图书随意堆叠在一起，每次都需要重复搬书翻找，十分地耗时耗力。当有了书架和分类摆放，每次按照标识就能快速定位书籍位置。</p><p>因此，我们需要一套行之有效的数据组织和管理方法来让我们的数据体系更有序，这就是谈到的数据分层。</p><h1 id="分层的好处"><a href="#分层的好处" class="headerlink" title="分层的好处"></a>分层的好处</h1><p>数据分层并不能解决所有的数据问题，但是，数据分层却可以给我们带来如下的好处：</p><p>（1）<strong>清晰数据结构</strong>：每一个数据分层都有对应的作用域，在使用数据的时候能更方便的定位和理解。<br>（2）<strong>数据血缘追踪</strong>：提供给业务人员或下游系统的数据服务时都是目标数据，目标数据的数据来源一般都来自于多张表数据。若出现目标数据异常时，清晰的血缘关系可以快速定位问题所在。而且，血缘管理也是元数据管理重要的一部分。<br>（2）<strong>减少重复开发</strong>：数据的逐层加工原则，下层包含了上层数据加工所需要的全量数据，这样的加工方式避免了每个数据开发人员都重新从源系统抽取数据进行加工。<br>（3）<strong>数据关系条理化</strong>：源系统间存在复杂的数据关系，比如客户信息同时存在于核心系统、信贷系统、理财系统、资金系统，取数时该如何决策呢？数据仓库会对相同主题的数据进行统一建模，把复杂的数据关系梳理成条理清晰的数据模型，使用时就可避免上述问题了。<br>（4）<strong>屏蔽原始数据的影响</strong>：数据的逐层加工原则，上层的数据都由下一层的数据加工获取，不允许跳级取数。而原始数据位于数仓的最底层，离应用层数据还有多层的数据加工，所以加工应用层数据的过程中就会把原始数据的变更消除掉，保持应用层的稳定性。  </p><h1 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h1><p>以呆过的一家公司的数仓架构为例，数仓架构主要分为五层：</p><p>1）<strong>ods：（Operational Data Store）数据贴源层</strong>，将业务系统的数据几乎无处理地存储在数仓系统中，结构上与业务系统基本保持一致。<br>2）<strong>dwd：（Data Warehouse Detail）数据明细层</strong>，用于隔离业务层和数据仓库，保持和ods层一样的颗粒度，对ods层的数据做一些简单的清洗、去空值、标准化处理。<br>3）<strong>dw：（Data Warehouse）数据中间层</strong>，在dwd层的基础上，对数据进行轻微的聚合操作，提升公共指标的复用性，减少重复加工操作。<br>4）<strong>dws：（Data Warehouse Summary）数据汇总层</strong>，以dw层为基础，整合成分析某个主题域的汇总数据，用于提供后续的查询分析服务。该层的数据表会涵盖较多的业务信息，字段较多，一般称为宽表。<br>5）<strong>ads：（Application Data Store）数据应用层</strong>，为各种数据产品提供个性化的统计指标数据。 </p><p>此外，还有<strong>dim层（维表层）</strong>，将事实表中重复出现的属性信息抽取出来，用一张表进行规范管理，查询时再与事实表进行关联。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么要分层&quot;&gt;&lt;a href=&quot;#为什么要分层&quot; class=&quot;headerlink&quot; title=&quot;为什么要分层&quot;&gt;&lt;/a&gt;为什么要分层&lt;/h1&gt;&lt;p&gt;试想一下没有数仓分层的以下场景：&lt;/p&gt;
&lt;p&gt;有一个需求，计算每个用户日gmv，然后从交易系统抽取数据，并</summary>
      
    
    
    
    <category term="数据仓库" scheme="https://llye-hub.github.io/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
    
    <category term="数仓" scheme="https://llye-hub.github.io/tags/%E6%95%B0%E4%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>SparkSQL优化之数据倾斜</title>
    <link href="https://llye-hub.github.io/posts/faab1ad7.html"/>
    <id>https://llye-hub.github.io/posts/faab1ad7.html</id>
    <published>2023-07-09T02:19:52.000Z</published>
    <updated>2023-11-08T03:56:31.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Spark作业优化场景中，最常见且比较棘手的就是数据倾斜问题。个人认为，具备数据倾斜调优能力对从事数仓开发人员是必备的基本要求。当然，数据倾斜的场景是比较复杂的，针对不同的数据倾斜有不同的处理方案。</p><h1 id="如何辨别和定位数据倾斜"><a href="#如何辨别和定位数据倾斜" class="headerlink" title="如何辨别和定位数据倾斜"></a>如何辨别和定位数据倾斜</h1><p>从Spark作业的执行计划看，若出现某个task任务比其他task任务执行耗时极其久，比如：某个stage有100个task，其中99个task在1min左右就执行成功，但是有1个task却执行了1个小时甚至更久，这种情况显然是出现了数据倾斜。</p><p>数据倾斜问题仅出现在shuffle过程，一些会触发shuffle的算子：distinct、groupByKey、reduceByKey、aggregateByKey、countByKey、join、cogroup、repartition等。<br>对应提交的SparkSQL中可能有distinct、count(distinct)、group by、partition by、join等关键词。</p><h1 id="常见的数据倾斜场景及解决方案"><a href="#常见的数据倾斜场景及解决方案" class="headerlink" title="常见的数据倾斜场景及解决方案"></a>常见的数据倾斜场景及解决方案</h1><h1 id="碰到的数据倾斜案例"><a href="#碰到的数据倾斜案例" class="headerlink" title="碰到的数据倾斜案例"></a>碰到的数据倾斜案例</h1><h2 id="窗口分组数据倾斜"><a href="#窗口分组数据倾斜" class="headerlink" title="窗口分组数据倾斜"></a>窗口分组数据倾斜</h2><p><strong>倾斜场景</strong><br>业务上有一张消息记录表msg_records，sql要求是取下一次回复消息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> msg_tmp <span class="keyword">as</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span>  id                  <span class="comment">-- 唯一键，消息id</span></span><br><span class="line">           ,from_chat_id        <span class="comment">-- 消息发送者id</span></span><br><span class="line">           ,to_chat_id          <span class="comment">-- 消息接受者id</span></span><br><span class="line">           ,msg_time            <span class="comment">-- 消息时间</span></span><br><span class="line">    <span class="keyword">from</span> msg_records</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span>  id</span><br><span class="line">       ,msg_time</span><br><span class="line">       ,<span class="built_in">first_value</span>(if(type <span class="operator">=</span> <span class="string">&#x27;reply&#x27;</span>,id,<span class="keyword">null</span>),<span class="literal">true</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> from_chat_id,to_chat_id <span class="keyword">order</span> <span class="keyword">by</span> msg_time,id <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> following <span class="keyword">and</span> unbounded following) <span class="keyword">as</span> reply_msg_id_n1t <span class="comment">-- 取下一次回复消息</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span>  id</span><br><span class="line">           ,from_chat_id</span><br><span class="line">           ,to_chat_id</span><br><span class="line">           ,msg_time</span><br><span class="line">           ,<span class="string">&#x27;send&#x27;</span> <span class="keyword">as</span> type</span><br><span class="line">    <span class="keyword">from</span> msg_tmp</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="comment">-- 调转，取返回消息</span></span><br><span class="line">    <span class="keyword">select</span>  id</span><br><span class="line">           ,to_chat_id   <span class="keyword">as</span> from_chat_id</span><br><span class="line">           ,from_chat_id <span class="keyword">as</span> to_chat_id</span><br><span class="line">           ,msg_time</span><br><span class="line">           ,<span class="string">&#x27;reply&#x27;</span>      <span class="keyword">as</span> type</span><br><span class="line">    <span class="keyword">from</span> msg_tmp</span><br><span class="line">) t1</span><br></pre></td></tr></table></figure><p><strong>sql执行分析</strong><br>有一个task执行耗时1h<br>4373</p><p><strong>数据倾斜分析</strong><br>根据窗口函数的分组<code>from_chat_id + to_chat_id</code>分析，数据量出现严重倾斜，表总数据量1亿多，其中，分组<code>from_chat_id=12 and to_chat_id=81867</code>的数据量有30w，其他分组数据量至多3w。</p><p>另外，分组<code>from_chat_id=12 and to_chat_id=81867</code>的数据在业务上可定义为脏数据，且first_value()函数计算出的值全为null。</p><p>经过测试验证发现，没有 <strong>rows between语句</strong> 或是 <strong>过滤倾斜数据</strong> 时，SQL执行很快</p><p>综上分析，再对照spark执行计划基本可以定位倾斜原因为<strong>窗口数据倾斜和rows between计算耗时</strong></p><p><strong>解决方案</strong><br>结合业务知识，在sql逻辑中过滤<code>from_chat_id=12 and to_chat_id=81867</code>的数据</p><p>最终，任务执行耗时从<code>1h</code>优化至<code>10min</code></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://tech.meituan.com/2016/05/12/spark-tuning-pro.html">美团技术团队：Spark性能优化指南——高级篇</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在Spark作业优化场景中，最常见且比较棘手的就是数据倾斜问题。个人认为，具备数据倾斜调优能力对从事数仓开发人员是必备的基本要求。当然，数据</summary>
      
    
    
    
    <category term="SQL" scheme="https://llye-hub.github.io/categories/SQL/"/>
    
    
    <category term="数据倾斜" scheme="https://llye-hub.github.io/tags/%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/"/>
    
  </entry>
  
  <entry>
    <title>算法思路总结</title>
    <link href="https://llye-hub.github.io/posts/5f4823a0.html"/>
    <id>https://llye-hub.github.io/posts/5f4823a0.html</id>
    <published>2023-06-15T06:16:02.000Z</published>
    <updated>2023-06-28T03:05:20.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="st表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h1><p>ST表（Sparse Table，稀疏表）是一种数据结构，采用了倍增的思想，在<code>O(nlogn)</code>时间构造一个二维表，可以在<code>O(1)</code>时间查询<code>[l,r]</code>区间的最值。主要用于解决RMQ（Range Minimum&#x2F;Maximum Query，区间最值查询）问题。</p><p>实现思路：</p><ul><li>设<code>F[i,j]</code>表示<code>[i,i+2^j-1]</code>区间的最值，区间长度为<code>2^j</code></li><li>根据倍增思想，长度为<code>2^j</code>的区间能分成两个长度为<code>2^(j-1)</code>的区间，然后分别求两个区间的最值。递推公式：<code>F[i,j]=max(F[i,j-1],F[i+2^(j-1),j-1])</code></li></ul><p>java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建ST表</span></span><br><span class="line"><span class="type">int</span>[] lg = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];<span class="comment">// 预处理：以2为底的对数，向下取整</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(lg));</span><br><span class="line"></span><br><span class="line"><span class="comment">// f[i][j] 表示 [i - 2^j + 1, i] 区间的最大值</span></span><br><span class="line"><span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n][lg[n] + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    f[i][<span class="number">0</span>] = chargeTimes[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= lg[i + <span class="number">1</span>]; ++j) &#123;</span><br><span class="line">        f[i][j] = Math.max(f[i][j - <span class="number">1</span>], f[i - (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] tmp : f) &#123;</span><br><span class="line">    System.out.printf(Arrays.toString(tmp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;st表&quot;&gt;&lt;a href=&quot;#ST表&quot; class=&quot;headerlink&quot; title=&quot;ST表&quot;&gt;&lt;/a&gt;ST表&lt;/h1&gt;&lt;p&gt;ST表（Sparse Table，稀疏表）是一种数据结构，采用了倍增的思想，在&lt;code&gt;O(nlogn)&lt;/code&gt;时间构造一个</summary>
      
    
    
    
    <category term="练习笔记" scheme="https://llye-hub.github.io/categories/%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>解题思路之贪心算法</title>
    <link href="https://llye-hub.github.io/posts/da0ecc89.html"/>
    <id>https://llye-hub.github.io/posts/da0ecc89.html</id>
    <published>2023-05-31T07:37:07.000Z</published>
    <updated>2023-06-06T07:05:16.181Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="f1f3933a38de26f1241c74b22bf82c037a1f539cf1cf481ff0f3312a41d44f38">0ae7e196f2221a75e5346dcbb7e124f36deed831076312fa04e0c81d58c043c148e8c22ba19b06abf116e63b513fbe0b5b1ddbf3866dc6a4e231d41e8109c481fc84aff1e6d1f764e5387bbc2a63efcd269076b6d26b9e37133e8c3c6e87e9c29bb7891588fe68135e64e07a5ee665260c228e10e9e2b55e786e2e883ea80bceea0893b36e9e1e963aad143ef29fb21981efea5dca5fe6cbb33adb683110ddbb7085b2538798a7949198817313548b38852832d8eddec8d696ad233fc849508b1de1d97c47860c66db564e474b3cdd7dc05b249a441e1f42d0fe89b797e9a6f338fd5759017bc374582df0e6d42f28361eb0d77c753ec011e1c74dff9ebd735b03ceeea2bf90dbe2c14c2a3da8ce0fa476df707c7a8e1749a23b680aa9b612153300f46bb11388f8217130f8ee7b541cf4431a021a430a3e721ede6cc6a94facb92a5ca4b781e9be77c179c399d4d821</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是一篇加密文章，需要密码才能继续阅读。</summary>
    
    
    
    <category term="对照文件存放的目录名称" scheme="https://llye-hub.github.io/categories/%E5%AF%B9%E7%85%A7%E6%96%87%E4%BB%B6%E5%AD%98%E6%94%BE%E7%9A%84%E7%9B%AE%E5%BD%95%E5%90%8D%E7%A7%B0/"/>
    
    
    <category term="文章内容的关键词" scheme="https://llye-hub.github.io/tags/%E6%96%87%E7%AB%A0%E5%86%85%E5%AE%B9%E7%9A%84%E5%85%B3%E9%94%AE%E8%AF%8D/"/>
    
    <category term="private" scheme="https://llye-hub.github.io/tags/private/"/>
    
  </entry>
  
  <entry>
    <title>SQL之distirbute by rand有坑</title>
    <link href="https://llye-hub.github.io/posts/68201c19.html"/>
    <id>https://llye-hub.github.io/posts/68201c19.html</id>
    <published>2023-05-23T09:29:09.000Z</published>
    <updated>2023-06-06T07:05:16.175Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="27e524583d1fcf2f1c13d3f5a7034a7f698ec863b32338e48443bc6eccafe994">0ae7e196f2221a75e5346dcbb7e124f39514e07fde056a265182dbd07146d257904f8da20d3ff0c1b0ef8ab8f0988a5faa61ca39c50eca0bc647f1183468803fdb7eb5d5a7593fd27e5d0d4c591b1b3b437b54ddd77005bf7470681fc084f79e4692262a7f466691839a576636f25cc888052dd1155a41106eb8db3b08946eb959cf163478c34033fb6ecaec8e26b694d3d6c8f1267c9f15b06256e1ca5699e5cac5130527fb77e1f5d169cd7b276a6fb1d18b77ca651179a48e0c7aa93ed2e7b1bf0984864b9f7a1e23e5aff938ca81b5be8200b7bf93fe40d35a21c6bcb5c6c181d8277085c1c77c914826650e9850</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是一篇加密文章，需要密码才能继续阅读。</summary>
    
    
    
    <category term="对照文件存放的目录名称" scheme="https://llye-hub.github.io/categories/%E5%AF%B9%E7%85%A7%E6%96%87%E4%BB%B6%E5%AD%98%E6%94%BE%E7%9A%84%E7%9B%AE%E5%BD%95%E5%90%8D%E7%A7%B0/"/>
    
    
    <category term="文章内容的关键词" scheme="https://llye-hub.github.io/tags/%E6%96%87%E7%AB%A0%E5%86%85%E5%AE%B9%E7%9A%84%E5%85%B3%E9%94%AE%E8%AF%8D/"/>
    
    <category term="private" scheme="https://llye-hub.github.io/tags/private/"/>
    
  </entry>
  
  <entry>
    <title>解题思路之回溯算法</title>
    <link href="https://llye-hub.github.io/posts/49adf57d.html"/>
    <id>https://llye-hub.github.io/posts/49adf57d.html</id>
    <published>2023-05-19T06:34:49.000Z</published>
    <updated>2023-06-28T02:03:26.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是回溯算法"><a href="#什么是回溯算法" class="headerlink" title="什么是回溯算法"></a>什么是回溯算法</h1><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，回溯函数也就是递归函数。  </p><p>回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><h1 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h1><p>1、回溯函数模板返回值以及参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span></span><br></pre></td></tr></table></figure><p>2、终止条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">    存放结果;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、回溯搜索的遍历过程</p><p>1444</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">    回溯，撤销处理结果;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。<br>backtracking是自己调用自己，实现递归。</p><p>综上，回溯算法的模板框架如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例子全排列"><a href="#例子：全排列" class="headerlink" title="例子：全排列"></a>例子：全排列</h2><p>题目：给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。<br>输入：nums &#x3D; [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p><p>抽象成树形结构如下：<br>3974</p><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">// 用来存放符合条件结果</span></span><br><span class="line">    <span class="type">boolean</span>[] isVisited;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        backTracking(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历当前数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            <span class="keyword">if</span> (isVisited[i]) &#123;  <span class="keyword">continue</span>;&#125;  <span class="comment">// 跳过已排列的元素</span></span><br><span class="line">            isVisited[i] = <span class="literal">true</span>; <span class="comment">// 标记当前位置元素是否已排列</span></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            backTracking(nums);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">            isVisited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩展</strong>：给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();  <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  <span class="comment">// 存放符合条件结果</span></span><br><span class="line">    Set&lt;Integer&gt; distNums;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 计数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; dict = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;dict.put(num, dict.getOrDefault(num, <span class="number">0</span>)+<span class="number">1</span>);&#125;</span><br><span class="line">        <span class="comment">// 唯一出现的数字</span></span><br><span class="line">        distNums = dict.keySet();</span><br><span class="line">        backTracking(nums,dict);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums,Map&lt;Integer, Integer&gt; dict)</span> &#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历所有数字（去重后的）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : distNums) &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            <span class="keyword">if</span> (dict.get(num) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                path.add(num);</span><br><span class="line">                dict.put(num, dict.get(num) - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                backTracking(nums, dict);</span><br><span class="line">                <span class="comment">// 回溯</span></span><br><span class="line">                dict.put(num, dict.get(num) + <span class="number">1</span>);</span><br><span class="line">                path.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 时间复杂度O(n^2)，空间复杂度O(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例子活字印刷"><a href="#例子：活字印刷" class="headerlink" title="例子：活字印刷"></a>例子：活字印刷</h1><p>题目：你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。<br>输入：”AAB”<br>输出：8  </p><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTilePossibilities</span><span class="params">(String tiles)</span> &#123;</span><br><span class="line">        <span class="comment">// 统计字符个数</span></span><br><span class="line">        Map&lt;Character, Integer&gt; dict = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : tiles.toCharArray()) &#123;</span><br><span class="line">            dict.put(c, dict.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Character&gt; tile=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(dict.keySet());</span><br><span class="line">        <span class="keyword">return</span> dfs(tiles.length(),dict,tile)-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, Map&lt;Character, Integer&gt; dict, Set&lt;Character&gt; tile)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归终止条件，字符用完了</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历当前dict中value大于0的字符（去重后的）</span></span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : tile) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dict.get(c) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dict.put(c, dict.get(c) - <span class="number">1</span>);</span><br><span class="line">                res += dfs(i - <span class="number">1</span>, dict, tile);</span><br><span class="line">                dict.put(c, dict.get(c) + <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 时间复杂度O(n * n!)，空间复杂度O(∑)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E5%A4%A7%E7%BA%B2%E5%A6%82%E4%B8%8B">代码随想录之回溯算法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是回溯算法&quot;&gt;&lt;a href=&quot;#什么是回溯算法&quot; class=&quot;headerlink&quot; title=&quot;什么是回溯算法&quot;&gt;&lt;/a&gt;什么是回溯算法&lt;/h1&gt;&lt;p&gt;回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，回溯函数也就是递归函数。  &lt;/</summary>
      
    
    
    
    <category term="练习笔记" scheme="https://llye-hub.github.io/categories/%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="LeetCode" scheme="https://llye-hub.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>hiveSQL之深入理解视图</title>
    <link href="https://llye-hub.github.io/posts/2dfa544e.html"/>
    <id>https://llye-hub.github.io/posts/2dfa544e.html</id>
    <published>2023-05-17T01:58:48.000Z</published>
    <updated>2023-05-23T01:49:28.599Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="4f2fa0670b869d791d182abfc78a3015284ac2f7c4e7e7841f52957474817890">0ae7e196f2221a75e5346dcbb7e124f3a273828722568f616125477033531497</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是一篇加密文章，需要密码才能继续阅读。</summary>
    
    
    
    <category term="对照文件存放的目录名称" scheme="https://llye-hub.github.io/categories/%E5%AF%B9%E7%85%A7%E6%96%87%E4%BB%B6%E5%AD%98%E6%94%BE%E7%9A%84%E7%9B%AE%E5%BD%95%E5%90%8D%E7%A7%B0/"/>
    
    
    <category term="文章内容的关键词" scheme="https://llye-hub.github.io/tags/%E6%96%87%E7%AB%A0%E5%86%85%E5%AE%B9%E7%9A%84%E5%85%B3%E9%94%AE%E8%AF%8D/"/>
    
    <category term="private" scheme="https://llye-hub.github.io/tags/private/"/>
    
  </entry>
  
  <entry>
    <title>hive之常用元数据表</title>
    <link href="https://llye-hub.github.io/posts/b06ccdfe.html"/>
    <id>https://llye-hub.github.io/posts/b06ccdfe.html</id>
    <published>2023-05-16T03:30:36.000Z</published>
    <updated>2023-11-08T04:05:15.051Z</updated>
    
    <content type="html"><![CDATA[<p>hive元数据信息通常存储在关系型数据库，常见的是MySQL数据库。hive元数据信息存储在MySQL库的57张表中。<br>61</p><h1 id="存储hive版本的元数据表version"><a href="#存储Hive版本的元数据表（VERSION）" class="headerlink" title="存储Hive版本的元数据表（VERSION）"></a>存储Hive版本的元数据表（VERSION）</h1><table><thead><tr><th>VER_ID</th><th>SCHEMA_VERSION</th><th>VERSION_COMMENT</th></tr></thead><tbody><tr><td>1</td><td>2.3.0</td><td>Hive release version 2.3.0</td></tr></tbody></table><p>该表比较重要，如果出现问题，根本进入不了Hive-Cli。比如该表不存在，当启动Hive-Cli时候，就会报错”Table ‘hive.version’ doesn’t exist”。</p><h1 id="hive数据库相关的元数据表dbs-database_params"><a href="#Hive数据库相关的元数据表（DBS、DATABASE-PARAMS）" class="headerlink" title="Hive数据库相关的元数据表（DBS、DATABASE_PARAMS）"></a>Hive数据库相关的元数据表（DBS、DATABASE_PARAMS）</h1><h2 id="dbs"><a href="#DBS" class="headerlink" title="DBS"></a>DBS</h2><p>DBS表存储的是hive中所有库的基本信息</p><table><thead><tr><th>DB_ID</th><th>DESC</th><th>DB_LOCATION_URI</th><th>NAME</th><th>OWNER_NAME</th><th>OWNER_TYPE</th></tr></thead><tbody><tr><td>1</td><td>Default Hive database</td><td>hdfs:&#x2F;&#x2F;localhost:8020&#x2F;user&#x2F;hive&#x2F;warehouse</td><td>default</td><td>public</td><td>ROLE</td></tr><tr><td>6</td><td></td><td>hdfs:&#x2F;&#x2F;localhost:8020&#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;test.db</td><td>test</td><td>llye</td><td>USER</td></tr></tbody></table><h2 id="database_params"><a href="#DATABASE-PARAMS" class="headerlink" title="DATABASE_PARAMS"></a>DATABASE_PARAMS</h2><p>DATABASE_PARAMS表存储数据库的相关参数，在CREATE DATABASE时候用<code>WITH DBPROPERTIES(property_name=property_value, …)</code>指定的参数。</p><p>表字段有：<code>DB_ID</code>、<code>PARAM_KEY</code>、<code>PARAM_VALUE</code></p><h1 id="hive表和视图相关的元数据表tbls-table_params-tbl_privs"><a href="#Hive表和视图相关的元数据表（TBLS、TABLE-PARAMS、TBL-PRIVS）" class="headerlink" title="Hive表和视图相关的元数据表（TBLS、TABLE_PARAMS、TBL_PRIVS）"></a>Hive表和视图相关的元数据表（TBLS、TABLE_PARAMS、TBL_PRIVS）</h1><h2 id="tbls"><a href="#TBLS" class="headerlink" title="TBLS"></a>TBLS</h2><p>TBLS表存储了表&#x2F;视图的基本信息，表字段有：<code>TBL_ID </code>、<code>CREATE_TIME </code>、<code>DB_ID</code>、<code>LAST_ACCESS_TIME</code>(上次访问时间)、<code>OWNER</code>、<code>RETENTION</code>(保留字段)、<code>SD_ID</code>(序列化配置信息)、<code>TBL_NAME</code>、<code>TBL_TYPE</code>、<code>VIEW_EXPANDED_TEXT</code>(视图的详细HQL语句)、<code>VIEW_ORIGINAL_TEXT</code>(视图的原始HQL语句)。</p><table><thead><tr><th>TBL_ID</th><th>CREATE_TIME</th><th>DB_ID</th><th>LAST_ACCESS_TIME</th><th>OWNER</th><th>RETENTION</th><th>SD_ID</th><th>TBL_NAME</th><th>TBL_TYPE</th><th>VIEW_EXPANDED_TEXT</th><th>VIEW_ORIGINAL_TEXT</th><th>IS_REWRITE_ENABLED</th></tr></thead><tbody><tr><td>2</td><td>1678874852</td><td>1</td><td>0</td><td>llye</td><td>0</td><td>2</td><td>student</td><td>MANAGED_TABLE</td><td></td><td></td><td>0</td></tr><tr><td>13</td><td>1683273717</td><td>6</td><td>0</td><td>llye</td><td>0</td><td>13</td><td>travel_data</td><td>MANAGED_TABLE</td><td></td><td></td><td>0</td></tr><tr><td>16</td><td>1684216889</td><td>1</td><td>0</td><td>llye</td><td>0</td><td>16</td><td>test_query</td><td>VIRTUAL_VIEW</td><td>(¶select¶`travel_data`.`province`, `travel_data`.`city`, `travel_data`.`attraction`, `travel_data`.`star_level`, `travel_data`.`price`, `travel_data`.`sales`, `travel_data`.`sale_date`¶from¶ `test`.`travel_data`)</td><td>(¶select¶ *¶from¶ test.travel_data)</td><td>0</td></tr></tbody></table><h2 id="table_params"><a href="#TABLE-PARAMS" class="headerlink" title="TABLE_PARAMS"></a>TABLE_PARAMS</h2><p>TABLE_PARAMS表存储了表&#x2F;视图的属性信息，表字段有：<code>TBL_ID</code>、<code>PARAM_KEY</code>(totalSize,numRows,EXTERNAL)、<code>PARAM_VALUE</code></p><table><thead><tr><th>TBL_ID</th><th>PARAM_KEY</th><th>PARAM_VALUE</th></tr></thead><tbody><tr><td>2</td><td>COLUMN_STATS_ACCURATE</td><td>{“BASIC_STATS”:”true”}</td></tr><tr><td>2</td><td>numFiles</td><td>1</td></tr><tr><td>2</td><td>numRows</td><td>1</td></tr><tr><td>2</td><td>rawDataSize</td><td>5</td></tr><tr><td>2</td><td>totalSize</td><td>6</td></tr><tr><td>2</td><td>transient_lastDdlTime</td><td>1678874879</td></tr><tr><td>13</td><td>COLUMN_STATS_ACCURATE</td><td>{“BASIC_STATS”:”true”}</td></tr><tr><td>13</td><td>numFiles</td><td>1</td></tr><tr><td>13</td><td>numRows</td><td>11</td></tr><tr><td>13</td><td>rawDataSize</td><td>597</td></tr><tr><td>13</td><td>totalSize</td><td>608</td></tr><tr><td>13</td><td>transient_lastDdlTime</td><td>1683273753</td></tr><tr><td>16</td><td>transient_lastDdlTime</td><td>1684216889</td></tr></tbody></table><h2 id="tbl_privs"><a href="#TBL-PRIVS" class="headerlink" title="TBL_PRIVS"></a>TBL_PRIVS</h2><p>TBL_PRIVS表存储了表&#x2F;视图的授权信息，表字段有：<code>TBL_GRANT_ID</code>、<code>CREATE_TIME</code>、<code>GRANT_OPTION</code>、<code>GRANTOR</code>(授权执行用户)、<code>GRANTOR_TYPE</code>、<code>PRINCIPAL_NAME</code>(被授权用户)、<code>PRINCIPAL_TYPE</code>、<code>TBL_PRIV</code>、<code>TBL_ID</code></p><table><thead><tr><th>TBL_GRANT_ID</th><th>CREATE_TIME</th><th>GRANT_OPTION</th><th>GRANTOR</th><th>GRANTOR_TYPE</th><th>PRINCIPAL_NAME</th><th>PRINCIPAL_TYPE</th><th>TBL_PRIV</th><th>TBL_ID</th></tr></thead><tbody><tr><td>5</td><td>1678874852</td><td>1</td><td>llye</td><td>USER</td><td>llye</td><td>USER</td><td>INSERT</td><td>2</td></tr><tr><td>6</td><td>1678874852</td><td>1</td><td>llye</td><td>USER</td><td>llye</td><td>USER</td><td>SELECT</td><td>2</td></tr><tr><td>7</td><td>1678874852</td><td>1</td><td>llye</td><td>USER</td><td>llye</td><td>USER</td><td>UPDATE</td><td>2</td></tr><tr><td>8</td><td>1678874852</td><td>1</td><td>llye</td><td>USER</td><td>llye</td><td>USER</td><td>DELETE</td><td>2</td></tr><tr><td>39</td><td>1683273717</td><td>1</td><td>llye</td><td>USER</td><td>llye</td><td>USER</td><td>INSERT</td><td>13</td></tr><tr><td>40</td><td>1683273717</td><td>1</td><td>llye</td><td>USER</td><td>llye</td><td>USER</td><td>SELECT</td><td>13</td></tr><tr><td>41</td><td>1683273717</td><td>1</td><td>llye</td><td>USER</td><td>llye</td><td>USER</td><td>UPDATE</td><td>13</td></tr><tr><td>42</td><td>1683273717</td><td>1</td><td>llye</td><td>USER</td><td>llye</td><td>USER</td><td>DELETE</td><td>13</td></tr><tr><td>46</td><td>1684216889</td><td>1</td><td>llye</td><td>USER</td><td>llye</td><td>USER</td><td>INSERT</td><td>16</td></tr><tr><td>47</td><td>1684216889</td><td>1</td><td>llye</td><td>USER</td><td>llye</td><td>USER</td><td>SELECT</td><td>16</td></tr><tr><td>48</td><td>1684216889</td><td>1</td><td>llye</td><td>USER</td><td>llye</td><td>USER</td><td>UPDATE</td><td>16</td></tr><tr><td>49</td><td>1684216889</td><td>1</td><td>llye</td><td>USER</td><td>llye</td><td>USER</td><td>DELETE</td><td>16</td></tr></tbody></table><h1 id="hive文件存储信息相关的元数据表sds-sd_params-serdes-serde_params"><a href="#Hive文件存储信息相关的元数据表（SDS、SD-PARAMS、SERDES、SERDE-PARAMS）" class="headerlink" title="Hive文件存储信息相关的元数据表（SDS、SD_PARAMS、SERDES、SERDE_PARAMS）"></a>Hive文件存储信息相关的元数据表（SDS、SD_PARAMS、SERDES、SERDE_PARAMS）</h1><p>由于HDFS支持的文件格式很多，而建Hive表时候也可以指定各种文件格式，Hive在将HQL解析成MapReduce时候，需要知道去哪里，使用哪种格式去读写HDFS文件，而这些信息就保存在这几张表中。</p><h2 id="sds"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><p>SDS表保存文件存储的基本信息，如INPUT_FORMAT、OUTPUT_FORMAT、是否压缩等。TBLS表中的SD_ID与该表关联，可以获取Hive表的存储信息。</p><p>表字段有：<code>SD_ID</code>、<code>CD_ID</code>(字段信息id)、<code>INPUT_FORMAT</code>(文件输入格式)、<code>IS_COMPRESSED</code>(是否压缩)、<code>IS_STOREDASSUBDIRECTORIES</code>(是否以子目录存储)、<code>LOCATION</code>(HDFS路径)、<code>NUM_BUCKETS</code>(分桶数量)、<code>OUTPUT_FORMAT</code>(文件输出格式)、<code>SERDE_ID</code>(序列化类id)。</p><table><thead><tr><th>SD_ID</th><th>CD_ID</th><th>INPUT_FORMAT</th><th>IS_COMPRESSED</th><th>IS_STOREDASSUBDIRECTORIES</th><th>LOCATION</th><th>NUM_BUCKETS</th><th>OUTPUT_FORMAT</th><th>SERDE_ID</th></tr></thead><tbody><tr><td>2</td><td>2</td><td>org.apache.hadoop.mapred.TextInputFormat</td><td>0</td><td>0</td><td>hdfs:&#x2F;&#x2F;localhost:8020&#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;student</td><td>-1</td><td>org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat</td><td>2</td></tr><tr><td>13</td><td>13</td><td>org.apache.hadoop.mapred.TextInputFormat</td><td>0</td><td>0</td><td>hdfs:&#x2F;&#x2F;localhost:8020&#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;test.db&#x2F;travel_data</td><td>-1</td><td>org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat</td><td>13</td></tr><tr><td>16</td><td>16</td><td>org.apache.hadoop.mapred.TextInputFormat</td><td>0</td><td>0</td><td>NULL</td><td>-1</td><td>org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat</td><td>16</td></tr></tbody></table><h2 id="sd_params"><a href="#SD-PARAMS" class="headerlink" title="SD_PARAMS"></a>SD_PARAMS</h2><p>SD_PARAMS表保存Hive存储的属性信息，在创建表时候使用<code>STORED BY ‘storage.handler.class.name’ [WITH SERDEPROPERTIES (…)</code>指定。</p><p>表字段有：<code>SD_ID</code>、<code>PARAM_KEY</code>、<code>PARAM_VALUE</code></p><h2 id="serdes"><a href="#SERDES" class="headerlink" title="SERDES"></a>SERDES</h2><p>SERDES表存储序列化使用的类信息</p><p>表字段有：<code>SERDE_ID</code>、<code>NAME</code>(序列化类别名)、<code>SLIB</code>(序列化类)。</p><table><thead><tr><th>SERDE_ID</th><th>NAME</th><th>SLIB</th></tr></thead><tbody><tr><td>2</td><td>NULL</td><td>org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe</td></tr><tr><td>13</td><td>NULL</td><td>org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe</td></tr><tr><td>16</td><td>NULL</td><td>NULL</td></tr></tbody></table><h2 id="serde_params"><a href="#SERDE-PARAMS" class="headerlink" title="SERDE_PARAMS"></a>SERDE_PARAMS</h2><p>SERDE_PARAMS表存储了hive表序列化的一些属性信息，比如:行、列分隔符</p><p>表字段有：<code>SERDE_ID</code>、<code>PARAM_KEY</code>、<code>PARAM_VALUE</code></p><table><thead><tr><th>SERDE_ID</th><th>PARAM_KEY</th><th>PARAM_VALUE</th></tr></thead><tbody><tr><td>2</td><td>serialization.format</td><td>1</td></tr><tr><td>13</td><td>serialization.format</td><td>1</td></tr></tbody></table><h1 id="hive表字段相关的元数据表columns_v2"><a href="#Hive表字段相关的元数据表（COLUMNS-V2）" class="headerlink" title="Hive表字段相关的元数据表（COLUMNS_V2）"></a>Hive表字段相关的元数据表（COLUMNS_V2）</h1><p>COLUMNS_V2表存储了hive表各字段的基本信息。</p><p>表字段有：<code>CD_ID</code>、<code>COMMENT</code>、<code>COLUMN_NAME</code>、<code>TYPE_NAME</code>(字段类型)、<code>INTEGER_IDX</code>(字段顺序)。</p><table><thead><tr><th>CD_ID</th><th>COMMENT</th><th>COLUMN_NAME</th><th>TYPE_NAME</th><th>INTEGER_IDX</th></tr></thead><tbody><tr><td>2</td><td>NULL</td><td>id</td><td>int</td><td>0</td></tr><tr><td>2</td><td>NULL</td><td>name</td><td>string</td><td>1</td></tr><tr><td>13</td><td>NULL</td><td>attraction</td><td>string</td><td>2</td></tr><tr><td>13</td><td>NULL</td><td>city</td><td>string</td><td>1</td></tr><tr><td>13</td><td>NULL</td><td>price</td><td>double</td><td>4</td></tr><tr><td>13</td><td>NULL</td><td>province</td><td>string</td><td>0</td></tr><tr><td>13</td><td>NULL</td><td>sale_date</td><td>string</td><td>6</td></tr><tr><td>13</td><td>NULL</td><td>sales</td><td>int</td><td>5</td></tr><tr><td>13</td><td>NULL</td><td>star_level</td><td>int</td><td>3</td></tr><tr><td>16</td><td>NULL</td><td>attraction</td><td>string</td><td>2</td></tr><tr><td>16</td><td>NULL</td><td>city</td><td>string</td><td>1</td></tr><tr><td>16</td><td>NULL</td><td>price</td><td>double</td><td>4</td></tr><tr><td>16</td><td>NULL</td><td>province</td><td>string</td><td>0</td></tr><tr><td>16</td><td>NULL</td><td>sale_date</td><td>string</td><td>6</td></tr><tr><td>16</td><td>NULL</td><td>sales</td><td>int</td><td>5</td></tr><tr><td>16</td><td>NULL</td><td>star_level</td><td>int</td><td>3</td></tr></tbody></table><h1 id="hive表分区相关的元数据表partitions-partition_keys-partition_key_vals-partition_params"><a href="#Hive表分区相关的元数据表（PARTITIONS、PARTITION-KEYS、PARTITION-KEY-VALS、PARTITION-PARAMS）" class="headerlink" title="Hive表分区相关的元数据表（PARTITIONS、PARTITION_KEYS、PARTITION_KEY_VALS、PARTITION_PARAMS）"></a>Hive表分区相关的元数据表（PARTITIONS、PARTITION_KEYS、PARTITION_KEY_VALS、PARTITION_PARAMS）</h1><h2 id="partitions"><a href="#PARTITIONS" class="headerlink" title="PARTITIONS"></a>PARTITIONS</h2><p>PARTITIONS表存储hive表分区的基本信息。</p><p>表字段有：<code>PART_ID</code>、<code>CREATE_TIME</code>、<code>LAST_ACCESS_TIME</code>、<code>PART_NAME</code>、<code>SD_ID</code>(分区存储ID)、<code>TBL_ID</code>、<code>LINK_TARGET_ID</code>。</p><table><thead><tr><th>PART_ID</th><th>CREATE_TIME</th><th>LAST_ACCESS_TIME</th><th>PART_NAME</th><th>SD_ID</th><th>TBL_ID</th></tr></thead><tbody><tr><td>1</td><td>1684221232</td><td>0</td><td>dt&#x3D;1</td><td>18</td><td>17</td></tr><tr><td>2</td><td>1684221294</td><td>0</td><td>dt&#x3D;2</td><td>19</td><td>17</td></tr></tbody></table><h2 id="partition_keys"><a href="#PARTITION-KEYS" class="headerlink" title="PARTITION_KEYS"></a>PARTITION_KEYS</h2><p>PARTITION_KEYS表存储hive表分区的字段信息。</p><p>表字段有：<code>TBL_ID</code>、<code>PKEY_COMMENT</code>、<code>PKEY_NAME</code>、<code>PKEY_TYPE</code>、<code>INTEGER_IDX</code>(分区字段顺序)。</p><table><thead><tr><th>TBL_ID</th><th>PKEY_COMMENT</th><th>PKEY_NAME</th><th>PKEY_TYPE</th><th>INTEGER_IDX</th></tr></thead><tbody><tr><td>17</td><td>NULL</td><td>dt</td><td>string</td><td>0</td></tr></tbody></table><h2 id="partition_key_vals"><a href="#PARTITION-KEY-VALS" class="headerlink" title="PARTITION_KEY_VALS"></a>PARTITION_KEY_VALS</h2><p>PARTITION_KEY_VALS表存储hive表分区字段值。</p><p>表字段有：<code>PART_ID</code>、<code>PART_KEY_VAL</code>(分区字段值)、<code>INTEGER_IDX</code>(分区字段值顺序)。</p><table><thead><tr><th>PART_ID</th><th>PART_KEY_VAL</th><th>INTEGER_IDX</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td></tr><tr><td>2</td><td>2</td><td>0</td></tr></tbody></table><h2 id="partition_params"><a href="#PARTITION-PARAMS" class="headerlink" title="PARTITION_PARAMS"></a>PARTITION_PARAMS</h2><p>PARTITIONS表存储hive表分区的属性信息。</p><p>表字段有：<code>PART_ID</code>、<code>PARAM_KEY</code>(numFiles，numRows)、<code>PARAM_VALUE</code>。</p><table><thead><tr><th>PART_ID</th><th>PARAM_KEY</th><th>PARAM_VALUE</th></tr></thead><tbody><tr><td>1</td><td>COLUMN_STATS_ACCURATE</td><td>{“BASIC_STATS”:”true”}</td></tr><tr><td>1</td><td>numFiles</td><td>1</td></tr><tr><td>1</td><td>numRows</td><td>11</td></tr><tr><td>1</td><td>rawDataSize</td><td>4290</td></tr><tr><td>1</td><td>totalSize</td><td>1221</td></tr><tr><td>1</td><td>transient_lastDdlTime</td><td>1684221233</td></tr><tr><td>2</td><td>COLUMN_STATS_ACCURATE</td><td>{“BASIC_STATS”:”true”}</td></tr><tr><td>2</td><td>numFiles</td><td>1</td></tr><tr><td>2</td><td>numRows</td><td>4</td></tr><tr><td>2</td><td>rawDataSize</td><td>1564</td></tr><tr><td>2</td><td>totalSize</td><td>1040</td></tr><tr><td>2</td><td>transient_lastDdlTime</td><td>1684221294</td></tr></tbody></table><h1 id="其他不常用的元数据表"><a href="#其他不常用的元数据表" class="headerlink" title="其他不常用的元数据表"></a>其他不常用的元数据表</h1><p>DB_PRIVS：数据库权限信息表。通过GRANT语句对数据库授权后，将会在这里存储。<br>IDXS：索引表，存储Hive索引相关的元数据。<br>INDEX_PARAMS：索引相关的属性信息。<br>TBL_COL_STATS：表字段的统计信息。使用ANALYZE语句对表字段分析后记录在这里。<br>TBL_COL_PRIVS：表字段的授权信息。<br>PART_PRIVS：分区的授权信息。<br>PART_COL_PRIVS：分区字段的权限信息。<br>PART_COL_STATS：分区字段的统计信息。<br>FUNCS：用户注册的函数信息。<br>FUNC_RU：用户注册函数的资源信息。<br>……  </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3ODUxMzQxMA==&mid=2663993556&idx=1&sn=0e5291bd63426d747f32a7fd05128caa&scene=21#wechat_redirect">Hive 元数据表结构详解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hive元数据信息通常存储在关系型数据库，常见的是MySQL数据库。hive元数据信息存储在MySQL库的57张表中。&lt;br&gt;61&lt;/p&gt;
&lt;h1 id=&quot;存储hive版本的元数据表version&quot;&gt;&lt;a href=&quot;#存储Hive版本的元数据表（VERSION）&quot; cla</summary>
      
    
    
    
    <category term="hive" scheme="https://llye-hub.github.io/categories/hive/"/>
    
    
    <category term="hive元数据" scheme="https://llye-hub.github.io/tags/hive%E5%85%83%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>算法性能分析之时间和空间复杂度</title>
    <link href="https://llye-hub.github.io/posts/d1fda56a.html"/>
    <id>https://llye-hub.github.io/posts/d1fda56a.html</id>
    <published>2023-05-12T07:42:59.000Z</published>
    <updated>2023-06-28T02:03:26.123Z</updated>
    
    <content type="html"><![CDATA[<p>关于时间复杂度和空间复杂度，刷过一些算法题后多少知道一点，比如单层for循环的时间复杂度为O(n)、数组变量的空间复杂度为O(n)，但是提到大O是什么就说不清了，而且涉及到一些复杂代码时，也说不清时间和空间复杂度。</p><p>首先解释下，这里<strong>大O用来表示算法的一般执行性能</strong>，大多情况下，它是算法的最坏情况下的执行性能，比如：插入排序的时间复杂度都说是O(n^2)。</p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>时间复杂度是一个函数，它定性描述该算法的运行时间。更详细的解释可以参见<a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%81.html#%E7%A9%B6%E7%AB%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">这篇文章</a>  </p><p>大数据规模的情况下，算法时间复杂度的排行如下：  </p><blockquote><p>O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(nlogn)线性对数阶 &lt; O(n^2)平方阶 &lt; O(n^3)立方阶 &lt; O(2^n)指数阶</p></blockquote><p><strong>举一个例子：</strong> 找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）</p><p><strong>解法一：暴力枚举</strong><br>双层遍历所有字符串比较，一般可能认为时间复杂度为O(n^2)。但其实这里忽略了字符串比较的时间消耗，因为字符串比较是按字典序逐位比较，长度为m的字符串比较的时间复杂度为O(m)，所以暴力枚举的时间复杂度应该是O(m×n×n)。</p><p><strong>解法二：所有字符串排序后遍历</strong><br>先对n个字符串按字典序进行排序，排序后相同的两个字符串一定是挨着的，只要再遍历一遍n个字符串就能找到。</p><p>如果用快速排序算法，再加上长度为m的字符串比较，排序步骤的时间复杂度为O(m×nlogn)，遍历步骤的时间复杂度为O(m×n)，所以总的时间复杂度为O(m×nlogn + m×n)，简化后的时间复杂度为O(m×nlogn)。</p><p>很明显O(m×nlogn)是要优于O(m×n×n)的。</p><p><strong>强调下上面两种解法仅做时间复杂度说明，非题目最佳解。</strong></p><p><strong>递归算法的时间复杂度：</strong> 本质上是 <strong>递归的次数 * 每次递归中的操作次数</strong> 。</p><p>比如题目：求x的n次方，用for循环的解法时间复杂度是O(n)，那么如果用递归写法呢？一定是O(logn)吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">function2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// return 1 同样是因为0次方是等于1的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> function2(x, n - <span class="number">1</span>) * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码层面看，递归了n次，每次进行乘法操作，所以上面代码的时间复杂度为O(n*1)&#x3D;O(n)，和for循环写法没有差别。那么O(logn)的实现应该是怎样的？</p><p>先看下面这段代码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">function3</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> function3(x, n / <span class="number">2</span>) * function3(x, n / <span class="number">2</span>)*x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> function3(x, n / <span class="number">2</span>) * function3(x, n / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中有两处递归调用。假设n&#x3D;16，将上面代码的计算过程抽象为二叉树效果如下：</p><p>3874</p><p>从图中可以看到，共有n-1个节点，也就是说做了n-1次乘法操作，所以时间复杂度还是O(n-1)&#x3D;O(n)。其实，只要再做个小改动就能实现时间复杂度O(logn)的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">function4</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line"><span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> function4(x, n / <span class="number">2</span>);<span class="comment">// 这里相对于function3，是把这个递归操作抽取出来，减少了重复计算</span></span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> t * t * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t * t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，仅有一个调用，且每次都是 n&#x2F;2，所以一共调用了 log以2为底n的对数次，再着每次递归做了一次乘法操作，所以时间复杂度为O(logn*1)&#x3D;O(logn)。</p><h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>空间复杂度是一个算法在运行过程中占用内存空间大小的量度，利用程序的空间复杂度，可以对程序运行中需要多少内存有个预先估计。空间复杂度(Space Complexity)记作 S(n) 依然使用大O来表示。递归算法的空间复杂度 &#x3D; 每次递归的空间复杂度 * 递归深度</p><p>常量的空间复杂度为O(1)，一维数组的空间复杂度为O(n)，二维数组的空间复杂度为O(n^2)……</p><p>那么，什么情况下，空间复杂度会是O(logn)呢？情况特殊些，一般出现在递归算法中。</p><p><strong>举例分析：斐波那契数列</strong></p><p>常规写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(i &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> fibonacci(i-<span class="number">1</span>) + fibonacci(i-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设i&#x3D;5，计算过程抽象为二叉树效果如下：</p><p>7031</p><p>每次递归中需要的空间是一个常量，并不会随着n的变化而变化，每次递归的空间复杂度就是O(1)。递归第n个斐波那契数的话，递归调用栈的深度是n。所以，上面代码的空间复杂度为O(1*n)&#x3D;O(n)。</p><p>根据树的结点来看，时间复杂度为O(2^n)，随着n的增大，计算时间消耗呈指数上升，这样的性能是最差的。究其原因，代码中调用了2次递归，导致复杂度非常大，从这个角度，可以做如下优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> second, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> first + second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fibonacci(second, first + second, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中用两个常量来记录当前相加的两个数值，仅有一次递归调用，时间复杂度为O(n)。  </p><p>因为递归的深度依然是n，每次递归所需的空间也是常数，所以空间复杂度依然是O(n)。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://programmercarl.com/">算法性能分析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于时间复杂度和空间复杂度，刷过一些算法题后多少知道一点，比如单层for循环的时间复杂度为O(n)、数组变量的空间复杂度为O(n)，但是提到大O是什么就说不清了，而且涉及到一些复杂代码时，也说不清时间和空间复杂度。&lt;/p&gt;
&lt;p&gt;首先解释下，这里&lt;strong&gt;大O用来表示</summary>
      
    
    
    
    <category term="练习笔记" scheme="https://llye-hub.github.io/categories/%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo+GitHub自建博客遇到的问题</title>
    <link href="https://llye-hub.github.io/posts/69a95f3b.html"/>
    <id>https://llye-hub.github.io/posts/69a95f3b.html</id>
    <published>2023-05-08T06:48:01.000Z</published>
    <updated>2023-05-08T06:49:22.520Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_45149481/article/details/116794535">hexo文章目录点击不跳转，html没有生成href</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_45149481/article/details/116794535&quot;&gt;hexo文章目录点击不跳转，html没有生成href&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://llye-hub.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hiveSQL之理解explain参数</title>
    <link href="https://llye-hub.github.io/posts/2369b6cf.html"/>
    <id>https://llye-hub.github.io/posts/2369b6cf.html</id>
    <published>2023-05-08T03:16:49.000Z</published>
    <updated>2023-05-08T08:27:00.383Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Explain">hive官方文档说明</a></p><p><strong>关键字</strong> <code>EXPLAIN</code></p><p><strong>语法：</strong> <code>EXPLAIN [EXTENDED|DEPENDENCY|AUTHORIZATION|VECTORIZATION|ANALYZE] query</code>（<code>hive2.3.9</code>版本支持）  </p><ul><li>EXPLAIN EXTENDED是EXPLAIN的扩展，能展示更加详细的信息。除了EXPLAIN打印出的内容，还包括每个标的HDFS读取路径，每个HIVE表的配置信息等，可以查看出表是否被全表扫描。</li><li>EXPLAIN DEPENDENCY用于描述一段sql需要的数据来源，输出的是一个json格式的数据，里面包含一下两个部分的内容，<br>input_partitions：描述一段sql依赖的数据来源表分区，里面存储的分区名的列表，格式如下：<br>{“partitionname”:“库名@表名 @分区列&#x3D;分区列的值”} ，如果整段sql包含的所有表都是是非分区表，则显示为空。<br>input_table：描述一段sql依赖的数据来源表，里面存储的是HIVE表名的列表格式如下：<br>{“tablename”:“库名@表名 ”，“tabletype”：表的类型（外部表&#x2F;内部表）}</li><li>EXPLAIN ANALYZE是EXPLAIN的扩展。EXPLAIN的信息中标示的是预估扫描行数，EXPLAIN ANALYZE但展示信息中也标示了实际扫描行数，格式为：<code>Num rows: (estimated row count)/(actual row count)</code></li></ul><p>**执行计划包含三部分内容: **</p><ul><li>查询sql的抽象语法树</li><li>所有stage之间的依赖关系</li><li>每个stage的具体描述</li></ul><p><strong>参数解释</strong></p><ul><li><p>MapReduce: 表示当前任务执行所用的计算机引擎是MapReduce  </p></li><li><p>Map Operator Tree: 表示当前描述的Map阶段执行的操作信息。</p><ul><li>TableScan: 表示对关键字alias声明的结果集。这里代指表明。</li><li>Statistics: 表示对当前阶段的统计信息。例如数据行数和数据量，这两个都是预估值。</li><li>Filter Operator: 表示在之前操作（TableScan）的结果集上进行数据的过滤。</li><li>Predicate: 表示Filter Operator进行过滤时候使用的谓词，例如 pt_dt &#x3D; 2020-11-11</li><li>Select Operator: 表示在之前的结果集上对列进行投影，即列筛选。<ul><li>Expressions: 表示需要投影的列，即筛选的列。</li><li>OutputColNames: 表示输出的列名。</li><li>Group By Operator: 表示在之前的结果集上分组聚合。<ul><li>keys: 表示分组的列。</li><li>mode[aggregations]: 表示分组聚合使用的算法.例如 count（）。</li><li>Reduce Output Operator: 表示当前描述的是对之前的结果聚合后的输出信息，这里表示Map端聚合后的信息。<ul><li>key expressions&#x2F;value expressions: MapReduce计算引擎，在Map阶段和Reduce阶段输出的都是键-值对的形式，这里key expression和 key expression 和 value expression 分别描述的就是Map阶段输出的键（key） 和值（value）所用的数据列。key expression指代的就是聚合列。 value expression 指代的就是 聚合的函数。</li><li>sort order：表示输出是否进行排序，每个<code>+</code>表示正序排序的一列，每个<code>-</code>表示倒序排序的一列。</li><li>Map-Reduce partition columns: 表示Map阶段输出到Reduce阶段的分区列。在HIVE-SQL中可以用distribute by 指代分区的列。</li></ul></li></ul></li></ul></li></ul></li><li><p>Reduce Operator Tree: 表示当前描述的Reduce阶段执行的操作信息。<br>  Reduce 阶段关键字和Map阶段的含义一样，不同的如下：</p></li><li><p>compressed: 在 File output operator中这个关键词表示文件输出的结果是否进行压缩，FALSE表示不进行输出压缩。</p></li><li><p>table: 表示正在操作的表。</p></li><li><p>input format&#x2F;out putformat: 分别表示文件输入和输出的文件类型。</p></li><li><p>serde:表示读取表数据的序列化和反序列化的方式。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Explain&quot;&gt;hive官方文档说明&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt; &lt;code&gt;EXPLAI</summary>
      
    
    
    
    <category term="hive" scheme="https://llye-hub.github.io/categories/hive/"/>
    
    
    <category term="hiveSQL" scheme="https://llye-hub.github.io/tags/hiveSQL/"/>
    
  </entry>
  
  <entry>
    <title>hiveSQL之groupBy语句增强语法grouping sets/CUBE/rollup</title>
    <link href="https://llye-hub.github.io/posts/67bc5d15.html"/>
    <id>https://llye-hub.github.io/posts/67bc5d15.html</id>
    <published>2023-05-05T06:01:45.000Z</published>
    <updated>2023-05-12T03:37:35.202Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细整理了关于group by子句的增强聚合语法grouping sets&#x2F;CUBE&#x2F;rollup的具体用法，语法的<a href="https://cwiki.apache.org/confluence/display/Hive/Enhanced+Aggregation%2C+Cube%2C+Grouping+and+Rollup">hive官方介绍文档</a> 。</p><h1 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h1><p>首先声明使用的hive版本为 <code>2.3.9</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> travel_data;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> travel_data(</span><br><span class="line">      province string,</span><br><span class="line">      city string,</span><br><span class="line">      attraction string,</span><br><span class="line">      star_level <span class="type">int</span>,</span><br><span class="line">      Price <span class="keyword">double</span>,</span><br><span class="line">      sales <span class="type">int</span>,</span><br><span class="line">      sale_date string</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> travel_data</span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;河南省&#x27;</span>,<span class="string">&#x27;郑州市&#x27;</span>,<span class="string">&#x27;方特&#x27;</span>,<span class="number">4</span>,<span class="number">312.22</span>,<span class="number">15789</span>,<span class="string">&#x27;2019-02-03&#x27;</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;河南省&#x27;</span>,<span class="string">&#x27;郑州市&#x27;</span>,<span class="string">&#x27;二七广场&#x27;</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">5942</span>,<span class="string">&#x27;2019-02-03&#x27;</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;河南省&#x27;</span>,<span class="string">&#x27;郑州市&#x27;</span>,<span class="string">&#x27;河南省博物馆&#x27;</span>,<span class="number">4</span>,<span class="number">1.22</span>,<span class="number">943</span>,<span class="string">&#x27;2019-02-03&#x27;</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;河南省&#x27;</span>,<span class="string">&#x27;洛阳市&#x27;</span>,<span class="string">&#x27;白云山&#x27;</span>,<span class="number">4</span>,<span class="number">324.44</span>,<span class="number">16843</span>,<span class="string">&#x27;2019-02-03&#x27;</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;河南省&#x27;</span>,<span class="string">&#x27;洛阳市&#x27;</span>,<span class="string">&#x27;白马寺&#x27;</span>,<span class="number">4</span>,<span class="number">23.45</span>,<span class="number">2567</span>,<span class="string">&#x27;2019-02-03&#x27;</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;河南省&#x27;</span>,<span class="string">&#x27;洛阳市&#x27;</span>,<span class="string">&#x27;龙门石窟&#x27;</span>,<span class="number">4</span>,<span class="number">45</span>,<span class="number">15784</span>,<span class="string">&#x27;2019-02-03&#x27;</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;广东省&#x27;</span>,<span class="string">&#x27;深圳市&#x27;</span>,<span class="string">&#x27;东部华侨城&#x27;</span>,<span class="number">4</span>,<span class="number">86</span>,<span class="number">9523</span>,<span class="string">&#x27;2019-02-03&#x27;</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;广东省&#x27;</span>,<span class="string">&#x27;深圳市&#x27;</span>,<span class="string">&#x27;欢乐谷&#x27;</span>,<span class="number">4</span>,<span class="number">54</span>,<span class="number">2573</span>,<span class="string">&#x27;2019-02-03&#x27;</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;广东省&#x27;</span>,<span class="string">&#x27;深圳市&#x27;</span>,<span class="string">&#x27;世界之窗&#x27;</span>,<span class="number">4</span>,<span class="number">34</span>,<span class="number">5644</span>,<span class="string">&#x27;2019-02-03&#x27;</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;广东省&#x27;</span>,<span class="string">&#x27;广州市&#x27;</span>,<span class="string">&#x27;长隆&#x27;</span>,<span class="number">4</span>,<span class="number">46</span>,<span class="number">25673</span>,<span class="string">&#x27;2019-02-03&#x27;</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;广东省&#x27;</span>,<span class="string">&#x27;广州市&#x27;</span>,<span class="string">&#x27;广州塔&#x27;</span>,<span class="number">4</span>,<span class="number">35</span>,<span class="number">9735</span>,<span class="string">&#x27;2019-02-03&#x27;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><h1 id="grouping-set语句"><a href="#grouping-set语句" class="headerlink" title="grouping set语句"></a>grouping set语句</h1><p>官方说明</p><blockquote><p>The GROUPING SETS clause in GROUP BY allows us to specify more than one GROUP BY option in the same record set. All GROUPING SET clauses can be logically expressed in terms of several GROUP BY queries connected by UNION. Table-1 shows several such equivalent statements. This is helpful in forming the idea of the GROUPING SETS clause. A blank set ( ) in the GROUPING SETS clause calculates the overall aggregate.</p></blockquote><p>grouping set子句可以实现对同一个数据集指定多个group by条件，适合多维聚合场景下使用。其执行效果等同于对多个group by查询进行union all操作。</p><p><code>SELECT a, b, SUM(c) FROM tab1 GROUP BY a, b GROUPING SETS ( (a,b) )</code>等同下面语句</p><blockquote><p>SELECT a, b, SUM(c) FROM tab1 GROUP BY a, b</p></blockquote><p><code>SELECT a, b, SUM( c ) FROM tab1 GROUP BY a, b GROUPING SETS ( (a, b), a, b, ( ) )</code>等同下面语句</p><blockquote><p>SELECT a, b, SUM( c ) FROM tab1 GROUP BY a, b<br>UNION<br>SELECT a, null, SUM( c ) FROM tab1 GROUP BY a, null<br>UNION<br>SELECT null, b, SUM( c ) FROM tab1 GROUP BY null, b<br>UNION<br>SELECT null, null, SUM( c ) FROM tab1</p></blockquote><p><strong>语法</strong></p><ol><li>grouping sets子句必须跟在group by语句后，且出现在grouping sets的字段必须出现在group by语句中，但是出现在group by中字段不一定要出现在grouping sets语句中</li><li>出现在group by中但是没有在grouping sets中的字段将会被赋值为null</li><li>grouping__id字段可以区分不同的聚合粒度，表示当前行数据数据哪个分组集合</li><li>grouping函数可以处理空值，grouping()接受一个列名作为参数，如果结果对应行使用了参数列做聚合，返回0，此时意味着NULL来自输入数据；否则返回1，此时意味着NULL是grouping sets的占位符。</li></ol><p><strong>测试sql：从省&amp;市聚合维度统计销售数量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    td.province,</span><br><span class="line">    td.city,</span><br><span class="line">    IF(<span class="keyword">grouping</span>(td.city) <span class="operator">=</span> <span class="number">0</span>,td.city,<span class="string">&#x27;城市&#x27;</span>) <span class="keyword">as</span> city2, <span class="comment">-- 进行空值判断，替换输出更有实际意义的值</span></span><br><span class="line">    <span class="built_in">sum</span>(sales) <span class="keyword">as</span> sales,</span><br><span class="line">    grouping__id</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    travel_data td</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">    td.province,</span><br><span class="line">    td.city</span><br><span class="line">    <span class="keyword">grouping</span> SETS (td.province,td.city)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> grouping__id</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>查询结果：</p><p>10289</p><ul><li>第一列按照province</li><li>第二列按照city</li><li>第三列按照city分组，并对空值进行替换</li><li>第四列按照province或city分组，进行统计计算</li><li>第五列grouping__id表示当前行数据属于哪个分组，1表示province，2表示city</li></ul><p><strong>测试sql：从省&amp;市、省&amp;日期、省三个聚合维度统计销售数量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">td.province ,</span><br><span class="line">td.city,</span><br><span class="line"><span class="built_in">sum</span>(sales) <span class="keyword">as</span> sales,</span><br><span class="line">td.sale_date ,</span><br><span class="line">grouping__id</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">travel_data td</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">td.province ,</span><br><span class="line">td.city,</span><br><span class="line">td.sale_date</span><br><span class="line"><span class="keyword">grouping</span> SETS (</span><br><span class="line">(td.province , td.city)</span><br><span class="line">,(td.province, td.sale_date)</span><br><span class="line">,td.province </span><br><span class="line">)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">grouping__id</span><br></pre></td></tr></table></figure><h1 id="cube语句"><a href="#CUBE语句" class="headerlink" title="CUBE语句"></a>CUBE语句</h1><p>CUBE函数跟group by语句一起使用，可以对group by的所有字段进行组合再进行聚合计算。</p><p><code>group by a,b,c with CUBE</code>执行效果等同于 <code>group by a, b, c grouping sets ( (a, b, c), (a, b), (b, c), (a, c), (a), (b), (c), ( ))</code></p><p><strong>测试sql</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    province ,</span><br><span class="line">    city,</span><br><span class="line">    <span class="built_in">sum</span>(sales) <span class="keyword">as</span> sales,</span><br><span class="line">    grouping__id</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    travel_data</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">    province,city</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">CUBE</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">    grouping__id</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或者下面这种写法</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    province ,</span><br><span class="line">    city,</span><br><span class="line">    <span class="built_in">sum</span>(sales) <span class="keyword">as</span> sales,</span><br><span class="line">    grouping__id</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    travel_data</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">    <span class="keyword">CUBE</span>(province,city)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">    grouping__id</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>查询结果：</p><p>15315</p><p>从上面的结果数据可以看到，对聚合字段 <code>(province,city)</code>使用CUBE函数后，返回结果有4种聚合维度：<code>(province,city)</code>、<code>(province)</code>、<code>(city)</code>、<code>()</code></p><h1 id="rollup语句"><a href="#rollup语句" class="headerlink" title="rollup语句"></a>rollup语句</h1><p>rollup是CUBE的子集，以最左侧的维度为主，从该维度进行层级聚合，可以实现上钻和下钻的效果</p><p><code>group by a,b,c with rollup</code>假设层次结构是 “a “向下钻到 “b “向下钻到 “c”，执行效果等同于 <code>group by a, b, c grouping sets ( (a, b, c), (a, b), (a), ( ))</code></p><p><strong>测试sql</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    province ,</span><br><span class="line">    city,</span><br><span class="line">    sale_date ,</span><br><span class="line">    <span class="built_in">sum</span>(sales) <span class="keyword">as</span> sales,</span><br><span class="line">    grouping__id</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    travel_data</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">    province,city,sale_date</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">rollup</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">    grouping__id</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或者下面这种写法</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">province ,</span><br><span class="line">city,</span><br><span class="line">sale_date ,</span><br><span class="line"><span class="built_in">sum</span>(sales) <span class="keyword">as</span> sales,</span><br><span class="line">grouping__id</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">travel_data </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line"><span class="keyword">rollup</span>(province,city,sale_date)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">grouping__id</span><br></pre></td></tr></table></figure><p>查询结果：</p><p>18451</p><p>从上面的结果数据可以看到，对聚合字段 <code>(province,city,sale_date)</code>使用rollup函数后，返回结果有4种聚合维度：<code>(province,city,sale_date)</code>、<code>(province,city)</code>、<code>(province)</code>、<code>()</code></p><h1 id="grouping__id计算方法"><a href="#grouping-id计算方法" class="headerlink" title="grouping__id计算方法"></a>grouping__id计算方法</h1><p>从rollup函数的例子可以看到，grouping__id的数值并不是连续的，下面总结下grouping__id计算方法</p><ol><li>按group by语句的字段顺序（不理解网上有说法是按字段倒序排序）。所以这里要注意groupby字段顺序变化是会影响grouping__id计算结果的。</li><li>对于每个字段，若出现在了当前粒度中，则该字段位置赋值为0，否则为1。</li><li>这样就形成了一个二进制数，将这个二进制数转为十进制，即为当前粒度对应的 grouping__id。</li></ol><p>以统计粒度 <code>group by province,city,sale_date</code>为例，</p><ul><li>字段顺序为:province,city,sale_date</li><li>所有聚合维度对应的二进制数为：</li></ul><table><thead><tr><th align="center">grouping sets</th><th align="center">按字段顺序赋值二进制数</th><th align="center">转换为十进制的grouping__id</th></tr></thead><tbody><tr><td align="center">province,city,sale_date</td><td align="center">000</td><td align="center">0</td></tr><tr><td align="center">province,city</td><td align="center">001</td><td align="center">1</td></tr><tr><td align="center">province,sale_date</td><td align="center">010</td><td align="center">2</td></tr><tr><td align="center">province</td><td align="center">011</td><td align="center">3</td></tr><tr><td align="center">city,sale_date</td><td align="center">100</td><td align="center">4</td></tr><tr><td align="center">city</td><td align="center">101</td><td align="center">5</td></tr><tr><td align="center">sale_date</td><td align="center">110</td><td align="center">6</td></tr><tr><td align="center">无</td><td align="center">111</td><td align="center">7</td></tr></tbody></table><p><strong>测试sql：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">td.province ,</span><br><span class="line">city,</span><br><span class="line">td.sale_date ,</span><br><span class="line"><span class="built_in">sum</span>(sales) <span class="keyword">as</span> sales,</span><br><span class="line">grouping__id</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">travel_data td</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line"><span class="keyword">CUBE</span>(td.province,td.city,td.sale_date)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">grouping__id</span><br></pre></td></tr></table></figure><p>查询结果：</p><p>21146</p><p>从上面的结果可以看到，grouping__id的数值与计算规则得出来的一致。hive2.3版本前关于grouping__id的计算方式可能不同，可以参见<a href="https://blog.csdn.net/Dax1n/article/details/104308886">其他博客</a></p><h1 id="grouping-sets和union-all性能对比"><a href="#grouping-sets和union-all性能对比" class="headerlink" title="grouping sets和union all性能对比"></a>grouping sets和union all性能对比</h1><p><strong>实现逻辑</strong><br>如果说 <code>union all</code>是先聚合再联合，那么 <code>grouping sets</code>就是先联合再聚合。<code>grouping sets</code>根据 <code>N</code>个分组对每条数据进行计算，不在当前分组的字段置为null，将数据量扩展成原来的 <code>N</code>倍，再按 <code>group by</code>的字段做聚合计算。</p><p><code>group by province,city grouping sets ((province,city),province,())</code>计算效果图如下：</p><p>21602</p><p><code>…… group by province,city union all …… group by province</code>计算效果图如下：</p><p>21729</p><p>分析源码，grouping__id在process的时候将newKeysGroupingSets的值赋予具体的行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org/apache/hadoop/hive/ql/exec/GroupByOperator.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Object row, <span class="type">int</span> tag)</span> <span class="keyword">throws</span> HiveException &#123;</span><br><span class="line">……</span><br><span class="line">    <span class="keyword">if</span> (groupingSetsPresent) &#123;</span><br><span class="line">    Object[] newKeysArray = newKeys.getKeyArray();</span><br><span class="line">    Object[] cloneNewKeysArray = <span class="keyword">new</span> <span class="title class_">Object</span>[newKeysArray.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">keyPos</span> <span class="operator">=</span> <span class="number">0</span>; keyPos &lt; groupingSetsPosition; keyPos++) &#123;</span><br><span class="line">    cloneNewKeysArray[keyPos] = newKeysArray[keyPos];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">groupingSetPos</span> <span class="operator">=</span> <span class="number">0</span>; groupingSetPos &lt; groupingSets.size(); groupingSetPos++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">keyPos</span> <span class="operator">=</span> <span class="number">0</span>; keyPos &lt; groupingSetsPosition; keyPos++) &#123;</span><br><span class="line">    newKeysArray[keyPos] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">FastBitSet</span> <span class="variable">bitset</span> <span class="operator">=</span> groupingSetsBitSet[groupingSetPos];</span><br><span class="line">    <span class="comment">// Some keys need to be left to null corresponding to that grouping set.</span></span><br><span class="line">    <span class="comment">// 按照bitSet保留原值，对于group by a, b, c 如果bitSet是010，则表示keyPos为0和2就表示ClearBit，需要保留原值，1其他就为null</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">keyPos</span> <span class="operator">=</span> bitset.nextClearBit(<span class="number">0</span>); keyPos &lt; groupingSetsPosition;</span><br><span class="line">          keyPos = bitset.nextClearBit(keyPos+<span class="number">1</span>)) &#123;</span><br><span class="line">          newKeysArray[keyPos] = cloneNewKeysArray[keyPos];</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 这里就是给当前这条数据赋予GROUPING_ID的值</span></span><br><span class="line">    newKeysArray[groupingSetsPosition] = newKeysGroupingSets[groupingSetPos];</span><br><span class="line">    processKey(row, rowInspector);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    processKey(row, rowInspector);</span><br><span class="line">    &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面通过执行计划分析两种方式的差异。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span></span><br><span class="line">    province,</span><br><span class="line">    city,</span><br><span class="line">    grouping__id</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    travel_data </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">    province,</span><br><span class="line">    city</span><br><span class="line">    <span class="keyword">grouping</span> SETS ((province,city),province,())</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> grouping__id</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>hive执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Explain                                                                                                      |</span><br><span class="line">-------------------------------------------------------------------------------------------------------------+</span><br><span class="line">STAGE DEPENDENCIES:                                                                                          |</span><br><span class="line">  Stage-1 is a root stage                                                                                    |</span><br><span class="line">  Stage-2 depends on stages: Stage-1                                                                         |</span><br><span class="line">  Stage-0 depends on stages: Stage-2                                                                         |</span><br><span class="line">                                                                                                             |</span><br><span class="line">STAGE PLANS:                                                                                                 |</span><br><span class="line">  Stage: Stage-1                                                                                             |</span><br><span class="line">    Map Reduce                                                                                               |</span><br><span class="line">      Map Operator Tree:                                                                                     |</span><br><span class="line">          TableScan                                                                                          |</span><br><span class="line">            alias: travel_data                                                                               |</span><br><span class="line">            Statistics: Num rows: 11 Data size: 597 Basic stats: COMPLETE Column stats: NONE                 |</span><br><span class="line">            Select Operator                                                                                  |</span><br><span class="line">              expressions: province (type: string), city (type: string)                                      |</span><br><span class="line">              outputColumnNames: _col0, _col1                                                                |</span><br><span class="line">              Statistics: Num rows: 11 Data size: 597 Basic stats: COMPLETE Column stats: NONE               |</span><br><span class="line">              Group By Operator                                                                              |</span><br><span class="line">                keys: _col0 (type: string), _col1 (type: string), 0 (type: int)                              |</span><br><span class="line">                mode: hash                                                                                   |</span><br><span class="line">                outputColumnNames: _col0, _col1, _col2                                                       |</span><br><span class="line">                Statistics: Num rows: 33 Data size: 1791 Basic stats: COMPLETE Column stats: NONE            |  这里读取数据后按grouping sets的3个分组维度，将数据由11条扩充为33条</span><br><span class="line">                Reduce Output Operator                                                                       |</span><br><span class="line">                 ……</span><br><span class="line">      Reduce Operator Tree:                                                                                  |</span><br><span class="line">        Group By Operator                                                                                    |</span><br><span class="line">          keys: KEY._col0 (type: string), KEY._col1 (type: string), KEY._col2 (type: int)                    |</span><br><span class="line">          mode: mergepartial                                                                                 |</span><br><span class="line">          outputColumnNames: _col0, _col1, _col2                                                             |</span><br><span class="line">          Statistics: Num rows: 16 Data size: 868 Basic stats: COMPLETE Column stats: NONE                   |</span><br><span class="line">          Select Operator                                                                                    |</span><br><span class="line">            expressions: _col0 (type: string), _col1 (type: string), _col2 (type: int)                       |</span><br><span class="line">            outputColumnNames: _col0, _col1, _col2                                                           |</span><br><span class="line">            Statistics: Num rows: 16 Data size: 868 Basic stats: COMPLETE Column stats: NONE                 |</span><br><span class="line">            ……</span><br><span class="line">                                                                                                             |</span><br><span class="line">  Stage: Stage-2                                                                                             |</span><br><span class="line">    Map Reduce                                                                                               |</span><br><span class="line">      Map Operator Tree:                                                                                     |</span><br><span class="line">          TableScan                                                                                          |</span><br><span class="line">            Reduce Output Operator                                                                           |</span><br><span class="line">              key expressions: _col2 (type: int)                                                             |</span><br><span class="line">              sort order: +                                                                                  |</span><br><span class="line">              Statistics: Num rows: 16 Data size: 868 Basic stats: COMPLETE Column stats: NONE               |</span><br><span class="line">              value expressions: _col0 (type: string), _col1 (type: string)                                  |</span><br><span class="line">      Reduce Operator Tree:                                                                                  |</span><br><span class="line">        Select Operator                                                                                      |</span><br><span class="line">          expressions: VALUE._col0 (type: string), VALUE._col1 (type: string), KEY.reducesinkkey0 (type: int)|  这里KEY.reducesinkkey0即为grouping__id</span><br><span class="line">          outputColumnNames: _col0, _col1, _col2                                                             |</span><br><span class="line">          Statistics: Num rows: 16 Data size: 868 Basic stats: COMPLETE Column stats: NONE                   |</span><br><span class="line">          ……                                                                                        |</span><br><span class="line"> </span><br><span class="line">                                 |</span><br><span class="line">                                                                                                             |</span><br><span class="line">  Stage: Stage-0                                                                                             |</span><br><span class="line">    ……                                                                                   </span><br></pre></td></tr></table></figure><p>从上面的执行计划可以看到，<code>Stage-1</code>在读取数据时，在<code>map</code>阶段根据<code>grouping sets</code>有3个分组维度，将数据量扩充至原来的3倍，然后在<code>reduce</code>阶段做<code>group by province,city</code>操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">province,</span><br><span class="line">city</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">travel_data</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">    province,city</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    province,</span><br><span class="line">    <span class="keyword">NULL</span> <span class="keyword">as</span> city</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">travel_data</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">    province </span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>hive执行计划：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">Explain                                                                                           |</span><br><span class="line">--------------------------------------------------------------------------------------------------+</span><br><span class="line">STAGE DEPENDENCIES:                                                                               |</span><br><span class="line">  Stage-1 is a root stage                                                                         |</span><br><span class="line">  Stage-2 depends on stages: Stage-1, Stage-3                                                     |</span><br><span class="line">  Stage-3 is a root stage                                                                         |</span><br><span class="line">  Stage-0 depends on stages: Stage-2                                                              |</span><br><span class="line">                                                                                                  |</span><br><span class="line">STAGE PLANS:                                                                                      |</span><br><span class="line">  Stage: Stage-1                                                                                  |</span><br><span class="line">    Map Reduce                                                                                    |</span><br><span class="line">      Map Operator Tree:                                                                          |</span><br><span class="line">          TableScan                                                                               |</span><br><span class="line">            alias: travel_data                                                                    |</span><br><span class="line">            Statistics: Num rows: 11 Data size: 597 Basic stats: COMPLETE Column stats: NONE      |</span><br><span class="line">            Select Operator                                                                       |</span><br><span class="line">              expressions: province (type: string), city (type: string)                           |</span><br><span class="line">              outputColumnNames: province, city                                                   |</span><br><span class="line">              Statistics: Num rows: 11 Data size: 597 Basic stats: COMPLETE Column stats: NONE    |</span><br><span class="line">              Group By Operator                                                                   |</span><br><span class="line">                keys: province (type: string), city (type: string)                                |</span><br><span class="line">                mode: hash                                                                        |</span><br><span class="line">                outputColumnNames: _col0, _col1                                                   |</span><br><span class="line">                Statistics: Num rows: 11 Data size: 597 Basic stats: COMPLETE Column stats: NONE  |  这里数据量没有变化</span><br><span class="line">                Reduce Output Operator                                                            |</span><br><span class="line">                  ……</span><br><span class="line">      Reduce Operator Tree:                                                                       |</span><br><span class="line">        Group By Operator                                                                         |</span><br><span class="line">          keys: KEY._col0 (type: string), KEY._col1 (type: string)                                |</span><br><span class="line">          mode: mergepartial                                                                      |</span><br><span class="line">          outputColumnNames: _col0, _col1                                                         |</span><br><span class="line">          Statistics: Num rows: 5 Data size: 271 Basic stats: COMPLETE Column stats: NONE         |</span><br><span class="line">          ……</span><br><span class="line">                                                                                                  |</span><br><span class="line">  Stage: Stage-2                                                                                  |</span><br><span class="line">    Map Reduce                                                                                    |</span><br><span class="line">      Map Operator Tree:                                                                          |</span><br><span class="line">          TableScan                                                                               |</span><br><span class="line">            Union                                                                                 |</span><br><span class="line">              Statistics: Num rows: 10 Data size: 542 Basic stats: COMPLETE Column stats: NONE    |</span><br><span class="line">              ……                  |</span><br><span class="line">          TableScan                                                                               |</span><br><span class="line">            Union                                                                                 |</span><br><span class="line">              Statistics: Num rows: 10 Data size: 542 Basic stats: COMPLETE Column stats: NONE    |</span><br><span class="line">              ……               </span><br><span class="line">  Stage: Stage-3                                                                                  |</span><br><span class="line">    Map Reduce                                                                                    |</span><br><span class="line">      Map Operator Tree:                                                                          |</span><br><span class="line">          TableScan                                                                               |</span><br><span class="line">            alias: travel_data                                                                    |</span><br><span class="line">            Statistics: Num rows: 11 Data size: 597 Basic stats: COMPLETE Column stats: NONE      |</span><br><span class="line">            Select Operator                                                                       |</span><br><span class="line">              expressions: province (type: string)                                                |</span><br><span class="line">              outputColumnNames: province                                                         |</span><br><span class="line">              Statistics: Num rows: 11 Data size: 597 Basic stats: COMPLETE Column stats: NONE    |</span><br><span class="line">              Group By Operator                                                                   |</span><br><span class="line">                keys: province (type: string)                                                     |</span><br><span class="line">                mode: hash                                                                        |</span><br><span class="line">                outputColumnNames: _col0                                                          |</span><br><span class="line">                Statistics: Num rows: 11 Data size: 597 Basic stats: COMPLETE Column stats: NONE  |  这里数据量没有变化</span><br><span class="line">                Reduce Output Operator                                                            |</span><br><span class="line">                  ……</span><br><span class="line">      Reduce Operator Tree:                                                                       |</span><br><span class="line">        Group By Operator                                                                         |</span><br><span class="line">          keys: KEY._col0 (type: string)                                                          |</span><br><span class="line">          mode: mergepartial                                                                      |</span><br><span class="line">          outputColumnNames: _col0                                                                |</span><br><span class="line">          Statistics: Num rows: 5 Data size: 271 Basic stats: COMPLETE Column stats: NONE         |</span><br><span class="line">            ……             </span><br><span class="line">                                                                                                  |</span><br><span class="line">  Stage: Stage-0                                                                                  |</span><br><span class="line">    ……                     </span><br></pre></td></tr></table></figure><p>从上面的执行计划可以看到，<code>Stage-1</code>和<code>Stage-3</code>都是读取数据，再分别按照<code>group by province,city</code>和<code>group by province</code>做聚合操作，最后在<code>Stage-2</code>做<code>union</code>操作合并数据。<code>union all</code>这种写法对表<code>travel_data</code>重复读取两次，查询性能上比<code>grouping sets</code>写法要差些。在集群空闲的情况下，对两种写法的sql分别执行5次，得到如下结果：</p><blockquote><p>grouping sets写法执行5次的耗时:</p><blockquote><p>select province, city, grouping__id from travel_data group by province, city grouping SETS ((province,city),province) order by grouping__id ;</p></blockquote><p>Time taken: 54.807 seconds, Fetched: 6 row(s)<br>Time taken: 56.261 seconds, Fetched: 6 row(s)<br>Time taken: 52.671 seconds, Fetched: 6 row(s)<br>Time taken: 62.945 seconds, Fetched: 6 row(s)<br>Time taken: 57.337 seconds, Fetched: 6 row(s)</p></blockquote><blockquote><p>union all写法执行5次的耗时:</p><blockquote><p>select province,city from travel_data group by province,city union all select province, NULL as city from travel_data group by province;</p></blockquote><p>Time taken: 83.91 seconds, Fetched: 6 row(s)<br>Time taken: 94.466 seconds, Fetched: 6 row(s)<br>Time taken: 86.253 seconds, Fetched: 6 row(s)<br>Time taken: 75.509 seconds, Fetched: 6 row(s)<br>Time taken: 88.633 seconds, Fetched: 6 row(s)</p></blockquote><p>可以算出，<code>grouping sets</code>写法的平均耗时为56.8s，<code>union all</code>写法的平均耗时为85.7s，耗时是前者的1.5倍。</p><p>所以，<code>grouping sets</code>写法的sql不仅在表达上更加简洁，在查询性能上也更加高效。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://juejin.cn/post/7223211123961200700">Hive分析函数详解：GROUPING SETS&#x2F;CUBE&#x2F;ROLLUP</a></p><p><a href="https://zhuanlan.zhihu.com/p/536981356">从源码深入理解 Spark SQL 中的 Grouping Sets 语句</a></p><p><a href="https://zhuanlan.zhihu.com/p/408391394">Hive虚拟列的生成与计算【1】</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文详细整理了关于group by子句的增强聚合语法grouping sets&amp;#x2F;CUBE&amp;#x2F;rollup的具体用法，语法的&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Enhanced+</summary>
      
    
    
    
    <category term="SQL" scheme="https://llye-hub.github.io/categories/SQL/"/>
    
    
    <category term="grouping sets" scheme="https://llye-hub.github.io/tags/grouping-sets/"/>
    
  </entry>
  
  <entry>
    <title>关于数据仓库建设的一些思考</title>
    <link href="https://llye-hub.github.io/posts/49066d40.html"/>
    <id>https://llye-hub.github.io/posts/49066d40.html</id>
    <published>2023-04-14T09:02:13.000Z</published>
    <updated>2023-11-09T13:55:44.299Z</updated>
    
    <content type="html"><![CDATA[<p>基于在海拍客的工作经历，沉淀了一些关于数据仓库的思考，没有框架，想到什么写什么</p><h1 id="数据仓库解决什么问题"><a href="#数据仓库解决什么问题？" class="headerlink" title="数据仓库解决什么问题？"></a>数据仓库解决什么问题？</h1><p>1、避免”烟囱式”开发，减少由于业务变化带来的维护成本<br>烟囱式开发，所有报表都是基于原始数据加工，SQL复杂度高，模型和指标无法复用，大量重复计算逻辑。一但某个业务变化，模型维护成本极高，而且大量的重复计算对资源消耗非常大，极易造成队列阻塞，影响数据产出</p><p>2、统一数据指标口径，保证数据一致性：定义一致、计算口径一致、数据源一致</p><ul><li>中文博大精深，一个简单的中文词经常包含些隐含信息。</li></ul><p>比如交易金额，当需求方说要取今天的交易额的时候，很多时候说的是今天的成功的交易金额，然而在逻辑角度，交易金额指的的订单表上支付金额+优惠券金额，不进行交易状态的条件过滤。</p><ul><li>鸡同鸭讲，说的是两个人沟通时说的不是同一个东西。</li></ul><p>比如订单的发货时间，对于财务业务，指的是订单表中的delivery_time字段，表示的是供货商提供的物流订单后第一次抓取到发货状态的时间；对于门店用户角度，指的是物流表中最终发送到用户手上那个订单的物流的发货时间。</p><p>3、数据结构清晰，方便数据查找和理解<br>数仓的分层设计能明晰每张表的作用域和职责，在需要查询使用时，能快速找到要用的表和理解每个字段的含义</p><h1 id="一些博客文章"><a href="#一些博客文章" class="headerlink" title="一些博客文章"></a>一些博客文章</h1><p><a href="https://blog.51cto.com/u_15259710/2932712">如何避免数仓模型“烟囱式”建设</a></p><p><a href="https://mp.weixin.qq.com/s/U-avCBgYbwStUDe7e1LsqA">数仓常见问题以及解决方案！</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于在海拍客的工作经历，沉淀了一些关于数据仓库的思考，没有框架，想到什么写什么&lt;/p&gt;
&lt;h1 id=&quot;数据仓库解决什么问题&quot;&gt;&lt;a href=&quot;#数据仓库解决什么问题？&quot; class=&quot;headerlink&quot; title=&quot;数据仓库解决什么问题？&quot;&gt;&lt;/a&gt;数据仓库解决什</summary>
      
    
    
    
    <category term="数据仓库" scheme="https://llye-hub.github.io/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>数仓建模之关于流量域建设</title>
    <link href="https://llye-hub.github.io/posts/bbbc8dfb.html"/>
    <id>https://llye-hub.github.io/posts/bbbc8dfb.html</id>
    <published>2023-04-14T08:56:16.000Z</published>
    <updated>2023-05-08T02:05:14.131Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="86f0c8e322a1ed1a6fee70eb74822065d2999a9648c90ea9a4b26bea82e32c21">0ae7e196f2221a75e5346dcbb7e124f3b1b3c5930620d283013007149d4c4935b69ce92f61658828479c839b5ea9198d1bda489f76e02aefb6c8c1b6c4f32fd31f36e698664f02671ce11c574fe5628c2d85825c7895fbc00177c55eaf6dc5335488610a8b88d894b09d84d011efc5134b4573dfbe48ed2bf6c239d1fecd49fc54f965b6c70627686bc4d8b5209339f82930e76524144c0f1b5aaa60eef52f119b05e4136dc067e5e8ca67e8e0772186df70f115b895d7d8f368b79708fb1e4c54851da8d44365f6047c0fad077890a16bdd1a6ce5d908272fbbf4f3ee0664dfd07c0471c47bd5506baa027cb755c66a44a1e7277f99d9e2ee2202bd050c0bff1e7d335c69ba839e217bb9e0d3c3eebe6e72bacfd7dda5938764aa615d6f61ed67ed2b24bdcd393e307a817bb140ddb80654ca6f812585d0c73d00616a462225de61da0fc1629df0558f3ee47d9cecd1800ddc7e1d26428f625b965c2e48ac61c2a647927e16629ad85603f6a9378530d503ae19fbace06786266ea4e64eac41d7f818b58581c1086db366efa626abcfc9b024e24da4a29a84e2109cfe15b3fc4f486af813e69865ed2f2ae6b0b48844db76d51998001273c492f1ba476fb840b757be323d45fc5e3fe94eccb2131d4490c4ca9fda3b8088132ec133e5af1c60a7c297a3496af60720a9f2eeca0cf3cc43f5ddd4af9a1297eb760d777ea0626e3a9ad3e2168591d480999c1e7d13dfeb07f4835a8c12500d23c84a42935d3581287ab81ac6ffc7a61afb2eac4dd07742903b802d69292c3d7c56ffa992fa2556e2fc12cc6e52e60a3effa93e3d295e2b7149769d628962d5157c1d24ae1e28b632e676e76f487194ce8c0a434727916a1b8864513f4d69fa39d6a11d868a01dd69c0af40db273372ca9e8c832fea678c5842f86ee27e302472f3101ffbcbf7acc58cdbd720be68548958012f88480fd3af182ea95d5641a911905cc06e3ae93106941854c87263e3fba2445b0ee9b5e5ef894c1a4bba66165a51e1d256d8d186e704ed5e03ae2708a34c0fd18d12cc364164c8b49862a30ccb66621a9a00e10b911882fa0a44156c9686c81e3d0af11c400cc49f94663aa6db8511244e709be165369752e37546cdf7f5d4426a8a45088b2c546ffddb0710c07bdf0256f1e62514037ffdddb1245e6b6ab90d6503a50236f96dacbbe60d1353df2e9edd3b9ff638e32aa3dd29941692520119ba4ad15b060b64f1fb75bfa9e260011a92286c6033803626c66224641b78cd9d7c6e6b8ce6d3b439dd55e05dc95d4bca8009f5cc4d91aa275b41a3f558acbd64c86ea7ba7ebffaaff75acae85274fe26e0d739cf8cdcbf891c2a81a1c9e7bc3a4be7812357246c8a6ada9174133ebbc096984f8b324d5d2a13bb2a3ca4ca6cb44e971ea79ec807547e4421c5dc012bd4c633f805d07718f3906f4f28b7f2457e4c6d4badb98b7a126f3e170d32635bcca3aaa493acce8ef23435e755908f907c4d2786521d3fc0eba03d272015a567009ded9cf1b1730b8b40c7d3b16d9d9fdb734727e277da59dc74f90d3ab88019fa0f31a42161b568de2f8e79321055ff90c038bc71ae84799c93b9bc40aaa4b0ce38fea856e3479dcae13bcb0972ea996c083ea6d3abd6cb45844127558d16f547fa24c6b600fbd84d747f0590f3058fb1d4c5609c8e1a9b926d7b2f3ef3d119557c8519cb2cf49d6027256b75ff51844347463da6205855fca3987416daa6cff5f216c3dd3f5488d10f76f63cea20ac8c9f40f1ad6f7b87b412f1ce8de19e9a8b413bc57e4f5c3c63f680c7d7f71f31f8922b1907815a3e87e2db2a7433b7a2f93f6dd5b703d8c43ed34ee84e652d7225d0cda6dc1cf28cb8704e4cc70588542d8076d687197f40575d4b178184474d2c5a147b883f0fd88a7081f4947ecfaddece704619ac093393174f43a6808f48e40fffc1fc1d7427374af1b9b4e8fb15f47e7ffec46b7292c75eeedb6ce93c94d4c36c246873c258485a41864fc7a46f8beb92d89c7a76631bc6c7440400a7417b7c151bf482784d6a53a5455501f5bb2b54a74ab67e511a2f10bece2173f7112ad3a0c8f15091c2c47d4ae3855cc64489451368c480c1c90ac71b2361bb9986e528406361bed5f02a4fb96cb6cfe72c1f4c45576ce8c3e27342a0ebfe955789bb237ec99277552b8414761f9b16f102752c1214920120acf1195b569a03c59d137fd0ea84f3c7353e07b997ffd31bee3308e82865c8c2f8dc2890e40334a597a92a8148836004df6043b0b392b589e06788a7d50db7ae5535a667095d024108c1ba4ce20566f6536873142b9f265264ebd22d2f0c088661623aadffe6352a41b171d7ca497764c62d401724befe18cad6fac3e20c032edf3e2d2dc3a238d4e236306f20351b729663c275b680df6cc4cc7e092cb4d38474b5c64308f2e2154bf970bebe78433a8312d0aa3b95f2f4cd60e68719de146ff4759b7c25f65e9877299659fb46b497bde07f779553e11a58313f63f773b6aa0f82dcc3da4b0485fcf5b3653f9d5787b942394ebf39c32e6fb60ecb70b98a58e84304ced0d872ef39c167770187e525257037b02161d860367fee54a5968feb47437d461a3a14c292bc3986d581583d7638445636f15a9d04107079212c85922cefae5f920845a3723ae5c3a80abd1f16b9d0987affce63a11f3a0200b4bdf3a7348e14ce0315c21b3a0e88e12f807a76dd29bd28da5afe2bad26a7e43cfe67ad5a8d84c1fb84fb17243201726a8689d779cf2c54a5791e058edf06c9cdc4c62cfb089df793afe3d2dfb7644b1f96d777a162eff743b07c7ddf2372dd776b6bda368393adad97f4fbbea18ad20bac990f87d0debf5e522337d23ee768842719119b488a7173afc6715ab33cdfbc0336b2b31effe16e41844ca32747be8825de94fb9f7514837160aee9dfb8cb4c3b730bd65c89d5523d40bc3c8bda3a9a151e17bb4856d4fee4726fb3628eda438c0d22b3fced83b2418197b7c9965df8a326f8d6658ca1caa22ad46e3c7e46f943eb1dffc5556ca85a3d618498fbfb5c09b9e4a38e1996bf847a511ac945f8491c46697c516baa9e83634a8b27855e2410a83c610b0937c1f713308ff1c125c73c9929820df66acc9a78415a76cb8d86dcabd91f9e6c02e6d08768a0737b5699ade547a8d090ad96fe38bed82440081c65eb7ca6d86f4b61943372dc98fecfa7cfebc8db6ffb80b1f1c6e4c3536f09446a47a0b5df66f6a4133c9318d01cb5ee1a9226bc4d3aa14e7b901d16bf22bc56aef2b2d5ed66b5c6f159efed8bf2d1555b32a8c7cb445b8fd993611b5947abdd028d636ccd9c4895b5f45aa8826ea917a41fd49dd826ead8b6b4088ae64cffd807288f6a3d168e70cc7893e7cbe88380cb1e813b81db3b3d2bb7e3eb54bc872b29ffc73811163260d95d27efe2d2e8945dd816dce0c3d2807bb10c1055067d9d59fbd54e05d595c38d04f3830bf71b40622f0416e2fcb70b6bfdb55927bac01268bc317ec56e407470cff6b06b3eea63501d35bcb8af3e5487105301a0afde02f6b469dd58a4d252262a5a43ae1fc6492cd1bbe4b7da02e245eccb221eb1f9fd97a48e7c5e908f43af3017ce7d4e291f7a678468583ace28776ac51745251e6b8b16dfe585aacc73bac1db6dd9ebf0cf0b466825df633dfb53021f4dca52972b2d182a3149bebe845c6cc94a5f34a727889e8897dc785d929ba83749ab61ff5594e08f5fa142610ccea383bd9151ccd3a74b9872b288957c0add337f16eb7788fe34597d5598a35fb8872e9e5e206920eb980414fbe3c7f65cf39fa35b419eb17344a2d232ca412009a3788cd4177a72af316fec6ba69a1b76058980a5fcc2480da36895d041c3b4239a6a670d4abee60bc53a9173206d55b4a3452d094387e0213e156ee0580d0e1dd82e6e9bc0288ae9396089d3eef255eb470332d724a5d453a18db7fd0b1137a74d011442c24c15f310d05988d2304afa22a757dfa35857e238baf36b10283dcf811a759b27a3db5fbb60d953cdd42c58e1842b80f346cc4aa82bbf7a85397a5d60e5757f2a44c7bf47fc652555fc85fa11e2623a232ca8560cc93f2929d57955c15137f399563f9b01fc810cf50f4c32287efd131258cab8bd479b5833b3df2d3df6a94ce4fa4c9bf875be24327e59d85c4cbeea7c796381a7bf540bf1f496bc5f958daa7533d86d971602c8dbcfa8bd9c596cddeca84d05c01a1bbae669e6e92a1ea8f1227ba221a86b6c905d0f9df293d27868998607edd2d1ebba12eb9768142eccee0d18cccb25d0aac038be2218e8f64b971d95f341aab5c230acc24d7a03daeaa027a2bf17f5c2c79cf5d7d8a3573b4ea5f44b85a547e64480808a93f0ff4daef8f83fae63ae0a3a0bc32abf3a6bd6285847e2eaab0fb019dba860d7216ba38002ad8a4270496177fa78784c0937ef124b91b0f77b7ff0bb54fc755e5d8fd3f639e0663916ed0aa7d5f287aaa8d4c04f220ed0ddae3d3a3b6166c961d53c4812f3d993e4451d435b32394fe2913a0b239bde9a7b82fb5f1bd720e556d7e4e612260544313fef021e413921265bc69676a64ab45419aeb7f2d678395a9241fcca6db464b3c8481df56c4f10936e95439b667c32082c38a1ecc6cdea745a2f2a668fb64c3727b5f7eed1d4411fe3e0436d085b946cda1a3e01d883e5bf3d40a3ce32305676d00a19d531a4550e5a0cfa5161d301098a1baec7d7ea880f846fafb2006fc100fd632832ef08ad130df1fc5b85e4c519d3f05fa384ccb9b297ddf8ff3ef286e19f29bf5dd0a944f02d3092302b571459e7a07248560d78c9631115d2a52016bce02b00270f048204668e34e88136d7bd1e07696189b41f2f152169c0935e562ff3e735055465a452fb968f2eec318b4a7f438e397a453147c1512d07a0c03a15f3fcdba0799708ba4bc2188559abdddcba6681bf67a414841ed29a363a8f75b6df538ba4e572670b7891aa657180817590019c8d97345022b1d675539f717c39c60424fe20d5a11f44746c33d380556a606c463fc09aa33bc73043c7451cb097714b40527e9e5f4a9f46e1e4f54d2b219e4bcde7047e8254641db8ae94bbdd19e9a11b44e60f0d76cec2802b53708996ea2ec22ef328b524df75d6ec21043c80a41790fb55bc4bee3a6b9e0aef05d44f21e2b53c6e64839a01c750913fe7d18f46e7117fdd9956fe94910959f9c105e4ae06d42843089f7cab106f9785ead20084d2a702fa8468fa97d7aa964be426d3392841d26c434c83cc9b6971ef2b6def987e0588c38909db6f0c33b757dd743387af5f4cb7c08ecf98272e314c85602e21c2561720ccc6d5841e7db5ab0b6a29e97f1d85c60e24d6c7a859fa6990df13</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是一篇加密文章，需要密码才能继续阅读。</summary>
    
    
    
    <category term="数据仓库" scheme="https://llye-hub.github.io/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
    
    <category term="private" scheme="https://llye-hub.github.io/tags/private/"/>
    
    <category term="数仓建模" scheme="https://llye-hub.github.io/tags/%E6%95%B0%E4%BB%93%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>在hive中嵌入自定义数据处理函数-UDF函数</title>
    <link href="https://llye-hub.github.io/posts/cafe49d7.html"/>
    <id>https://llye-hub.github.io/posts/cafe49d7.html</id>
    <published>2023-04-11T09:04:03.000Z</published>
    <updated>2023-04-18T07:45:38.183Z</updated>
    
    
    
    
    <category term="hive" scheme="https://llye-hub.github.io/categories/hive/"/>
    
    
    <category term="写UDF" scheme="https://llye-hub.github.io/tags/%E5%86%99UDF/"/>
    
  </entry>
  
  <entry>
    <title>hiveSQL之全面认识窗口函数</title>
    <link href="https://llye-hub.github.io/posts/ed2327bc.html"/>
    <id>https://llye-hub.github.io/posts/ed2327bc.html</id>
    <published>2023-03-31T02:46:52.000Z</published>
    <updated>2023-04-07T03:23:39.244Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容来自文章<a href="https://mp.weixin.qq.com/s/VnQT-bidnJDduoLfJeRhxA">Hive SQL大厂必考常用窗口函数及面试题</a></p><p>受岗位性质和工作内容影响，在我从事数仓开发工作至今，对于窗口函数的使用场景都很基础，常用的也只有row_number、sum、max&#x2F;min，<br>偶尔碰到些其他场景，因为不熟悉，可能就需要反复查看官方文档确认。</p><p>所以在上面文章阅读过程中，基于个人理解，重新梳理写了本文</p><h1 id="窗口函数概述"><a href="#窗口函数概述" class="headerlink" title="窗口函数概述"></a>窗口函数概述</h1><p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+WindowingAndAnalytics">hive官方介绍</a></p><p>窗口函数也称为OLAP函数，是数据分析最常用到的函数，熟练的掌握窗口函数的各种用法和骚操作对从事数据工作者是很重要的。</p><p>与聚合函数将多条记录聚合为一条不同，窗口函数每条记录都会执行，执行前后数据量不变，且窗口函数兼具分组和排序两种功能。</p><h2 id="窗口函数用法"><a href="#窗口函数用法" class="headerlink" title="窗口函数用法"></a>窗口函数用法</h2><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">窗口函数</span>&gt;</span> over ([partition by <span class="tag">&lt;<span class="name">列名</span>&gt;</span>] [order by <span class="tag">&lt;<span class="name">排序列名</span>&gt;</span>] [window_frame])</span><br></pre></td></tr></table></figure><p>其中：</p><p>&lt;窗口函数&gt;: 指需要使用的分析函数，如row_number()、sum()等。</p><p>over() : 用来指定函数执行的窗口范围，这个数据窗口大小可能会随着行的变化而变化。<br>如果括号中什么都不写，则意味着窗口包含满足where条件的所有行，窗口函数基于所有行进行计算</p><p>window_frame: 在分组窗口基础上，可以进一步指定窗口计算边界</p><h2 id="设置窗口"><a href="#设置窗口" class="headerlink" title="设置窗口"></a>设置窗口</h2><h3 id="1partition-by子句"><a href="#1）partition-by子句" class="headerlink" title="1）partition by子句"></a>1）partition by子句</h3><p>窗口划分分组条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    uid,</span><br><span class="line">    score,</span><br><span class="line">    <span class="built_in">sum</span>(score) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> uid) <span class="keyword">AS</span> sum_score</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br></pre></td></tr></table></figure><h3 id="2order-by子句"><a href="#2）order-by子句" class="headerlink" title="2）order by子句"></a>2）order by子句</h3><p>窗口排序条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    uid,</span><br><span class="line">    score,</span><br><span class="line">    <span class="built_in">sum</span>(score) <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> uid) <span class="keyword">AS</span> sum_score</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br></pre></td></tr></table></figure><h3 id="3指定窗口大小"><a href="#3）指定窗口大小" class="headerlink" title="3）指定窗口大小"></a>3）指定窗口大小</h3><p>指定窗口大小，又称为窗口框架。框架是重新定义窗口计算边界，框架有两种范围限定方式：</p><ul><li><p>一种是使用 ROWS 子句，通过指定当前行之前或之后的固定数目的行来限制分区中的行数。</p></li><li><p>另一种是使用 RANGE 子句，按照排列序列的当前值，根据相同值来确定分区中的行数。</p></li></ul><p>语法<code>ORDER BY 字段名 RANGE|ROWS 边界规则0 | [BETWEEN 边界规则1 AND 边界规则2]</code>，边界规则的可取值如下：</p><ul><li><code>current row</code>：当前行</li><li><code>n preceding</code>：当前行及往前n行数据</li><li><code>unbounded preceding</code>：第一行至当前行数据</li><li><code>n following</code>：当前行及往后n行数据</li><li><code>unbounded following</code>：当前行至最后一行数据</li></ul><p>需要注意的是，</p><ul><li>使用框架时必须有order by子句</li><li>若仅有order by子句而未指定框架，则默认框架语句为<code>range unbounded preceding and current row</code>，<br><a href="https://llye-hub.github.io/posts/5af52219.html">详情见文章</a></li></ul><h3 id="4window_name"><a href="#4）window-name" class="headerlink" title="4）window_name"></a>4）window_name</h3><p>给窗口指定一个别名<code>WINDOW my_window_name AS (PARTITION BY uid ORDER BY score)</code>，<br>适用于一个窗口被多次使用，可以使sql简洁清晰，也易于维护</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    uid,</span><br><span class="line">    score,</span><br><span class="line">    <span class="built_in">rank</span>() <span class="keyword">OVER</span> my_window_name <span class="keyword">AS</span> rk_num,</span><br><span class="line">    <span class="built_in">row_number</span>() <span class="keyword">OVER</span> my_window_name <span class="keyword">AS</span> row_num,</span><br><span class="line">    <span class="built_in">dense_rank</span>() <span class="keyword">OVER</span> my_window_name <span class="keyword">AS</span> dr_num</span><br><span class="line"><span class="keyword">FROM</span> exam_record</span><br><span class="line"><span class="keyword">WHERE</span> score<span class="operator">&gt;=</span><span class="number">60</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> uid</span><br><span class="line"><span class="keyword">WINDOW</span> my_window_name <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> uid <span class="keyword">ORDER</span> <span class="keyword">BY</span> score)</span><br></pre></td></tr></table></figure><h2 id="窗口函数分类"><a href="#窗口函数分类" class="headerlink" title="窗口函数分类"></a>窗口函数分类</h2><p>窗口函数：</p><ul><li>first_value: 返回计算窗口内按排序条件的第一个值，语法<code>first_value(exp_str,true|false)</code></li><li>last_value: 返回计算窗口内按排序条件的最后一个值，语法<code>last_value(exp_str,true|false)</code></li><li>lag: 返回相对当前行，第前n行的数据，语法<code>lag(exp_str,offset,defval) over(partition by .. order by …)</code></li><li>lead: 返回相对当前行，第后n行的数据，语法<code>lead(exp_str,offset,defval) over(partition by .. order by …)</code></li></ul><p>配合over语句使用的聚合函数：</p><ul><li>sum</li><li>count([distinct])</li><li>max</li><li>min</li><li>avg</li></ul><p>分析函数：</p><ul><li>row_number: 连续排序——1、2、3、4</li><li>rank: 并列跳号排序——1、1、3、4</li><li>dense_rank: 并列连续排序——1、1、2、3</li><li>percent_rank: 将某个数值在数据集中的rank()排位作为数据集的百分比值返回，每行按照公式(rank-1) &#x2F; (rows-1)进行计算，百分比值的范围为 0 到 1。<br>可用于计算值在数据集内的相对位置。语法<code>percent_rank(exp_str)</code></li><li>cume_dist: 如果按升序排列，则统计：小于等于当前值的行数&#x2F;总行数。<br>       如果是降序排列，则统计：大于等于当前值的行数&#x2F;总行数。<br>       语法<code>cume_dist(exp_str)</code></li><li>ntiles: 将分组数据按照顺序平均切分成n组，并返回当前切片值。语法<code>ntiles(n)</code>。<br>    如果不能平均分配，则优先分配较小编号的切片，并且各个切片中能放的行数最多相差 1。<br>    可简单理解为，有 n 个桶，按编号 1-n 的顺序逐个将分组数据放到每个桶内，直至数据分配完毕。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文内容来自文章&lt;a href=&quot;https://mp.weixin.qq.com/s/VnQT-bidnJDduoLfJeRhxA&quot;&gt;Hive SQL大厂必考常用窗口函数及面试题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;受岗位性质和工作内容影响，在我从事数仓开发工作至今，对于窗口函数的使用</summary>
      
    
    
    
    <category term="SQL" scheme="https://llye-hub.github.io/categories/SQL/"/>
    
    
    <category term="hiveSQL" scheme="https://llye-hub.github.io/tags/hiveSQL/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记之数据仓库工具箱维度建模权威指南(第3版)</title>
    <link href="https://llye-hub.github.io/posts/4142350a.html"/>
    <id>https://llye-hub.github.io/posts/4142350a.html</id>
    <published>2023-03-29T06:31:37.000Z</published>
    <updated>2023-04-18T08:14:08.029Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="fe1d605873a64a776899cd24903c2cfb2b3f6754276eb8f0e33aa5b5ff6dec62">0ae7e196f2221a75e5346dcbb7e124f36deed831076312fa04e0c81d58c043c17806a367438824993e46b7303f74bdc03c0e9ef99e6f77cba23b77d5795720fb095d0c0e430a499f25eafc1f85fa0f26957e29e45a080da2e8c46c303015a2e2d6358f33b7831aac9e0a2fb3efa003c3cd5eaad97f9f54582e1da9d3f386f64442896e98805a10458108864bf0ef61af265291b4e35171a4ad62b9b68d2af755a6d3a47e23cfd7745f64e906d3d8ee534e387db252f45c508dac4c9ea64049c4a1c46c527800821ef48f838cbb99cc8ee5868166e758e4d826c9191045615239b0bba54723f534af3edc77073e5d173076bcc9d21377398813eebbe67fc13a41ea9b5290197772c51657848492cf450b25cb0fbda050d9f647c76c2ebd3459fd832323e2b8429cc279db814182e50790c0d6be8eb77aeae5900968ddad7ed661712e64bfcdbfc1fef9de209b4c86198573b24d0c8b0c0411af81c363f39c9f2a39a50a4e90b788ba333b563d188038926a4b8395a1fc54527e2e32d417c5ce6f0ab609334238dbf3f9e8a2a14c98c2324bc4e10e89bf085eec861d6b7bb63ba368b0b19eaf6554dce238e24f2eb6adae45ba88b31a41e358062f923d36aa294c5c69aef6cf5bd7e0ac159e04dec4c9afcc6782871a78be29a1af865d6bee02567373df4c8613a2eca0addc868f95d36def19cdf52874a6c37f8a73f02e7406aba0c30837fa9f3f5824054821260a56a37ccd83dc8bf48d55c6aa8a8cf54902233ae65c8539507f899f69cdd4578e899ca62eef20dbc2c62d93024f91675dbb3c44433526d59ccfb6c05b07789cff3c7bd2cc00a1abcb17b4fc14fab6a0e54a9c5468694c93a2b47dcfdffb36940d04ce71a420b1be7b7f34b4d7affc4372014c4022636cd353a115c0cbf51871ba41d55c14f2dac1ac1aaf1bfc8f7ea941568819a2a3fff8d5d45baf70a186d14ab11f375333786ec21e5c2c899504a9ffedba9864a1ed410fc0f58dd54d0200d0c39885ee14a485527caa2873936f60d4f7b84c34cce55e813a133ba372f781098969dacd4822610fb052f127c250bc50751f6f898875e0d8e4f2651497822fe62ce2fd9fcc8a2d157f870d1567e9975390486f1649f47d7bd22d2c47d6e8123f0d9a0867d731624d11c059793bfffcf417442ce4613c032d7fe5dc8b3f3a5dc5928ca0203636dad75632ff16d3a60447404feed43c0abe71f8c230b7448bcbd5a8b2fbb6bc6fde25b66bb65119415b55883fa33045f15360a426b8e57e3d1883b7e275259b408bfe2dbd99489a169defdde7cd9d3f1ebacb81189a59580199edbe0fdc72c80e15ab587b9e14abe0f7e4b635b4bbde877e75ef8b80b5b3330086c5a21104e737d1abae006ac6ca62e5910562b8dd19e83011e5b3099d270b238fc9d281476d06df4ba20b62eaa1db8ab10fb9e767162c78277f2b35ad15ed94a1f93fa9c1350a9b2cc42aec7f1b2742d3dc1deec41b7bdecad8d211b1b61bf6a4fa1a7354c57857f7f3091e64b7997a9392f61fd3d83fa37ebcd824fbd8e228134d72ff5207950a1bb1c83e68c6d7786dddad528cfa8f56cc5bda0195457edeec78abbcb9b8d4c05cc2c61cb0461db5d8954feecc1fe224f19f8756785cc826673959038e4a4800e158887a9dade68e86b099f1687be6418dc3482c001135ecf21d1366dbc41aa1284b08434a6c9612aaeeb6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是一篇加密文章，需要密码才能继续阅读。</summary>
    
    
    
    <category term="阅读笔记" scheme="https://llye-hub.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="private" scheme="https://llye-hub.github.io/tags/private/"/>
    
    <category term="读书笔记" scheme="https://llye-hub.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
